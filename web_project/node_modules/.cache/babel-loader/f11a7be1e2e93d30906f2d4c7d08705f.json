{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar calc = require('./calc');\n/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */\n\n\nmodule.exports = function crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var subplot = xa._id + ya._id;\n  var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];\n  if (!subplotStackOpts) return;\n  var calcTraces = gd.calcdata;\n  var i, j, k, i2, cd, cd0, posj, sumj, norm;\n  var groupOpts, interpolate, groupnorm, posAttr, valAttr;\n  var hasAnyBlanks;\n\n  for (var stackGroup in subplotStackOpts) {\n    groupOpts = subplotStackOpts[stackGroup];\n    var indices = groupOpts.traceIndices; // can get here with no indices if the stack axis is non-numeric\n\n    if (!indices.length) continue;\n    interpolate = groupOpts.stackgaps === 'interpolate';\n    groupnorm = groupOpts.groupnorm;\n\n    if (groupOpts.orientation === 'v') {\n      posAttr = 'x';\n      valAttr = 'y';\n    } else {\n      posAttr = 'y';\n      valAttr = 'x';\n    }\n\n    hasAnyBlanks = new Array(indices.length);\n\n    for (i = 0; i < hasAnyBlanks.length; i++) {\n      hasAnyBlanks[i] = false;\n    } // Collect the complete set of all positions across ALL traces.\n    // Start with the first trace, then interleave items from later traces\n    // as needed.\n    // Fill in mising items as we go.\n\n\n    cd0 = calcTraces[indices[0]];\n    var allPositions = new Array(cd0.length);\n\n    for (i = 0; i < cd0.length; i++) {\n      allPositions[i] = cd0[i][posAttr];\n    }\n\n    for (i = 1; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n\n      for (j = k = 0; j < cd.length; j++) {\n        posj = cd[j][posAttr];\n\n        for (; posj > allPositions[k] && k < allPositions.length; k++) {\n          // the current trace is missing a position from some previous trace(s)\n          insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n          j++;\n        }\n\n        if (posj !== allPositions[k]) {\n          // previous trace(s) are missing a position from the current trace\n          for (i2 = 0; i2 < i; i2++) {\n            insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);\n          }\n\n          allPositions.splice(k, 0, posj);\n        }\n\n        k++;\n      }\n\n      for (; k < allPositions.length; k++) {\n        insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n        j++;\n      }\n    }\n\n    var serieslen = allPositions.length; // stack (and normalize)!\n\n    for (j = 0; j < cd0.length; j++) {\n      sumj = cd0[j][valAttr] = cd0[j].s;\n\n      for (i = 1; i < indices.length; i++) {\n        cd = calcTraces[indices[i]];\n        cd[0].trace._rawLength = cd[0].trace._length;\n        cd[0].trace._length = serieslen;\n        sumj += cd[j].s;\n        cd[j][valAttr] = sumj;\n      }\n\n      if (groupnorm) {\n        norm = (groupnorm === 'fraction' ? sumj : sumj / 100) || 1;\n\n        for (i = 0; i < indices.length; i++) {\n          var cdj = calcTraces[indices[i]][j];\n          cdj[valAttr] /= norm;\n          cdj.sNorm = cdj.s / norm;\n        }\n      }\n    } // autorange\n\n\n    for (i = 0; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n      var trace = cd[0].trace;\n      var ppad = calc.calcMarkerSize(trace, trace._rawLength);\n      var arrayPad = Array.isArray(ppad);\n\n      if (ppad && hasAnyBlanks[i] || arrayPad) {\n        var ppadRaw = ppad;\n        ppad = new Array(serieslen);\n\n        for (j = 0; j < serieslen; j++) {\n          ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;\n        }\n      }\n\n      var x = new Array(serieslen);\n      var y = new Array(serieslen);\n\n      for (j = 0; j < serieslen; j++) {\n        x[j] = cd[j].x;\n        y[j] = cd[j].y;\n      }\n\n      calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad); // while we're here (in a loop over all traces in the stack)\n      // record the orientation, so hover can find it easily\n\n      cd[0].t.orientation = groupOpts.orientation;\n    }\n  }\n};\n\nfunction insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {\n  hasAnyBlanks[traceIndex] = true;\n  var newEntry = {\n    i: null,\n    gap: true,\n    s: 0\n  };\n  newEntry[posAttr] = position;\n  calcTrace.splice(index, 0, newEntry); // Even if we're not interpolating, if one trace has multiple\n  // values at the same position and this trace only has one value there,\n  // we just duplicate that one value rather than insert a zero.\n  // We also make it look like a real point - because it's ambiguous which\n  // one really is the real one!\n\n  if (index && position === calcTrace[index - 1][posAttr]) {\n    var prevEntry = calcTrace[index - 1];\n    newEntry.s = prevEntry.s; // TODO is it going to cause any problems to have multiple\n    // calcdata points with the same index?\n\n    newEntry.i = prevEntry.i;\n    newEntry.gap = prevEntry.gap;\n  } else if (interpolate) {\n    newEntry.s = getInterp(calcTrace, index, position, posAttr);\n  }\n\n  if (!index) {\n    // t and trace need to stay on the first cd entry\n    calcTrace[0].t = calcTrace[1].t;\n    calcTrace[0].trace = calcTrace[1].trace;\n    delete calcTrace[1].t;\n    delete calcTrace[1].trace;\n  }\n}\n\nfunction getInterp(calcTrace, index, position, posAttr) {\n  var pt0 = calcTrace[index - 1];\n  var pt1 = calcTrace[index + 1];\n  if (!pt1) return pt0.s;\n  if (!pt0) return pt1.s;\n  return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/scatter/cross_trace_calc.js"],"names":["calc","require","module","exports","crossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","subplot","_id","subplotStackOpts","_fullLayout","_scatterStackOpts","calcTraces","calcdata","i","j","k","i2","cd","cd0","posj","sumj","norm","groupOpts","interpolate","groupnorm","posAttr","valAttr","hasAnyBlanks","stackGroup","indices","traceIndices","length","stackgaps","orientation","Array","allPositions","insertBlank","splice","serieslen","s","trace","_rawLength","_length","cdj","sNorm","ppad","calcMarkerSize","arrayPad","isArray","ppadRaw","gap","x","y","calcAxisExpansion","t","calcTrace","index","position","traceIndex","newEntry","prevEntry","getInterp","pt0","pt1"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar calc = require('./calc');\n\n/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */\n\nmodule.exports = function crossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var subplot = xa._id + ya._id;\n\n    var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];\n    if(!subplotStackOpts) return;\n\n    var calcTraces = gd.calcdata;\n\n    var i, j, k, i2, cd, cd0, posj, sumj, norm;\n    var groupOpts, interpolate, groupnorm, posAttr, valAttr;\n    var hasAnyBlanks;\n\n    for(var stackGroup in subplotStackOpts) {\n        groupOpts = subplotStackOpts[stackGroup];\n        var indices = groupOpts.traceIndices;\n\n        // can get here with no indices if the stack axis is non-numeric\n        if(!indices.length) continue;\n\n        interpolate = groupOpts.stackgaps === 'interpolate';\n        groupnorm = groupOpts.groupnorm;\n        if(groupOpts.orientation === 'v') {\n            posAttr = 'x';\n            valAttr = 'y';\n        } else {\n            posAttr = 'y';\n            valAttr = 'x';\n        }\n        hasAnyBlanks = new Array(indices.length);\n        for(i = 0; i < hasAnyBlanks.length; i++) {\n            hasAnyBlanks[i] = false;\n        }\n\n        // Collect the complete set of all positions across ALL traces.\n        // Start with the first trace, then interleave items from later traces\n        // as needed.\n        // Fill in mising items as we go.\n        cd0 = calcTraces[indices[0]];\n        var allPositions = new Array(cd0.length);\n        for(i = 0; i < cd0.length; i++) {\n            allPositions[i] = cd0[i][posAttr];\n        }\n\n        for(i = 1; i < indices.length; i++) {\n            cd = calcTraces[indices[i]];\n\n            for(j = k = 0; j < cd.length; j++) {\n                posj = cd[j][posAttr];\n                for(; posj > allPositions[k] && k < allPositions.length; k++) {\n                    // the current trace is missing a position from some previous trace(s)\n                    insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n                    j++;\n                }\n                if(posj !== allPositions[k]) {\n                    // previous trace(s) are missing a position from the current trace\n                    for(i2 = 0; i2 < i; i2++) {\n                        insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);\n                    }\n                    allPositions.splice(k, 0, posj);\n                }\n                k++;\n            }\n            for(; k < allPositions.length; k++) {\n                insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n                j++;\n            }\n        }\n\n        var serieslen = allPositions.length;\n\n        // stack (and normalize)!\n        for(j = 0; j < cd0.length; j++) {\n            sumj = cd0[j][valAttr] = cd0[j].s;\n            for(i = 1; i < indices.length; i++) {\n                cd = calcTraces[indices[i]];\n                cd[0].trace._rawLength = cd[0].trace._length;\n                cd[0].trace._length = serieslen;\n                sumj += cd[j].s;\n                cd[j][valAttr] = sumj;\n            }\n\n            if(groupnorm) {\n                norm = ((groupnorm === 'fraction') ? sumj : (sumj / 100)) || 1;\n                for(i = 0; i < indices.length; i++) {\n                    var cdj = calcTraces[indices[i]][j];\n                    cdj[valAttr] /= norm;\n                    cdj.sNorm = cdj.s / norm;\n                }\n            }\n        }\n\n        // autorange\n        for(i = 0; i < indices.length; i++) {\n            cd = calcTraces[indices[i]];\n            var trace = cd[0].trace;\n            var ppad = calc.calcMarkerSize(trace, trace._rawLength);\n            var arrayPad = Array.isArray(ppad);\n            if((ppad && hasAnyBlanks[i]) || arrayPad) {\n                var ppadRaw = ppad;\n                ppad = new Array(serieslen);\n                for(j = 0; j < serieslen; j++) {\n                    ppad[j] = cd[j].gap ? 0 : (arrayPad ? ppadRaw[cd[j].i] : ppadRaw);\n                }\n            }\n            var x = new Array(serieslen);\n            var y = new Array(serieslen);\n            for(j = 0; j < serieslen; j++) {\n                x[j] = cd[j].x;\n                y[j] = cd[j].y;\n            }\n            calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n\n            // while we're here (in a loop over all traces in the stack)\n            // record the orientation, so hover can find it easily\n            cd[0].t.orientation = groupOpts.orientation;\n        }\n    }\n};\n\nfunction insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {\n    hasAnyBlanks[traceIndex] = true;\n    var newEntry = {\n        i: null,\n        gap: true,\n        s: 0\n    };\n    newEntry[posAttr] = position;\n    calcTrace.splice(index, 0, newEntry);\n    // Even if we're not interpolating, if one trace has multiple\n    // values at the same position and this trace only has one value there,\n    // we just duplicate that one value rather than insert a zero.\n    // We also make it look like a real point - because it's ambiguous which\n    // one really is the real one!\n    if(index && position === calcTrace[index - 1][posAttr]) {\n        var prevEntry = calcTrace[index - 1];\n        newEntry.s = prevEntry.s;\n        // TODO is it going to cause any problems to have multiple\n        // calcdata points with the same index?\n        newEntry.i = prevEntry.i;\n        newEntry.gap = prevEntry.gap;\n    } else if(interpolate) {\n        newEntry.s = getInterp(calcTrace, index, position, posAttr);\n    }\n    if(!index) {\n        // t and trace need to stay on the first cd entry\n        calcTrace[0].t = calcTrace[1].t;\n        calcTrace[0].trace = calcTrace[1].trace;\n        delete calcTrace[1].t;\n        delete calcTrace[1].trace;\n    }\n}\n\nfunction getInterp(calcTrace, index, position, posAttr) {\n    var pt0 = calcTrace[index - 1];\n    var pt1 = calcTrace[index + 1];\n    if(!pt1) return pt0.s;\n    if(!pt0) return pt1.s;\n    return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);\n}\n"]},"metadata":{},"sourceType":"script"}