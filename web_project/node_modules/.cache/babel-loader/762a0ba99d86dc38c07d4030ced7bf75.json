{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\n\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\n\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\n\nvar PlotSchema = require('./plot_schema');\n\nvar Plots = require('../plots/plots');\n\nvar Polar = require('../plots/polar/legacy');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar Drawing = require('../components/drawing');\n\nvar Color = require('../components/color');\n\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\n\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\n\nvar svgTextUtils = require('../lib/svg_text_utils');\n\nvar clearSelect = require('../plots/cartesian/select').clearSelect;\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar manageArrays = require('./manage_arrays');\n\nvar helpers = require('./helpers');\n\nvar subroutines = require('./subroutines');\n\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\n\nfunction plot(gd, data, layout, config) {\n  var frames;\n  gd = Lib.getGraphDiv(gd); // Events.init is idempotent and bails early if gd has already been init'd\n\n  Events.init(gd);\n\n  if (Lib.isPlainObject(data)) {\n    var obj = data;\n    data = obj.data;\n    layout = obj.layout;\n    config = obj.config;\n    frames = obj.frames;\n  }\n\n  var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n  if (okToPlot === false) return Promise.reject(); // if there's no data or layout, and this isn't yet a plotly plot\n  // container, log a warning to help plotly.js users debug\n\n  if (!data && !layout && !Lib.isPlotDiv(gd)) {\n    Lib.warn('Calling Plotly.plot as if redrawing ' + 'but this container doesn\\'t yet have a plot.', gd);\n  }\n\n  function addFrames() {\n    if (frames) {\n      return exports.addFrames(gd, frames);\n    }\n  } // transfer configuration options to gd until we move over to\n  // a more OO like model\n\n\n  setPlotContext(gd, config);\n  if (!layout) layout = {}; // hook class for plots main container (in case of plotly.js\n  // this won't be #embedded-graph or .js-tab-contents)\n\n  d3.select(gd).classed('js-plotly-plot', true); // off-screen getBoundingClientRect testing space,\n  // in #js-plotly-tester (and stored as Drawing.tester)\n  // so we can share cached text across tabs\n\n  Drawing.makeTester(); // collect promises for any async actions during plotting\n  // any part of the plotting code can push to gd._promises, then\n  // before we move to the next step, we check that they're all\n  // complete, and empty out the promise list again.\n\n  if (!Array.isArray(gd._promises)) gd._promises = [];\n  var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data); // if there is already data on the graph, append the new data\n  // if you only want to redraw, pass a non-array for data\n\n  if (Array.isArray(data)) {\n    helpers.cleanData(data);\n    if (graphWasEmpty) gd.data = data;else gd.data.push.apply(gd.data, data); // for routines outside graph_obj that want a clean tab\n    // (rather than appending to an existing one) gd.empty\n    // is used to determine whether to make a new tab\n\n    gd.empty = false;\n  }\n\n  if (!gd.layout || graphWasEmpty) {\n    gd.layout = helpers.cleanLayout(layout);\n  }\n\n  Plots.supplyDefaults(gd);\n  var fullLayout = gd._fullLayout;\n\n  var hasCartesian = fullLayout._has('cartesian'); // Legacy polar plots\n\n\n  if (!fullLayout._has('polar') && data && data[0] && data[0].r) {\n    Lib.log('Legacy polar charts are deprecated!');\n    return plotLegacyPolar(gd, data, layout);\n  } // so we don't try to re-call Plotly.plot from inside\n  // legend and colorbar, if margins changed\n\n\n  fullLayout._replotting = true; // make or remake the framework if we need to\n\n  if (graphWasEmpty || fullLayout._shouldCreateBgLayer) {\n    makePlotFramework(gd);\n\n    if (fullLayout._shouldCreateBgLayer) {\n      delete fullLayout._shouldCreateBgLayer;\n    }\n  } // polar need a different framework\n\n\n  if (gd.framework !== makePlotFramework) {\n    gd.framework = makePlotFramework;\n    makePlotFramework(gd);\n  } // clear gradient defs on each .plot call, because we know we'll loop through all traces\n\n\n  Drawing.initGradients(gd); // save initial show spikes once per graph\n\n  if (graphWasEmpty) Axes.saveShowSpikeInitial(gd); // prepare the data and find the autorange\n  // generate calcdata, if we need to\n  // to force redoing calcdata, just delete it before calling Plotly.plot\n\n  var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n  if (recalc) Plots.doCalcdata(gd); // in case it has changed, attach fullData traces to calcdata\n\n  for (var i = 0; i < gd.calcdata.length; i++) {\n    gd.calcdata[i][0].trace = gd._fullData[i];\n  } // make the figure responsive\n\n\n  if (gd._context.responsive) {\n    if (!gd._responsiveChartHandler) {\n      // Keep a reference to the resize handler to purge it down the road\n      gd._responsiveChartHandler = function () {\n        if (!Lib.isHidden(gd)) Plots.resize(gd);\n      }; // Listen to window resize\n\n\n      window.addEventListener('resize', gd._responsiveChartHandler);\n    }\n  } else {\n    Lib.clearResponsive(gd);\n  }\n  /*\n   * start async-friendly code - now we're actually drawing things\n   */\n\n\n  var oldMargins = Lib.extendFlat({}, fullLayout._size); // draw framework first so that margin-pushing\n  // components can position themselves correctly\n\n  var drawFrameworkCalls = 0;\n\n  function drawFramework() {\n    var basePlotModules = fullLayout._basePlotModules;\n\n    for (var i = 0; i < basePlotModules.length; i++) {\n      if (basePlotModules[i].drawFramework) {\n        basePlotModules[i].drawFramework(gd);\n      }\n    }\n\n    if (!fullLayout._glcanvas && fullLayout._has('gl')) {\n      fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n        key: 'contextLayer',\n        context: true,\n        pick: false\n      }, {\n        key: 'focusLayer',\n        context: false,\n        pick: false\n      }, {\n        key: 'pickLayer',\n        context: false,\n        pick: true\n      }], function (d) {\n        return d.key;\n      });\n\n      fullLayout._glcanvas.enter().append('canvas').attr('class', function (d) {\n        return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n      }).style({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        overflow: 'visible',\n        'pointer-events': 'none'\n      });\n    }\n\n    if (fullLayout._glcanvas) {\n      fullLayout._glcanvas.attr('width', fullLayout.width).attr('height', fullLayout.height);\n\n      var regl = fullLayout._glcanvas.data()[0].regl;\n\n      if (regl) {\n        // Unfortunately, this can happen when relayouting to large\n        // width/height on some browsers.\n        if (Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight) {\n          var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n\n          if (drawFrameworkCalls) {\n            Lib.error(msg);\n          } else {\n            Lib.log(msg + ' Clearing graph and plotting again.');\n            Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n            Plots.supplyDefaults(gd);\n            fullLayout = gd._fullLayout;\n            Plots.doCalcdata(gd);\n            drawFrameworkCalls++;\n            return drawFramework();\n          }\n        }\n      }\n    }\n\n    if (fullLayout.modebar.orientation === 'h') {\n      fullLayout._modebardiv.style('height', null).style('width', '100%');\n    } else {\n      fullLayout._modebardiv.style('width', null).style('height', fullLayout.height + 'px');\n    }\n\n    return Plots.previousPromises(gd);\n  } // draw anything that can affect margins.\n\n\n  function marginPushers() {\n    // First reset the list of things that are allowed to change the margins\n    // So any deleted traces or components will be wiped out of the\n    // automargin calculation.\n    // This means *every* margin pusher must be listed here, even if it\n    // doesn't actually try to push the margins until later.\n    Plots.clearAutoMarginIds(gd);\n    subroutines.drawMarginPushers(gd);\n    Axes.allowAutoMargin(gd); // TODO can this be moved elsewhere?\n\n    if (fullLayout._has('pie')) {\n      var fullData = gd._fullData;\n\n      for (var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if (trace.type === 'pie' && trace.automargin) {\n          Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n        }\n      }\n    }\n\n    Plots.doAutoMargin(gd);\n    return Plots.previousPromises(gd);\n  } // in case the margins changed, draw margin pushers again\n\n\n  function marginPushersAgain() {\n    if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n    return Lib.syncOrAsync([marginPushers, subroutines.layoutStyles], gd);\n  }\n\n  function positionAndAutorange() {\n    if (!recalc) {\n      doAutoRangeAndConstraints();\n      return;\n    } // TODO: autosize extra for text markers and images\n    // see https://github.com/plotly/plotly.js/issues/1111\n\n\n    return Lib.syncOrAsync([Registry.getComponentMethod('shapes', 'calcAutorange'), Registry.getComponentMethod('annotations', 'calcAutorange'), doAutoRangeAndConstraints], gd);\n  }\n\n  function doAutoRangeAndConstraints() {\n    if (gd._transitioning) return;\n    subroutines.doAutoRangeAndConstraints(gd); // store initial ranges *after* enforcing constraints, otherwise\n    // we will never look like we're at the initial ranges\n\n    if (graphWasEmpty) Axes.saveRangeInitial(gd); // this one is different from shapes/annotations calcAutorange\n    // the others incorporate those components into ax._extremes,\n    // this one actually sets the ranges in rangesliders.\n\n    Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n  } // draw ticks, titles, and calculate axis scaling (._b, ._m)\n\n\n  function drawAxes() {\n    return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n  }\n\n  var seq = [Plots.previousPromises, addFrames, drawFramework, marginPushers, marginPushersAgain];\n  if (hasCartesian) seq.push(positionAndAutorange);\n  seq.push(subroutines.layoutStyles);\n  if (hasCartesian) seq.push(drawAxes);\n  seq.push(subroutines.drawData, subroutines.finalDraw, initInteractions, Plots.addLinks, Plots.rehover, Plots.redrag, // TODO: doAutoMargin is only needed here for axis automargin, which\n  // happens outside of marginPushers where all the other automargins are\n  // calculated. Would be much better to separate margin calculations from\n  // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n  Plots.doAutoMargin, Plots.previousPromises); // even if everything we did was synchronous, return a promise\n  // so that the caller doesn't care which route we took\n\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    emitAfterPlot(gd);\n    return gd;\n  });\n}\n\nfunction emitAfterPlot(gd) {\n  var fullLayout = gd._fullLayout;\n\n  if (fullLayout._redrawFromAutoMarginCount) {\n    fullLayout._redrawFromAutoMarginCount--;\n  } else {\n    gd.emit('plotly_afterplot');\n  }\n}\n\nfunction setPlotConfig(obj) {\n  return Lib.extendFlat(dfltConfig, obj);\n}\n\nfunction setBackground(gd, bgColor) {\n  try {\n    gd._fullLayout._paper.style('background', bgColor);\n  } catch (e) {\n    Lib.error(e);\n  }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n  var blend = Color.combine(bgColor, 'white');\n  setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n  if (!gd._context) {\n    gd._context = Lib.extendDeep({}, dfltConfig); // stash <base> href, used to make robust clipPath URLs\n\n    var base = d3.select('base');\n    gd._context._baseUrl = base.size() && base.attr('href') ? window.location.href.split('#')[0] : '';\n  }\n\n  var context = gd._context;\n  var i, keys, key;\n\n  if (config) {\n    keys = Object.keys(config);\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      if (key === 'editable' || key === 'edits') continue;\n\n      if (key in context) {\n        if (key === 'setBackground' && config[key] === 'opaque') {\n          context[key] = opaqueSetBackground;\n        } else {\n          context[key] = config[key];\n        }\n      }\n    } // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n\n\n    if (config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n      context.plotGlPixelRatio = context.plot3dPixelRatio;\n    } // now deal with editable and edits - first editable overrides\n    // everything, then edits refines\n\n\n    var editable = config.editable;\n\n    if (editable !== undefined) {\n      // we're not going to *use* context.editable, we're only going to\n      // use context.edits... but keep it for the record\n      context.editable = editable;\n      keys = Object.keys(context.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        context.edits[keys[i]] = editable;\n      }\n    }\n\n    if (config.edits) {\n      keys = Object.keys(config.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n\n        if (key in context.edits) {\n          context.edits[key] = config.edits[key];\n        }\n      }\n    } // not part of the user-facing config options\n\n\n    context._exportedPlot = config._exportedPlot;\n  } // staticPlot forces a bunch of others:\n\n\n  if (context.staticPlot) {\n    context.editable = false;\n    context.edits = {};\n    context.autosizable = false;\n    context.scrollZoom = false;\n    context.doubleClick = false;\n    context.showTips = false;\n    context.showLink = false;\n    context.displayModeBar = false;\n  } // make sure hover-only devices have mode bar visible\n\n\n  if (context.displayModeBar === 'hover' && !hasHover) {\n    context.displayModeBar = true;\n  } // default and fallback for setBackground\n\n\n  if (context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n    context.setBackground = setBackground;\n  } // Check if gd has a specified widht/height to begin with\n\n\n  context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n  context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0; // fill context._scrollZoom helper to help manage scrollZoom flaglist\n\n  var szIn = context.scrollZoom;\n  var szOut = context._scrollZoom = {};\n\n  if (szIn === true) {\n    szOut.cartesian = 1;\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  } else if (typeof szIn === 'string') {\n    var parts = szIn.split('+');\n\n    for (i = 0; i < parts.length; i++) {\n      szOut[parts[i]] = 1;\n    }\n  } else if (szIn !== false) {\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  }\n}\n\nfunction plotLegacyPolar(gd, data, layout) {\n  // build or reuse the container skeleton\n  var plotContainer = d3.select(gd).selectAll('.plot-container').data([0]);\n  plotContainer.enter().insert('div', ':first-child').classed('plot-container plotly', true);\n  var paperDiv = plotContainer.selectAll('.svg-container').data([0]);\n  paperDiv.enter().append('div').classed('svg-container', true).style('position', 'relative'); // empty it everytime for now\n\n  paperDiv.html(''); // fulfill gd requirements\n\n  if (data) gd.data = data;\n  if (layout) gd.layout = layout;\n  Polar.manager.fillLayout(gd); // resize canvas\n\n  paperDiv.style({\n    width: gd._fullLayout.width + 'px',\n    height: gd._fullLayout.height + 'px'\n  }); // instantiate framework\n\n  gd.framework = Polar.manager.framework(gd); // plot\n\n  gd.framework({\n    data: gd.data,\n    layout: gd.layout\n  }, paperDiv.node()); // set undo point\n\n  gd.framework.setUndoPoint(); // get the resulting svg for extending it\n\n  var polarPlotSVG = gd.framework.svg(); // editable title\n\n  var opacity = 1;\n  var txt = gd._fullLayout.title ? gd._fullLayout.title.text : '';\n  if (txt === '' || !txt) opacity = 0;\n\n  var titleLayout = function () {\n    this.call(svgTextUtils.convertToTspans, gd); // TODO: html/mathjax\n    // TODO: center title\n  };\n\n  var title = polarPlotSVG.select('.title-group text').call(titleLayout);\n\n  if (gd._context.edits.titleText) {\n    var placeholderText = Lib._(gd, 'Click to enter Plot title');\n\n    if (!txt || txt === placeholderText) {\n      opacity = 0.2; // placeholder is not going through convertToTspans\n      // so needs explicit data-unformatted\n\n      title.attr({\n        'data-unformatted': placeholderText\n      }).text(placeholderText).style({\n        opacity: opacity\n      }).on('mouseover.opacity', function () {\n        d3.select(this).transition().duration(100).style('opacity', 1);\n      }).on('mouseout.opacity', function () {\n        d3.select(this).transition().duration(1000).style('opacity', 0);\n      });\n    }\n\n    var setContenteditable = function () {\n      this.call(svgTextUtils.makeEditable, {\n        gd: gd\n      }).on('edit', function (text) {\n        gd.framework({\n          layout: {\n            title: {\n              text: text\n            }\n          }\n        });\n        this.text(text).call(titleLayout);\n        this.call(setContenteditable);\n      }).on('cancel', function () {\n        var txt = this.attr('data-unformatted');\n        this.text(txt).call(titleLayout);\n      });\n    };\n\n    title.call(setContenteditable);\n  }\n\n  gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n\n  Plots.addLinks(gd);\n  return Promise.resolve();\n} // convenience function to force a full redraw, mostly for use by plotly.js\n\n\nfunction redraw(gd) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  helpers.cleanData(gd.data);\n  helpers.cleanLayout(gd.layout);\n  gd.calcdata = undefined;\n  return exports.plot(gd).then(function () {\n    gd.emit('plotly_redraw');\n    return gd;\n  });\n}\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\n\n\nfunction newPlot(gd, data, layout, config) {\n  gd = Lib.getGraphDiv(gd); // remove gl contexts\n\n  Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n  Plots.purge(gd);\n  return exports.plot(gd, data, layout, config);\n}\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\n\n\nfunction positivifyIndices(indices, maxIndex) {\n  var parentLength = maxIndex + 1;\n  var positiveIndices = [];\n  var i;\n  var index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n\n    if (index < 0) {\n      positiveIndices.push(parentLength + index);\n    } else {\n      positiveIndices.push(index);\n    }\n  }\n\n  return positiveIndices;\n}\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\n\n\nfunction assertIndexArray(gd, indices, arrayName) {\n  var i, index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i]; // validate that indices are indeed integers\n\n    if (index !== parseInt(index, 10)) {\n      throw new Error('all values in ' + arrayName + ' must be integers');\n    } // check that all indices are in bounds for given gd.data array length\n\n\n    if (index >= gd.data.length || index < -gd.data.length) {\n      throw new Error(arrayName + ' must be valid indices for gd.data.');\n    } // check that indices aren't repeated\n\n\n    if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n      throw new Error('each index in ' + arrayName + ' must be unique.');\n    }\n  }\n}\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\n\n\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // validate currentIndices array\n\n\n  if (typeof currentIndices === 'undefined') {\n    throw new Error('currentIndices is a required argument.');\n  } else if (!Array.isArray(currentIndices)) {\n    currentIndices = [currentIndices];\n  }\n\n  assertIndexArray(gd, currentIndices, 'currentIndices'); // validate newIndices array if it exists\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined') {\n    assertIndexArray(gd, newIndices, 'newIndices');\n  } // check currentIndices and newIndices are the same length if newIdices exists\n\n\n  if (typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n    throw new Error('current and new indices must be of equal length.');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\n\n\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n  var i, value; // check that gd has attribute 'data' and 'data' is array\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // make sure traces exists\n\n\n  if (typeof traces === 'undefined') {\n    throw new Error('traces must be defined.');\n  } // make sure traces is an array\n\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure each value in traces is an object\n\n\n  for (i = 0; i < traces.length; i++) {\n    value = traces[i];\n\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n      throw new Error('all values in traces array must be non-array objects');\n    }\n  } // make sure we have an index for each trace\n\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n    throw new Error('if indices is specified, traces.length must equal indices.length');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\n\n\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array');\n  }\n\n  if (!Lib.isPlainObject(update)) {\n    throw new Error('update must be a key:value object');\n  }\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers');\n  }\n\n  assertIndexArray(gd, indices, 'indices');\n\n  for (var key in update) {\n    /*\n     * Verify that the attribute to be updated contains as many trace updates\n     * as indices. Failure must result in throw and no-op\n     */\n    if (!Array.isArray(update[key]) || update[key].length !== indices.length) {\n      throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n    }\n    /*\n     * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n     */\n\n\n    if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update[key].length)) {\n      throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' + 'corrispondence with the keys and number of traces in the update object');\n    }\n  }\n}\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\n\n\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  var updateProps = [];\n  var trace, target, prop, insert, maxp; // allow scalar index to represent a single trace position\n\n  if (!Array.isArray(indices)) indices = [indices]; // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // loop through all update keys and traces and harvest validated data.\n\n  for (var key in update) {\n    for (var j = 0; j < indices.length; j++) {\n      /*\n       * Choose the trace indexed by the indices map argument and get the prop setter-getter\n       * instance that references the key and value for this particular trace.\n       */\n      trace = gd.data[indices[j]];\n      prop = nestedProperty(trace, key);\n      /*\n       * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n       * Target must exist as an Array to allow the extend operation to be performed.\n       */\n\n      target = prop.get();\n      insert = update[key][j];\n\n      if (!Lib.isArrayOrTypedArray(insert)) {\n        throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n      }\n\n      if (!Lib.isArrayOrTypedArray(target)) {\n        throw new Error('cannot extend missing or non-array attribute: ' + key);\n      }\n\n      if (target.constructor !== insert.constructor) {\n        throw new Error('cannot extend array with an array of a different type: ' + key);\n      }\n      /*\n       * maxPoints may be an object map or a scalar. If object select the key:value, else\n       * Use the scalar maxPoints for all key and trace combinations.\n       */\n\n\n      maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints; // could have chosen null here, -1 just tells us to not take a window\n\n      if (!isNumeric(maxp)) maxp = -1;\n      /*\n       * Wrap the nestedProperty in an object containing required data\n       * for lengthening and windowing this particular trace - key combination.\n       * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n       */\n\n      updateProps.push({\n        prop: prop,\n        target: target,\n        insert: insert,\n        maxp: Math.floor(maxp)\n      });\n    }\n  } // all target and insertion data now validated\n\n\n  return updateProps;\n}\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\n\n\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n  assertExtendTracesArgs(gd, update, indices, maxPoints);\n  var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n  var undoUpdate = {};\n  var undoPoints = {};\n\n  for (var i = 0; i < updateProps.length; i++) {\n    var prop = updateProps[i].prop;\n    var maxp = updateProps[i].maxp; // return new array and remainder\n\n    var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n    prop.set(out[0]); // build the inverse update object for the undo operation\n\n    if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n    undoUpdate[prop.astr].push(out[1]); // build the matching maxPoints undo object containing original trace lengths\n\n    if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n    undoPoints[prop.astr].push(updateProps[i].target.length);\n  }\n\n  return {\n    update: undoUpdate,\n    maxPoints: undoPoints\n  };\n}\n\nfunction concatTypedArray(arr0, arr1) {\n  var arr2 = new arr0.constructor(arr0.length + arr1.length);\n  arr2.set(arr0);\n  arr2.set(arr1, arr0.length);\n  return arr2;\n}\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\n\n\nfunction extendTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp < 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(target, insert);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target);\n          remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          var targetBegin = target.length - numberOfItemsFromTarget;\n          newArray.set(target.subarray(targetBegin));\n          newArray.set(insert, numberOfItemsFromTarget);\n          remainder.set(target.subarray(0, targetBegin));\n        }\n      }\n    } else {\n      newArray = target.concat(insert);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n  return promise;\n}\n\nfunction prependTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp <= 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(insert, target);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n          remainder.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target, numberOfItemsFromInsert);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          newArray.set(insert);\n          newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n          remainder.set(target.subarray(numberOfItemsFromTarget));\n        }\n      }\n    } else {\n      newArray = insert.concat(target);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n  return promise;\n}\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\n\n\nfunction addTraces(gd, traces, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var currentIndices = [];\n  var undoFunc = exports.deleteTraces;\n  var redoFunc = addTraces;\n  var undoArgs = [gd, currentIndices];\n  var redoArgs = [gd, traces]; // no newIndices here\n\n  var i;\n  var promise; // all validation is done elsewhere to remove clutter here\n\n  checkAddTracesArgs(gd, traces, newIndices); // make sure traces is an array\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure traces do not repeat existing ones\n\n\n  traces = traces.map(function (trace) {\n    return Lib.extendFlat({}, trace);\n  });\n  helpers.cleanData(traces); // add the traces to gd.data (no redrawing yet!)\n\n  for (i = 0; i < traces.length; i++) {\n    gd.data.push(traces[i]);\n  } // to continue, we need to call moveTraces which requires currentIndices\n\n\n  for (i = 0; i < traces.length; i++) {\n    currentIndices.push(-traces.length + i);\n  } // if the user didn't define newIndices, they just want the traces appended\n  // i.e., we can simply redraw and be done\n\n\n  if (typeof newIndices === 'undefined') {\n    promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    return promise;\n  } // make sure indices is property defined\n\n\n  if (!Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  try {\n    // this is redundant, but necessary to not catch later possible errors!\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n  } catch (error) {\n    // something went wrong, reset gd to be safe and rethrow error\n    gd.data.splice(gd.data.length - traces.length, traces.length);\n    throw error;\n  } // if we're here, the user has defined specific places to place the new traces\n  // this requires some extra work that moveTraces will do\n\n\n  Queue.startSequence(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  promise = exports.moveTraces(gd, currentIndices, newIndices);\n  Queue.stopSequence(gd);\n  return promise;\n}\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\n\n\nfunction deleteTraces(gd, indices) {\n  gd = Lib.getGraphDiv(gd);\n  var traces = [];\n  var undoFunc = exports.addTraces;\n  var redoFunc = deleteTraces;\n  var undoArgs = [gd, traces, indices];\n  var redoArgs = [gd, indices];\n  var i;\n  var deletedTrace; // make sure indices are defined\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers.');\n  } else if (!Array.isArray(indices)) {\n    indices = [indices];\n  }\n\n  assertIndexArray(gd, indices, 'indices'); // convert negative indices to positive indices\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // we want descending here so that splicing later doesn't affect indexing\n\n  indices.sort(Lib.sorterDes);\n\n  for (i = 0; i < indices.length; i += 1) {\n    deletedTrace = gd.data.splice(indices[i], 1)[0];\n    traces.push(deletedTrace);\n  }\n\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\n\n\nfunction moveTraces(gd, currentIndices, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var newData = [];\n  var movingTraceMap = [];\n  var undoFunc = moveTraces;\n  var redoFunc = moveTraces;\n  var undoArgs = [gd, newIndices, currentIndices];\n  var redoArgs = [gd, currentIndices, newIndices];\n  var i; // to reduce complexity here, check args elsewhere\n  // this throws errors where appropriate\n\n  checkMoveTracesArgs(gd, currentIndices, newIndices); // make sure currentIndices is an array\n\n  currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices]; // if undefined, define newIndices to point to the end of gd.data array\n\n  if (typeof newIndices === 'undefined') {\n    newIndices = [];\n\n    for (i = 0; i < currentIndices.length; i++) {\n      newIndices.push(-currentIndices.length + i);\n    }\n  } // make sure newIndices is an array if it's user-defined\n\n\n  newIndices = Array.isArray(newIndices) ? newIndices : [newIndices]; // convert negative indices to positive indices (they're the same length)\n\n  currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n  newIndices = positivifyIndices(newIndices, gd.data.length - 1); // at this point, we've coerced the index arrays into predictable forms\n  // get the traces that aren't being moved around\n\n  for (i = 0; i < gd.data.length; i++) {\n    // if index isn't in currentIndices, include it in ignored!\n    if (currentIndices.indexOf(i) === -1) {\n      newData.push(gd.data[i]);\n    }\n  } // get a mapping of indices to moving traces\n\n\n  for (i = 0; i < currentIndices.length; i++) {\n    movingTraceMap.push({\n      newIndex: newIndices[i],\n      trace: gd.data[currentIndices[i]]\n    });\n  } // reorder this mapping by newIndex, ascending\n\n\n  movingTraceMap.sort(function (a, b) {\n    return a.newIndex - b.newIndex;\n  }); // now, add the moving traces back in, in order!\n\n  for (i = 0; i < movingTraceMap.length; i += 1) {\n    newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n  }\n\n  gd.data = newData;\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\n\n\nfunction restyle(gd, astr, val, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n  if (typeof astr === 'string') aobj[astr] = val;else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = Lib.extendFlat({}, astr);\n    if (_traces === undefined) _traces = val;\n  } else {\n    Lib.warn('Restyle fail.', astr, val, _traces);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var specs = _restyle(gd, aobj, traces);\n\n  var flags = specs.flags; // clear calcdata and/or axis types if required so they get regenerated\n\n  if (flags.calc) gd.calcdata = undefined;\n  if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {}); // fill in redraw sequence\n\n  var seq = [];\n\n  if (flags.fullReplot) {\n    seq.push(exports.plot);\n  } else {\n    seq.push(Plots.previousPromises); // maybe only call Plots.supplyDataDefaults in the splom case,\n    // to skip over long and slow axes defaults\n\n    Plots.supplyDefaults(gd);\n\n    if (flags.markerSize) {\n      Plots.doCalcdata(gd);\n      addAxRangeSequence(seq); // TODO\n      // if all axes have autorange:false, then\n      // proceed to subroutines.doTraceStyle(),\n      // otherwise we must go through addAxRangeSequence,\n      // which in general must redraws 'all' axes\n    }\n\n    if (flags.style) seq.push(subroutines.doTraceStyle);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, restyle, [gd, specs.undoit, specs.traces], restyle, [gd, specs.redoit, specs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    gd.emit('plotly_restyle', specs.eventData);\n    return gd;\n  });\n} // for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\n\n\nfunction undefinedToNull(val) {\n  if (val === undefined) return null;\n  return val;\n}\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\n\n\nfunction makeNP(preGUI, guiEditFlag) {\n  if (!guiEditFlag) return nestedProperty;\n  return function (container, attr, prefix) {\n    var np = nestedProperty(container, attr);\n    var npSet = np.set;\n\n    np.set = function (val) {\n      var fullAttr = (prefix || '') + attr;\n      storeCurrent(fullAttr, np.get(), val, preGUI);\n      npSet(val);\n    };\n\n    return np;\n  };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n  if (Array.isArray(val) || Array.isArray(newVal)) {\n    var arrayVal = Array.isArray(val) ? val : [];\n    var arrayNew = Array.isArray(newVal) ? newVal : [];\n    var maxLen = Math.max(arrayVal.length, arrayNew.length);\n\n    for (var i = 0; i < maxLen; i++) {\n      storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n    }\n  } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n    var objVal = Lib.isPlainObject(val) ? val : {};\n    var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n    var objBoth = Lib.extendFlat({}, objVal, objNew);\n\n    for (var key in objBoth) {\n      storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n    }\n  } else if (preGUI[attr] === undefined) {\n    preGUI[attr] = undefinedToNull(val);\n  }\n}\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\n\n\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n  for (var attr in edits) {\n    var np = nestedProperty(container, attr);\n    storeCurrent(attr, np.get(), edits[attr], preGUI);\n  }\n}\n\nfunction _restyle(gd, aobj, traces) {\n  var fullLayout = gd._fullLayout;\n  var fullData = gd._fullData;\n  var data = gd.data;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var i;\n  cleanDeprecatedAttributeKeys(aobj); // initialize flags\n\n  var flags = editTypes.traceFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {};\n  var axlist; // make a new empty vals array for undoit\n\n  function a0() {\n    return traces.map(function () {\n      return undefined;\n    });\n  } // for autoranging multiple axes\n\n\n  function addToAxlist(axid) {\n    var axName = Axes.id2name(axid);\n    if (axlist.indexOf(axName) === -1) axlist.push(axName);\n  }\n\n  function autorangeAttr(axName) {\n    return 'LAYOUT' + axName + '.autorange';\n  }\n\n  function rangeAttr(axName) {\n    return 'LAYOUT' + axName + '.range';\n  }\n\n  function getFullTrace(traceIndex) {\n    // usually fullData maps 1:1 onto data, but with groupby transforms\n    // the fullData index can be greater. Take the *first* matching trace.\n    for (var j = traceIndex; j < fullData.length; j++) {\n      if (fullData[j]._input === data[traceIndex]) return fullData[j];\n    } // should never get here - and if we *do* it should cause an error\n    // later on undefined fullTrace is passed to nestedProperty.\n\n  } // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // val=null will delete the attribute\n  // attr can be an array to set several at once (all to the same val)\n\n\n  function doextra(attr, val, i) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val, i);\n      });\n      return;\n    } // quit if explicitly setting this elsewhere\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var extraparam;\n\n    if (attr.substr(0, 6) === 'LAYOUT') {\n      extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n    } else {\n      var tracei = traces[i];\n\n      var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n\n      extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n    }\n\n    if (!(attr in undoit)) {\n      undoit[attr] = a0();\n    }\n\n    if (undoit[attr][i] === undefined) {\n      undoit[attr][i] = undefinedToNull(extraparam.get());\n    }\n\n    if (val !== undefined) {\n      extraparam.set(val);\n    }\n  }\n\n  function allBins(binAttr) {\n    return function (j) {\n      return fullData[j][binAttr];\n    };\n  }\n\n  function arrayBins(binAttr) {\n    return function (vij, j) {\n      return vij === false ? fullData[traces[j]][binAttr] : null;\n    };\n  } // now make the changes to gd.data (and occasionally gd.layout)\n  // and figure out what kind of graphics update we need to do\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var vi = aobj[ai];\n    var cont;\n    var contFull;\n    var param;\n    var oldVal;\n    var newVal;\n    var valObject; // Backward compatibility shim for turning histogram autobin on,\n    // or freezing previous autobinned values.\n    // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n    // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n\n    if (ai === 'autobinx' || ai === 'autobiny') {\n      ai = ai.charAt(ai.length - 1) + 'bins';\n      if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));else if (vi === false) vi = traces.map(allBins(ai));else vi = null;\n    }\n\n    redoit[ai] = vi;\n\n    if (ai.substr(0, 6) === 'LAYOUT') {\n      param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n      undoit[ai] = [undefinedToNull(param.get())]; // since we're allowing val to be an array, allow it here too,\n      // even though that's meaningless\n\n      param.set(Array.isArray(vi) ? vi[0] : vi); // ironically, the layout attrs in restyle only require replot,\n      // not relayout\n\n      flags.calc = true;\n      continue;\n    } // set attribute in gd.data\n\n\n    undoit[ai] = a0();\n\n    for (i = 0; i < traces.length; i++) {\n      cont = data[traces[i]];\n      contFull = getFullTrace(traces[i]);\n      var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n      param = makeNP(preGUI, guiEditFlag)(cont, ai);\n      oldVal = param.get();\n      newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n      if (newVal === undefined) continue;\n      var finalPart = param.parts[param.parts.length - 1];\n      var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n      var prefixDot = prefix ? prefix + '.' : '';\n      var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;\n      valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n      if (valObject && valObject.impliedEdits && newVal !== null) {\n        for (var impliedKey in valObject.impliedEdits) {\n          doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n        }\n      } else if ((finalPart === 'thicknessmode' || finalPart === 'lenmode') && oldVal !== newVal && (newVal === 'fraction' || newVal === 'pixels') && innerContFull) {\n        // changing colorbar size modes,\n        // make the resulting size not change\n        // note that colorbar fractional sizing is based on the\n        // original plot size, before anything (like a colorbar)\n        // increases the margins\n        var gs = fullLayout._size;\n        var orient = innerContFull.orient;\n        var topOrBottom = orient === 'top' || orient === 'bottom';\n\n        if (finalPart === 'thicknessmode') {\n          var thicknorm = topOrBottom ? gs.h : gs.w;\n          doextra(prefixDot + 'thickness', innerContFull.thickness * (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n        } else {\n          var lennorm = topOrBottom ? gs.w : gs.h;\n          doextra(prefixDot + 'len', innerContFull.len * (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n        }\n      } else if (ai === 'type' && (newVal === 'pie' !== (oldVal === 'pie') || newVal === 'funnelarea' !== (oldVal === 'funnelarea'))) {\n        var labelsTo = 'x';\n        var valuesTo = 'y';\n\n        if ((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n          labelsTo = 'y';\n          valuesTo = 'x';\n        }\n\n        Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n        Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n        Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n        if (oldVal === 'pie' || oldVal === 'funnelarea') {\n          nestedProperty(cont, 'marker.color').set(nestedProperty(cont, 'marker.colors').get()); // super kludgy - but if all pies are gone we won't remove them otherwise\n\n          fullLayout._pielayer.selectAll('g.trace').remove();\n        } else if (Registry.traceIs(cont, 'cartesian')) {\n          nestedProperty(cont, 'marker.colors').set(nestedProperty(cont, 'marker.color').get());\n        }\n      }\n\n      undoit[ai][i] = undefinedToNull(oldVal); // set the new value - if val is an array, it's one el per trace\n      // first check for attributes that get more complex alterations\n\n      var swapAttrs = ['swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'];\n\n      if (swapAttrs.indexOf(ai) !== -1) {\n        // setting an orientation: make sure it's changing\n        // before we swap everything else\n        if (ai === 'orientation') {\n          param.set(newVal); // obnoxious that we need this level of coupling... but in order to\n          // properly handle setting orientation to `null` we need to mimic\n          // the logic inside Bars.supplyDefaults for default orientation\n\n          var defaultOrientation = cont.x && !cont.y ? 'h' : 'v';\n\n          if ((param.get() || defaultOrientation) === contFull.orientation) {\n            continue;\n          }\n        } else if (ai === 'orientationaxes') {\n          // orientationaxes has no value,\n          // it flips everything and the axes\n          cont.orientation = {\n            v: 'h',\n            h: 'v'\n          }[contFull.orientation];\n        }\n\n        helpers.swapXYData(cont);\n        flags.calc = flags.clearAxisTypes = true;\n      } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n        // TODO: use manageArrays.applyContainerArrayChanges here too\n        helpers.manageArrayContainers(param, newVal, undoit);\n        flags.calc = true;\n      } else {\n        if (valObject) {\n          // must redo calcdata when restyling array values of arrayOk attributes\n          // ... but no need to this for regl-based traces\n          if (valObject.arrayOk && !Registry.traceIs(contFull, 'regl') && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {\n            flags.calc = true;\n          } else editTypes.update(flags, valObject);\n        } else {\n          /*\n           * if we couldn't find valObject,  assume a full recalc.\n           * This can happen if you're changing type and making\n           * some other edits too, so the modules we're\n           * looking at don't have these attributes in them.\n           */\n          flags.calc = true;\n        } // all the other ones, just modify that one attribute\n\n\n        param.set(newVal);\n      }\n    } // swap the data attributes of the relevant x and y axes?\n\n\n    if (['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n      Axes.swap(gd, traces);\n    } // swap hovermode if set to \"compare x/y data\"\n\n\n    if (ai === 'orientationaxes') {\n      var hovermode = nestedProperty(gd.layout, 'hovermode');\n\n      if (hovermode.get() === 'x') {\n        hovermode.set('y');\n      } else if (hovermode.get() === 'y') {\n        hovermode.set('x');\n      } else if (hovermode.get() === 'x unified') {\n        hovermode.set('y unified');\n      } else if (hovermode.get() === 'y unified') {\n        hovermode.set('x unified');\n      }\n    } // Major enough changes deserve autoscale and\n    // non-reversed axes so people don't get confused\n    //\n    // Note: autobin (or its new analog bin clearing) is not included here\n    // since we're not pushing bins back to gd.data, so if we have bin\n    // info it was explicitly provided by the user.\n\n\n    if (['orientation', 'type'].indexOf(ai) !== -1) {\n      axlist = [];\n\n      for (i = 0; i < traces.length; i++) {\n        var trace = data[traces[i]];\n\n        if (Registry.traceIs(trace, 'cartesian')) {\n          addToAxlist(trace.xaxis || 'x');\n          addToAxlist(trace.yaxis || 'y');\n        }\n      }\n\n      doextra(axlist.map(autorangeAttr), true, 0);\n      doextra(axlist.map(rangeAttr), [0, 1], 0);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  return {\n    flags: flags,\n    undoit: undoit,\n    redoit: redoit,\n    traces: traces,\n    eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n  };\n}\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\n\n\nfunction cleanDeprecatedAttributeKeys(aobj) {\n  var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n  var colorbarRegex = /colorbar\\.title$/;\n  var keys = Object.keys(aobj);\n  var i, key, value;\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    value = aobj[key];\n\n    if ((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) && (typeof value === 'string' || typeof value === 'number')) {\n      replace(key, key.replace('title', 'title.text'));\n    } else if (key.indexOf('titlefont') > -1) {\n      replace(key, key.replace('titlefont', 'title.font'));\n    } else if (key.indexOf('titleposition') > -1) {\n      replace(key, key.replace('titleposition', 'title.position'));\n    } else if (key.indexOf('titleside') > -1) {\n      replace(key, key.replace('titleside', 'title.side'));\n    } else if (key.indexOf('titleoffset') > -1) {\n      replace(key, key.replace('titleoffset', 'title.offset'));\n    }\n  }\n\n  function replace(oldAttrStr, newAttrStr) {\n    aobj[newAttrStr] = aobj[oldAttrStr];\n    delete aobj[oldAttrStr];\n  }\n}\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\n\n\nfunction relayout(gd, astr, val) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n\n  var aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = Lib.extendFlat({}, astr);\n  } else {\n    Lib.warn('Relayout fail.', astr, val);\n    return Promise.reject();\n  }\n\n  if (Object.keys(aobj).length) gd.changed = true;\n\n  var specs = _relayout(gd, aobj);\n\n  var flags = specs.flags; // clear calcdata if required\n\n  if (flags.calc) gd.calcdata = undefined; // fill in redraw sequence\n  // even if we don't have anything left in aobj,\n  // something may have happened within relayout that we\n  // need to wait for\n\n  var seq = [Plots.previousPromises];\n\n  if (flags.layoutReplot) {\n    seq.push(subroutines.layoutReplot);\n  } else if (Object.keys(aobj).length) {\n    axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n    if (flags.legend) seq.push(subroutines.doLegend);\n    if (flags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n    if (flags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (flags.modebar) seq.push(subroutines.doModeBar);\n    if (flags.camera) seq.push(subroutines.doCamera);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, relayout, [gd, specs.undoit], relayout, [gd, specs.redoit]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_relayout', specs.eventData);\n    return gd;\n  });\n} // Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\n\n\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n  var fullLayout = gd._fullLayout;\n  if (!flags.axrange) return false;\n\n  for (var k in flags) {\n    if (k !== 'axrange' && flags[k]) return false;\n  }\n\n  for (var axId in specs.rangesAltered) {\n    var axName = Axes.id2name(axId);\n    var axIn = gd.layout[axName];\n    var axOut = fullLayout[axName];\n    axOut.autorange = axIn.autorange;\n    axOut.range = axIn.range.slice();\n    axOut.cleanRange();\n\n    if (axOut._matchGroup) {\n      for (var axId2 in axOut._matchGroup) {\n        if (axId2 !== axId) {\n          var ax2 = fullLayout[Axes.id2name(axId2)];\n          ax2.autorange = axOut.autorange;\n          ax2.range = axOut.range.slice();\n          ax2._input.range = axOut.range.slice();\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n  // N.B. leave as sequence of subroutines (for now) instead of\n  // subroutine of its own so that finalDraw always gets\n  // executed after drawData\n  var drawAxes = rangesAltered ? function (gd) {\n    var axIds = [];\n    var skipTitle = true;\n\n    for (var id in rangesAltered) {\n      var ax = Axes.getFromId(gd, id);\n      axIds.push(id);\n\n      if (ax._matchGroup) {\n        for (var id2 in ax._matchGroup) {\n          if (!rangesAltered[id2]) {\n            axIds.push(id2);\n          }\n        }\n      }\n\n      if (ax.automargin) skipTitle = false;\n    }\n\n    return Axes.draw(gd, axIds, {\n      skipTitle: skipTitle\n    });\n  } : function (gd) {\n    return Axes.draw(gd, 'redraw');\n  };\n  seq.push(clearSelect, subroutines.doAutoRangeAndConstraints, drawAxes, subroutines.drawData, subroutines.finalDraw);\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var keys = Object.keys(aobj);\n  var axes = Axes.list(gd);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var arrayEdits = {};\n  var arrayStr, i, j;\n  cleanDeprecatedAttributeKeys(aobj);\n  keys = Object.keys(aobj); // look for 'allaxes', split out into all axes\n  // in case of 3D the axis are nested within a scene which is held in _id\n\n  for (i = 0; i < keys.length; i++) {\n    if (keys[i].indexOf('allaxes') === 0) {\n      for (j = 0; j < axes.length; j++) {\n        var scene = axes[j]._id.substr(1);\n\n        var axisAttr = scene.indexOf('scene') !== -1 ? scene + '.' : '';\n        var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n        if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n      }\n\n      delete aobj[keys[i]];\n    }\n  } // initialize flags\n\n\n  var flags = editTypes.layoutFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {}; // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // attr can be an array to set several at once (all to the same val)\n\n  function doextra(attr, val) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val);\n      });\n      return;\n    } // if we have another value for this attribute (explicitly or\n    // via a parent) do not override with this auto-generated extra\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var p = layoutNP(layout, attr);\n\n    if (!(attr in undoit)) {\n      undoit[attr] = undefinedToNull(p.get());\n    }\n\n    if (val !== undefined) p.set(val);\n  } // for constraint enforcement: keep track of all axes (as {id: name})\n  // we're editing the (auto)range of, so we can tell the others constrained\n  // to scale with them that it's OK for them to shrink\n\n\n  var rangesAltered = {};\n  var axId;\n\n  function recordAlteredAxis(pleafPlus) {\n    var axId = Axes.name2id(pleafPlus.split('.')[0]);\n    rangesAltered[axId] = 1;\n    return axId;\n  } // alter gd.layout\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var p = layoutNP(layout, ai);\n    var vi = aobj[ai];\n    var plen = p.parts.length; // p.parts may end with an index integer if the property is an array\n\n    var pend = plen - 1;\n\n    while (pend > 0 && typeof p.parts[pend] !== 'string') pend--; // last property in chain (leaf node)\n\n\n    var pleaf = p.parts[pend]; // leaf plus immediate parent\n\n    var pleafPlus = p.parts[pend - 1] + '.' + pleaf; // trunk nodes (everything except the leaf)\n\n    var ptrunk = p.parts.slice(0, pend).join('.');\n    var parentIn = nestedProperty(gd.layout, ptrunk).get();\n    var parentFull = nestedProperty(fullLayout, ptrunk).get();\n    var vOld = p.get();\n    if (vi === undefined) continue;\n    redoit[ai] = vi; // axis reverse is special - it is its own inverse\n    // op and has no flag.\n\n    undoit[ai] = pleaf === 'reverse' ? vi : undefinedToNull(vOld);\n    var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n    if (valObject && valObject.impliedEdits && vi !== null) {\n      for (var impliedKey in valObject.impliedEdits) {\n        doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n      }\n    } // Setting width or height to null must reset the graph's width / height\n    // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    //\n    // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // can't use impliedEdits for this because behavior depends on vi\n\n\n    if (['width', 'height'].indexOf(ai) !== -1) {\n      if (vi) {\n        doextra('autosize', null); // currently we don't support autosize one dim only - so\n        // explicitly set the other one. Note that doextra will\n        // ignore this if the same relayout call also provides oppositeAttr\n\n        var oppositeAttr = ai === 'height' ? 'width' : 'height';\n        doextra(oppositeAttr, fullLayout[oppositeAttr]);\n      } else {\n        fullLayout[ai] = gd._initialAutoSize[ai];\n      }\n    } else if (ai === 'autosize') {\n      // depends on vi here too, so again can't use impliedEdits\n      doextra('width', vi ? null : fullLayout.width);\n      doextra('height', vi ? null : fullLayout.height);\n    } else if (pleafPlus.match(AX_RANGE_RE)) {\n      // check autorange vs range\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleafPlus.match(AX_AUTORANGE_RE)) {\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n      var axFull = nestedProperty(fullLayout, ptrunk).get();\n\n      if (axFull._inputDomain) {\n        // if we're autoranging and this axis has a constrained domain,\n        // reset it so we don't get locked into a shrunken size\n        axFull._input.domain = axFull._inputDomain.slice();\n      }\n    } else if (pleafPlus.match(AX_DOMAIN_RE)) {\n      nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n    } // toggling axis type between log and linear: we need to convert\n    // positions for components that are still using linearized values,\n    // not data values like newer components.\n    // previously we did this for log <-> not-log, but now only do it\n    // for log <-> linear\n\n\n    if (pleaf === 'type') {\n      var ax = parentIn;\n      var toLog = parentFull.type === 'linear' && vi === 'log';\n      var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n      if (toLog || fromLog) {\n        if (!ax || !ax.range) {\n          // 2D never gets here, but 3D does\n          // I don't think this is needed, but left here in case there\n          // are edge cases I'm not thinking of.\n          doextra(ptrunk + '.autorange', true);\n        } else if (!parentFull.autorange) {\n          // toggling log without autorange: need to also recalculate ranges\n          // because log axes use linearized values for range endpoints\n          var r0 = ax.range[0];\n          var r1 = ax.range[1];\n\n          if (toLog) {\n            // if both limits are negative, autorange\n            if (r0 <= 0 && r1 <= 0) {\n              doextra(ptrunk + '.autorange', true);\n            } // if one is negative, set it 6 orders below the other.\n\n\n            if (r0 <= 0) r0 = r1 / 1e6;else if (r1 <= 0) r1 = r0 / 1e6; // now set the range values as appropriate\n\n            doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n            doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n          } else {\n            doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n            doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n          }\n        } else if (toLog) {\n          // just make sure the range is positive and in the right\n          // order, it'll get recalculated later\n          ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];\n        } // clear polar view initial stash for radial range so that\n        // value get recomputed in correct units\n\n\n        if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === 'radialaxis') {\n          delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n        } // Annotations and images also need to convert to/from linearized coords\n        // Shapes do not need this :)\n\n\n        Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n        Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n      } else {\n        // any other type changes: the range from the previous type\n        // will not make sense, so autorange it.\n        doextra(ptrunk + '.autorange', true);\n        doextra(ptrunk + '.range', null);\n      }\n\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleaf.match(AX_NAME_PATTERN)) {\n      var fullProp = nestedProperty(fullLayout, ai).get();\n      var newType = (vi || {}).type; // This can potentially cause strange behavior if the autotype is not\n      // numeric (linear, because we don't auto-log) but the previous type\n      // was log. That's a very strange edge case though\n\n      if (!newType || newType === '-') newType = 'linear';\n      Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n      Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n    } // alter gd.layout\n    // collect array component edits for execution all together\n    // so we can ensure consistent behavior adding/removing items\n    // and order-independence for add/remove/edit all together in\n    // one relayout call\n\n\n    var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n\n    if (containerArrayMatch) {\n      arrayStr = containerArrayMatch.array;\n      i = containerArrayMatch.index;\n      var propStr = containerArrayMatch.property;\n      var updateValObject = valObject || {\n        editType: 'calc'\n      };\n\n      if (i !== '' && propStr === '') {\n        // special handling of undoit if we're adding or removing an element\n        // ie 'annotations[2]' which can be {...} (add) or null,\n        // does not work when replacing the entire array\n        if (manageArrays.isAddVal(vi)) {\n          undoit[ai] = null;\n        } else if (manageArrays.isRemoveVal(vi)) {\n          undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n        } else {\n          Lib.warn('unrecognized full object value', aobj);\n        }\n      }\n\n      editTypes.update(flags, updateValObject); // prepare the edits object we'll send to applyContainerArrayChanges\n\n      if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n      var objEdits = arrayEdits[arrayStr][i];\n      if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n      objEdits[propStr] = vi;\n      delete aobj[ai];\n    } else if (pleaf === 'reverse') {\n      // handle axis reversal explicitly, as there's no 'reverse' attribute\n      if (parentIn.range) parentIn.range.reverse();else {\n        doextra(ptrunk + '.autorange', true);\n        parentIn.range = [1, 0];\n      }\n      if (parentFull.autorange) flags.calc = true;else flags.plot = true;\n    } else {\n      if (fullLayout._has('scatter-like') && fullLayout._has('regl') && ai === 'dragmode' && (vi === 'lasso' || vi === 'select') && !(vOld === 'lasso' || vOld === 'select')) {\n        flags.plot = true;\n      } else if (fullLayout._has('gl2d')) {\n        flags.plot = true;\n      } else if (valObject) editTypes.update(flags, valObject);else flags.calc = true;\n\n      p.set(vi);\n    }\n  } // now we've collected component edits - execute them all together\n\n\n  for (arrayStr in arrayEdits) {\n    var finished = manageArrays.applyContainerArrayChanges(gd, layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n    if (!finished) flags.plot = true;\n  } // figure out if we need to recalculate axis constraints\n\n\n  var constraints = fullLayout._axisConstraintGroups || [];\n\n  for (axId in rangesAltered) {\n    for (i = 0; i < constraints.length; i++) {\n      var group = constraints[i];\n\n      if (group[axId]) {\n        // Always recalc if we're changing constrained ranges.\n        // Otherwise it's possible to violate the constraints by\n        // specifying arbitrary ranges for all axes in the group.\n        // this way some ranges may expand beyond what's specified,\n        // as they do at first draw, to satisfy the constraints.\n        flags.calc = true;\n\n        for (var groupAxId in group) {\n          if (!rangesAltered[groupAxId]) {\n            Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n          }\n        }\n      }\n    }\n  } // If the autosize changed or height or width was explicitly specified,\n  // this triggers a redraw\n  // TODO: do we really need special aobj.height/width handling here?\n  // couldn't editType do this?\n\n\n  if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  } // now all attribute mods are done, as are\n  // redo and undo so we can save them\n\n\n  return {\n    flags: flags,\n    rangesAltered: rangesAltered,\n    undoit: undoit,\n    redoit: redoit,\n    eventData: eventData\n  };\n}\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\n\n\nfunction updateAutosize(gd) {\n  var fullLayout = gd._fullLayout;\n  var oldWidth = fullLayout.width;\n  var oldHeight = fullLayout.height; // calculate autosizing\n\n  if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n  return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;\n}\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\n\n\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n\n  if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n  if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n  if (Object.keys(traceUpdate).length) gd.changed = true;\n  if (Object.keys(layoutUpdate).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n\n  var restyleFlags = restyleSpecs.flags;\n\n  var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n\n  var relayoutFlags = relayoutSpecs.flags; // clear calcdata and/or axis types if required\n\n  if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n  if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate); // fill in redraw sequence\n\n  var seq = [];\n\n  if (relayoutFlags.layoutReplot) {\n    // N.B. works fine when both\n    // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n    seq.push(subroutines.layoutReplot);\n  } else if (restyleFlags.fullReplot) {\n    seq.push(exports.plot);\n  } else {\n    seq.push(Plots.previousPromises);\n    axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n    if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n    if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n    if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n    if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n    if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n    if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces], update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_update', {\n      data: restyleSpecs.eventData,\n      layout: relayoutSpecs.eventData\n    });\n    return gd;\n  });\n}\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\n\n\nfunction guiEdit(func) {\n  return function wrappedEdit(gd) {\n    gd._fullLayout._guiEditing = true;\n    var p = func.apply(null, arguments);\n    gd._fullLayout._guiEditing = false;\n    return p;\n  };\n} // For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\n\n\nvar layoutUIControlPatterns = [{\n  pattern: /^hiddenlabels/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/\n}, // showspikes and modes include those nested inside scenes\n{\n  pattern: /axis\\d*\\.showspikes$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /(hover|drag)mode$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /^(scene\\d*)\\.camera/\n}, {\n  pattern: /^(geo\\d*)\\.(projection|center|fitbounds)/\n}, {\n  pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/\n}, {\n  pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/\n}, {\n  pattern: /^(polar\\d*\\.angularaxis)\\.rotation/\n}, {\n  pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/\n}, {\n  pattern: /^legend\\.(x|y)$/,\n  attr: 'editrevision'\n}, {\n  pattern: /^(shapes|annotations)/,\n  attr: 'editrevision'\n}, {\n  pattern: /^title\\.text$/,\n  attr: 'editrevision'\n}]; // same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\n\nvar traceUIControlPatterns = [{\n  pattern: /^selectedpoints$/,\n  attr: 'selectionrevision'\n}, // \"visible\" includes trace.transforms[i].styles[j].value.visible\n{\n  pattern: /(^|value\\.)visible$/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^dimensions\\[\\d+\\]\\.constraintrange/\n}, {\n  pattern: /^node\\.(x|y|groups)/\n}, // for Sankey nodes\n{\n  pattern: /^level$/\n}, // for Sunburst & Treemap traces\n// below this you must be in editable: true mode\n// TODO: I still put name and title with `trace.uirevision`\n// reasonable or should these be `editrevision`?\n// Also applies to axis titles up in the layout section\n// \"name\" also includes transform.styles\n{\n  pattern: /(^|value\\.)name$/\n}, // including nested colorbar attributes (ie marker.colorbar)\n{\n  pattern: /colorbar\\.title\\.text$/\n}, {\n  pattern: /colorbar\\.(x|y)$/,\n  attr: 'editrevision'\n}];\n\nfunction findUIPattern(key, patternSpecs) {\n  for (var i = 0; i < patternSpecs.length; i++) {\n    var spec = patternSpecs[i];\n    var match = key.match(spec.pattern);\n\n    if (match) {\n      return {\n        head: match[1],\n        attr: spec.attr\n      };\n    }\n  }\n} // We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\n\n\nfunction getNewRev(revAttr, container) {\n  var newRev = nestedProperty(container, revAttr).get();\n  if (newRev !== undefined) return newRev;\n  var parts = revAttr.split('.');\n  parts.pop();\n\n  while (parts.length > 1) {\n    parts.pop();\n    newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n    if (newRev !== undefined) return newRev;\n  }\n\n  return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n  for (var i = 0; i < fullData.length; i++) {\n    if (fullData[i]._fullInput.uid === uid) return i;\n  }\n\n  return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].uid === uid) return i;\n  } // fall back on trace order, but only if user didn't provide a uid for that trace\n\n\n  return !data[tracei] || data[tracei].uid ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n  var v1IsObj = Lib.isPlainObject(v1);\n  var v1IsArray = Array.isArray(v1);\n\n  if (v1IsObj || v1IsArray) {\n    return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);\n  }\n\n  return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n  var layoutPreGUI = oldFullLayout._preGUI;\n  var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n  var bothInheritAutorange = [];\n  var newRangeAccepted = {};\n\n  for (key in layoutPreGUI) {\n    match = findUIPattern(key, layoutUIControlPatterns);\n\n    if (match) {\n      revAttr = match.attr || match.head + '.uirevision';\n      oldRev = nestedProperty(oldFullLayout, revAttr).get();\n      newRev = oldRev && getNewRev(revAttr, layout);\n\n      if (newRev && newRev === oldRev) {\n        preGUIVal = layoutPreGUI[key];\n        if (preGUIVal === null) preGUIVal = undefined;\n        newNP = nestedProperty(layout, key);\n        newVal = newNP.get();\n\n        if (valsMatch(newVal, preGUIVal)) {\n          if (newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n            bothInheritAutorange.push(key.substr(0, key.length - 10));\n          }\n\n          newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n          continue;\n        }\n      }\n    } else {\n      Lib.warn('unrecognized GUI edit: ' + key);\n    } // if we got this far, the new value was accepted as the new starting\n    // point (either because it changed or revision changed)\n    // so remove it from _preGUI for next time.\n\n\n    delete layoutPreGUI[key];\n\n    if (key.substr(key.length - 8, 6) === 'range[') {\n      newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n    }\n  } // Special logic for `autorange`, since it interacts with `range`:\n  // If the new figure's matching `range` was kept, and `autorange`\n  // wasn't supplied explicitly in either the original or the new figure,\n  // we shouldn't alter that - but we may just have done that, so fix it.\n\n\n  for (var i = 0; i < bothInheritAutorange.length; i++) {\n    var axAttr = bothInheritAutorange[i];\n\n    if (newRangeAccepted[axAttr]) {\n      var newAx = nestedProperty(layout, axAttr).get();\n      if (newAx) delete newAx.autorange;\n    }\n  } // Now traces - try to match them up by uid (in case we added/deleted in\n  // the middle), then fall back on index.\n\n\n  var allTracePreGUI = oldFullLayout._tracePreGUI;\n\n  for (var uid in allTracePreGUI) {\n    var tracePreGUI = allTracePreGUI[uid];\n    var newTrace = null;\n    var fullInput;\n\n    for (key in tracePreGUI) {\n      // wait until we know we have preGUI values to look for traces\n      // but if we don't find both, stop looking at this uid\n      if (!newTrace) {\n        var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n\n        if (fulli < 0) {\n          // Somehow we didn't even have this trace in oldFullData...\n          // I guess this could happen with `deleteTraces` or something\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        var fullTrace = oldFullData[fulli];\n        fullInput = fullTrace._fullInput;\n        var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n\n        if (newTracei < 0) {\n          // No match in new data\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        newTrace = data[newTracei];\n      }\n\n      match = findUIPattern(key, traceUIControlPatterns);\n\n      if (match) {\n        if (match.attr) {\n          oldRev = nestedProperty(oldFullLayout, match.attr).get();\n          newRev = oldRev && getNewRev(match.attr, layout);\n        } else {\n          oldRev = fullInput.uirevision; // inheritance for trace.uirevision is simple, just layout.uirevision\n\n          newRev = newTrace.uirevision;\n          if (newRev === undefined) newRev = layout.uirevision;\n        }\n\n        if (newRev && newRev === oldRev) {\n          preGUIVal = tracePreGUI[key];\n          if (preGUIVal === null) preGUIVal = undefined;\n          newNP = nestedProperty(newTrace, key);\n          newVal = newNP.get();\n\n          if (valsMatch(newVal, preGUIVal)) {\n            newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n            continue;\n          }\n        }\n      } else {\n        Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n      }\n\n      delete tracePreGUI[key];\n    }\n  }\n}\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\n\n\nfunction react(gd, data, layout, config) {\n  var frames, plotDone;\n\n  function addFrames() {\n    return exports.addFrames(gd, frames);\n  }\n\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var oldFullData = gd._fullData;\n  var oldFullLayout = gd._fullLayout; // you can use this as the initial draw as well as to update\n\n  if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n    plotDone = exports.newPlot(gd, data, layout, config);\n  } else {\n    if (Lib.isPlainObject(data)) {\n      var obj = data;\n      data = obj.data;\n      layout = obj.layout;\n      config = obj.config;\n      frames = obj.frames;\n    }\n\n    var configChanged = false; // assume that if there's a config at all, we're reacting to it too,\n    // and completely replace the previous config\n\n    if (config) {\n      var oldConfig = Lib.extendDeep({}, gd._context);\n      gd._context = undefined;\n      setPlotContext(gd, config);\n      configChanged = diffConfig(oldConfig, gd._context);\n    }\n\n    gd.data = data || [];\n    helpers.cleanData(gd.data);\n    gd.layout = layout || {};\n    helpers.cleanLayout(gd.layout);\n    applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout); // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n    // which supplyDefaults usually does at the end, but we may need to NOT do\n    // if the diff (which we haven't determined yet) says we'll recalc\n\n    Plots.supplyDefaults(gd, {\n      skipUpdateCalc: true\n    });\n    var newFullData = gd._fullData;\n    var newFullLayout = gd._fullLayout;\n    var immutable = newFullLayout.datarevision === undefined;\n    var transition = newFullLayout.transition;\n    var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n    var newDataRevision = relayoutFlags.newDataRevision;\n    var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision); // TODO: how to translate this part of relayout to Plotly.react?\n    // // Setting width or height to null must reset the graph's width / height\n    // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    // //\n    // // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n    //     fullLayout[ai] = gd._initialAutoSize[ai];\n    // }\n\n    if (updateAutosize(gd)) relayoutFlags.layoutReplot = true; // clear calcdata if required\n\n    if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined; // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n    else Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData); // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n    // must be handled by the user when using Plotly.react.\n    // fill in redraw sequence\n\n    var seq = [];\n\n    if (frames) {\n      gd._transitionData = {};\n      Plots.createTransitionData(gd);\n      seq.push(addFrames);\n    } // Transition pathway,\n    // only used when 'transition' is set by user and\n    // when at least one animatable attribute has changed,\n    // N.B. config changed aren't animatable\n\n\n    if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n      Plots.doCalcdata(gd);\n      subroutines.doAutoRangeAndConstraints(gd);\n      seq.push(function () {\n        return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n      });\n    } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n      gd._fullLayout._skipDefaults = true;\n      seq.push(exports.plot);\n    } else {\n      for (var componentType in relayoutFlags.arrays) {\n        var indices = relayoutFlags.arrays[componentType];\n\n        if (indices.length) {\n          var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n\n          if (drawOne !== Lib.noop) {\n            for (var i = 0; i < indices.length; i++) {\n              drawOne(gd, indices[i]);\n            }\n          } else {\n            var draw = Registry.getComponentMethod(componentType, 'draw');\n\n            if (draw === Lib.noop) {\n              throw new Error('cannot draw components: ' + componentType);\n            }\n\n            draw(gd);\n          }\n        }\n      }\n\n      seq.push(Plots.previousPromises);\n      if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n      if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n      if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n      if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n      if (relayoutFlags.axrange) addAxRangeSequence(seq);\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n      if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n      seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n    plotDone = Lib.syncOrAsync(seq, gd);\n    if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  }\n\n  return plotDone.then(function () {\n    gd.emit('plotly_react', {\n      data: data,\n      layout: layout\n    });\n    return gd;\n  });\n}\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n  var sameTraceLength = oldFullData.length === newFullData.length;\n\n  if (!transition && !sameTraceLength) {\n    return {\n      fullReplot: true,\n      calc: true\n    };\n  }\n\n  var flags = editTypes.traceFlags();\n  flags.arrays = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  var i, trace;\n\n  function getTraceValObject(parts) {\n    var out = PlotSchema.getTraceValObject(trace, parts);\n\n    if (!trace._module.animatable && out.anim) {\n      out.anim = false;\n    }\n\n    return out;\n  }\n\n  var diffOpts = {\n    getValObject: getTraceValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    newDataRevision: newDataRevision,\n    gd: gd\n  };\n  var seenUIDs = {};\n\n  for (i = 0; i < oldFullData.length; i++) {\n    if (newFullData[i]) {\n      trace = newFullData[i]._fullInput;\n      if (Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n      if (seenUIDs[trace.uid]) continue;\n      seenUIDs[trace.uid] = 1;\n      getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n  var flags = editTypes.layoutFlags();\n  flags.arrays = {};\n  flags.rangesAltered = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n\n  function getLayoutValObject(parts) {\n    return PlotSchema.getLayoutValObject(newFullLayout, parts);\n  }\n\n  var diffOpts = {\n    getValObject: getLayoutValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    gd: gd\n  };\n  getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n  var valObject, key, astr;\n  var getValObject = opts.getValObject;\n  var flags = opts.flags;\n  var immutable = opts.immutable;\n  var inArray = opts.inArray;\n  var arrayIndex = opts.arrayIndex;\n\n  function changed() {\n    var editType = valObject.editType;\n\n    if (inArray && editType.indexOf('arraydraw') !== -1) {\n      Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n      return;\n    }\n\n    editTypes.update(flags, valObject);\n\n    if (editType !== 'none') {\n      flags.nChanges++;\n    } // track animatable changes\n\n\n    if (opts.transition && valObject.anim) {\n      flags.nChangesAnim++;\n    } // track cartesian axes with altered ranges\n\n\n    if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n      flags.rangesAltered[outerparts[0]] = 1;\n    } // clear _inputDomain on cartesian axes with altered domains\n\n\n    if (AX_DOMAIN_RE.test(astr)) {\n      nestedProperty(newContainer, '_inputDomain').set(null);\n    } // track datarevision changes\n\n\n    if (key === 'datarevision') {\n      flags.newDataRevision = 1;\n    }\n  }\n\n  function valObjectCanBeDataArray(valObject) {\n    return valObject.valType === 'data_array' || valObject.arrayOk;\n  }\n\n  for (key in oldContainer) {\n    // short-circuit based on previous calls or previous keys that already maximized the pathway\n    if (flags.calc && !opts.transition) return;\n    var oldVal = oldContainer[key];\n    var newVal = newContainer[key];\n    var parts = outerparts.concat(key);\n    astr = parts.join('.');\n    if (key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue; // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n    // and unlike other auto values they don't make it back into the input,\n    // so newContainer won't have them.\n\n    if ((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n      var tickMode = newContainer.tickmode;\n      if (tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n    } // FIXME: Similarly for axis ranges for 3D\n    // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n\n\n    if (key === 'range' && newContainer.autorange) continue;\n    if ((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n    valObject = getValObject(parts); // in case type changed, we may not even *have* a valObject.\n\n    if (!valObject) continue;\n    if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n    var valType = valObject.valType;\n    var i;\n    var canBeDataArray = valObjectCanBeDataArray(valObject);\n    var wasArray = Array.isArray(oldVal);\n    var nowArray = Array.isArray(newVal); // hack for traces that modify the data in supplyDefaults, like\n    // converting 1D to 2D arrays, which will always create new objects\n\n    if (wasArray && nowArray) {\n      var inputKey = '_input_' + key;\n      var oldValIn = oldContainer[inputKey];\n      var newValIn = newContainer[inputKey];\n      if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n    }\n\n    if (newVal === undefined) {\n      if (canBeDataArray && wasArray) flags.calc = true;else changed();\n    } else if (valObject._isLinkedToArray) {\n      var arrayEditIndices = [];\n      var extraIndices = false;\n      if (!inArray) flags.arrays[key] = arrayEditIndices;\n      var minLen = Math.min(oldVal.length, newVal.length);\n      var maxLen = Math.max(oldVal.length, newVal.length);\n\n      if (minLen !== maxLen) {\n        if (valObject.editType === 'arraydraw') {\n          extraIndices = true;\n        } else {\n          changed();\n          continue;\n        }\n      }\n\n      for (i = 0; i < minLen; i++) {\n        getDiffFlags(oldVal[i], newVal[i], parts.concat(i), // add array indices, but not if we're already in an array\n        Lib.extendFlat({\n          inArray: key,\n          arrayIndex: i\n        }, opts));\n      } // put this at the end so that we know our collected array indices are sorted\n      // but the check for length changes happens up front so we can short-circuit\n      // diffing if appropriate\n\n\n      if (extraIndices) {\n        for (i = minLen; i < maxLen; i++) {\n          arrayEditIndices.push(i);\n        }\n      }\n    } else if (!valType && Lib.isPlainObject(oldVal)) {\n      getDiffFlags(oldVal, newVal, parts, opts);\n    } else if (canBeDataArray) {\n      if (wasArray && nowArray) {\n        // don't try to diff two data arrays. If immutable we know the data changed,\n        // if not, assume it didn't and let `layout.datarevision` tell us if it did\n        if (immutable) {\n          flags.calc = true;\n        } // look for animatable attributes when the data changed\n\n\n        if (immutable || opts.newDataRevision) {\n          changed();\n        }\n      } else if (wasArray !== nowArray) {\n        flags.calc = true;\n      } else changed();\n    } else if (wasArray && nowArray) {\n      // info array, colorscale, 'any' - these are short, just stringify.\n      // I don't *think* that covers up any real differences post-validation, does it?\n      // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n      // all elements.\n      if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n        changed();\n      }\n    } else {\n      changed();\n    }\n  }\n\n  for (key in newContainer) {\n    if (!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n      valObject = getValObject(outerparts.concat(key));\n\n      if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n        flags.calc = true;\n        return;\n      } else changed();\n    }\n  }\n}\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\n\n\nfunction diffConfig(oldConfig, newConfig) {\n  var key;\n\n  for (key in oldConfig) {\n    if (key.charAt(0) === '_') continue;\n    var oldVal = oldConfig[key];\n    var newVal = newConfig[key];\n\n    if (oldVal !== newVal) {\n      if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n        if (diffConfig(oldVal, newVal)) {\n          return true;\n        }\n      } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {\n        if (oldVal.length !== newVal.length) {\n          return true;\n        }\n\n        for (var i = 0; i < oldVal.length; i++) {\n          if (oldVal[i] !== newVal[i]) {\n            if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n              if (diffConfig(oldVal[i], newVal[i])) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n}\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\n\n\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before animating it. For more details, see ' + 'https://plotly.com/javascript/animations/');\n  }\n\n  var trans = gd._transitionData; // This is the queue of frames that will be animated as soon as possible. They\n  // are popped immediately upon the *start* of a transition:\n\n  if (!trans._frameQueue) {\n    trans._frameQueue = [];\n  }\n\n  animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n  var transitionOpts = animationOpts.transition;\n  var frameOpts = animationOpts.frame; // Since frames are popped immediately, an empty queue only means all frames have\n  // *started* to transition, not that the animation is complete. To solve that,\n  // track a separate counter that increments at the same time as frames are added\n  // to the queue, but decrements only when the transition is complete.\n\n  if (trans._frameWaitingCnt === undefined) {\n    trans._frameWaitingCnt = 0;\n  }\n\n  function getTransitionOpts(i) {\n    if (Array.isArray(transitionOpts)) {\n      if (i >= transitionOpts.length) {\n        return transitionOpts[0];\n      } else {\n        return transitionOpts[i];\n      }\n    } else {\n      return transitionOpts;\n    }\n  }\n\n  function getFrameOpts(i) {\n    if (Array.isArray(frameOpts)) {\n      if (i >= frameOpts.length) {\n        return frameOpts[0];\n      } else {\n        return frameOpts[i];\n      }\n    } else {\n      return frameOpts;\n    }\n  } // Execute a callback after the wrapper function has been called n times.\n  // This is used to defer the resolution until a transition has resovled *and*\n  // the frame has completed. If it's not done this way, then we get a race\n  // condition in which the animation might resolve before a transition is complete\n  // or vice versa.\n\n\n  function callbackOnNthTime(cb, n) {\n    var cnt = 0;\n    return function () {\n      if (cb && ++cnt === n) {\n        return cb();\n      }\n    };\n  }\n\n  return new Promise(function (resolve, reject) {\n    function discardExistingFrames() {\n      if (trans._frameQueue.length === 0) {\n        return;\n      }\n\n      while (trans._frameQueue.length) {\n        var next = trans._frameQueue.pop();\n\n        if (next.onInterrupt) {\n          next.onInterrupt();\n        }\n      }\n\n      gd.emit('plotly_animationinterrupted', []);\n    }\n\n    function queueFrames(frameList) {\n      if (frameList.length === 0) return;\n\n      for (var i = 0; i < frameList.length; i++) {\n        var computedFrame;\n\n        if (frameList[i].type === 'byname') {\n          // If it's a named frame, compute it:\n          computedFrame = Plots.computeFrame(gd, frameList[i].name);\n        } else {\n          // Otherwise we must have been given a simple object, so treat\n          // the input itself as the computed frame.\n          computedFrame = frameList[i].data;\n        }\n\n        var frameOpts = getFrameOpts(i);\n        var transitionOpts = getTransitionOpts(i); // It doesn't make much sense for the transition duration to be greater than\n        // the frame duration, so limit it:\n\n        transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n        var nextFrame = {\n          frame: computedFrame,\n          name: frameList[i].name,\n          frameOpts: frameOpts,\n          transitionOpts: transitionOpts\n        };\n\n        if (i === frameList.length - 1) {\n          // The last frame in this .animate call stores the promise resolve\n          // and reject callbacks. This is how we ensure that the animation\n          // loop (which may exist as a result of a *different* .animate call)\n          // still resolves or rejecdts this .animate call's promise. once it's\n          // complete.\n          nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n          nextFrame.onInterrupt = reject;\n        }\n\n        trans._frameQueue.push(nextFrame);\n      } // Set it as never having transitioned to a frame. This will cause the animation\n      // loop to immediately transition to the next frame (which, for immediate mode,\n      // is the first frame in the list since all others would have been discarded\n      // below)\n\n\n      if (animationOpts.mode === 'immediate') {\n        trans._lastFrameAt = -Infinity;\n      } // Only it's not already running, start a RAF loop. This could be avoided in the\n      // case that there's only one frame, but it significantly complicated the logic\n      // and only sped things up by about 5% or so for a lorenz attractor simulation.\n      // It would be a fine thing to implement, but the benefit of that optimization\n      // doesn't seem worth the extra complexity.\n\n\n      if (!trans._animationRaf) {\n        beginAnimationLoop();\n      }\n    }\n\n    function stopAnimationLoop() {\n      gd.emit('plotly_animated'); // Be sure to unset also since it's how we know whether a loop is already running:\n\n      window.cancelAnimationFrame(trans._animationRaf);\n      trans._animationRaf = null;\n    }\n\n    function nextFrame() {\n      if (trans._currentFrame && trans._currentFrame.onComplete) {\n        // Execute the callback and unset it to ensure it doesn't\n        // accidentally get called twice\n        trans._currentFrame.onComplete();\n      }\n\n      var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n      if (newFrame) {\n        // Since it's sometimes necessary to do deep digging into frame data,\n        // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n        // so check when casting the name, just to be absolutely certain:\n        var stringName = newFrame.name ? newFrame.name.toString() : null;\n        gd._fullLayout._currentFrame = stringName;\n        trans._lastFrameAt = Date.now();\n        trans._timeToNext = newFrame.frameOpts.duration; // This is simply called and it's left to .transition to decide how to manage\n        // interrupting current transitions. That means we don't need to worry about\n        // how it resolves or what happens after this:\n\n        Plots.transition(gd, newFrame.frame.data, newFrame.frame.layout, helpers.coerceTraceIndices(gd, newFrame.frame.traces), newFrame.frameOpts, newFrame.transitionOpts).then(function () {\n          if (newFrame.onComplete) {\n            newFrame.onComplete();\n          }\n        });\n        gd.emit('plotly_animatingframe', {\n          name: stringName,\n          frame: newFrame.frame,\n          animation: {\n            frame: newFrame.frameOpts,\n            transition: newFrame.transitionOpts\n          }\n        });\n      } else {\n        // If there are no more frames, then stop the RAF loop:\n        stopAnimationLoop();\n      }\n    }\n\n    function beginAnimationLoop() {\n      gd.emit('plotly_animating'); // If no timer is running, then set last frame = long ago so that the next\n      // frame is immediately transitioned:\n\n      trans._lastFrameAt = -Infinity;\n      trans._timeToNext = 0;\n      trans._runningTransitions = 0;\n      trans._currentFrame = null;\n\n      var doFrame = function () {\n        // This *must* be requested before nextFrame since nextFrame may decide\n        // to cancel it if there's nothing more to animated:\n        trans._animationRaf = window.requestAnimationFrame(doFrame); // Check if we're ready for a new frame:\n\n        if (Date.now() - trans._lastFrameAt > trans._timeToNext) {\n          nextFrame();\n        }\n      };\n\n      doFrame();\n    } // This is an animate-local counter that helps match up option input list\n    // items with the particular frame.\n\n\n    var configCounter = 0;\n\n    function setTransitionConfig(frame) {\n      if (Array.isArray(transitionOpts)) {\n        if (configCounter >= transitionOpts.length) {\n          frame.transitionOpts = transitionOpts[configCounter];\n        } else {\n          frame.transitionOpts = transitionOpts[0];\n        }\n      } else {\n        frame.transitionOpts = transitionOpts;\n      }\n\n      configCounter++;\n      return frame;\n    } // Disambiguate what's sort of frames have been received\n\n\n    var i, frame;\n    var frameList = [];\n    var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n    var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n    var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n    if (isSingleFrame) {\n      // In this case, a simple object has been passed to animate.\n      frameList.push({\n        type: 'object',\n        data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n      });\n    } else if (allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n      // In this case, null or undefined has been passed so that we want to\n      // animate *all* currently defined frames\n      for (i = 0; i < trans._frames.length; i++) {\n        frame = trans._frames[i];\n        if (!frame) continue;\n\n        if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n          frameList.push({\n            type: 'byname',\n            name: String(frame.name),\n            data: setTransitionConfig({\n              name: frame.name\n            })\n          });\n        }\n      }\n    } else if (isFrameArray) {\n      for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n        var frameOrName = frameOrGroupNameOrFrameList[i];\n\n        if (['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n          frameOrName = String(frameOrName); // In this case, there's an array and this frame is a string name:\n\n          frameList.push({\n            type: 'byname',\n            name: frameOrName,\n            data: setTransitionConfig({\n              name: frameOrName\n            })\n          });\n        } else if (Lib.isPlainObject(frameOrName)) {\n          frameList.push({\n            type: 'object',\n            data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n          });\n        }\n      }\n    } // Verify that all of these frames actually exist; return and reject if not:\n\n\n    for (i = 0; i < frameList.length; i++) {\n      frame = frameList[i];\n\n      if (frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n        Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n        reject();\n        return;\n      }\n    } // If the mode is either next or immediate, then all currently queued frames must\n    // be dumped and the corresponding .animate promises rejected.\n\n\n    if (['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n      discardExistingFrames();\n    }\n\n    if (animationOpts.direction === 'reverse') {\n      frameList.reverse();\n    }\n\n    var currentFrame = gd._fullLayout._currentFrame;\n\n    if (currentFrame && animationOpts.fromcurrent) {\n      var idx = -1;\n\n      for (i = 0; i < frameList.length; i++) {\n        frame = frameList[i];\n\n        if (frame.type === 'byname' && frame.name === currentFrame) {\n          idx = i;\n          break;\n        }\n      }\n\n      if (idx > 0 && idx < frameList.length - 1) {\n        var filteredFrameList = [];\n\n        for (i = 0; i < frameList.length; i++) {\n          frame = frameList[i];\n\n          if (frameList[i].type !== 'byname' || i > idx) {\n            filteredFrameList.push(frame);\n          }\n        }\n\n        frameList = filteredFrameList;\n      }\n    }\n\n    if (frameList.length > 0) {\n      queueFrames(frameList);\n    } else {\n      // This is the case where there were simply no frames. It's a little strange\n      // since there's not much to do:\n      gd.emit('plotly_animated');\n      resolve();\n    }\n  });\n}\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\n\n\nfunction addFrames(gd, frameList, indices) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (frameList === null || frameList === undefined) {\n    return Promise.resolve();\n  }\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before adding frames. For more details, see ' + 'https://plotly.com/javascript/animations/');\n  }\n\n  var i, frame, j, idx;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n\n  if (!Array.isArray(frameList)) {\n    throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n  } // Create a sorted list of insertions since we run into lots of problems if these\n  // aren't in ascending order of index:\n  //\n  // Strictly for sorting. Make sure this is guaranteed to never collide with any\n  // already-exisisting indices:\n\n\n  var bigIndex = _frames.length + frameList.length * 2;\n  var insertions = [];\n  var _frameHashLocal = {};\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    if (!Lib.isPlainObject(frameList[i])) continue; // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n    // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n\n    var lookupName = frameList[i].name;\n    var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n    var newName = frameList[i].name;\n    var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n    if (name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n      numericNameWarningCount++;\n      Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name + '\" with a frame whose name of type \"number\" also equates to \"' + name + '\". This is valid but may potentially lead to unexpected ' + 'behavior since all plotly.js frame names are stored internally ' + 'as strings.');\n\n      if (numericNameWarningCount === numericNameWarningCountLimit) {\n        Lib.warn('addFrames: This API call has yielded too many of these warnings. ' + 'For the rest of this call, further warnings about numeric frame ' + 'names will be suppressed.');\n      }\n    }\n\n    _frameHashLocal[lookupName] = {\n      name: lookupName\n    };\n    insertions.push({\n      frame: Plots.supplyFrameDefaults(frameList[i]),\n      index: indices && indices[i] !== undefined && indices[i] !== null ? indices[i] : bigIndex + i\n    });\n  } // Sort this, taking note that undefined insertions end up at the end:\n\n\n  insertions.sort(function (a, b) {\n    if (a.index > b.index) return -1;\n    if (a.index < b.index) return 1;\n    return 0;\n  });\n  var ops = [];\n  var revops = [];\n  var frameCount = _frames.length;\n\n  for (i = insertions.length - 1; i >= 0; i--) {\n    frame = insertions[i].frame;\n\n    if (typeof frame.name === 'number') {\n      Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' + 'implicitly cast to strings');\n    }\n\n    if (!frame.name) {\n      // Repeatedly assign a default name, incrementing the counter each time until\n      // we get a name that's not in the hashed lookup table:\n      while (_frameHash[frame.name = 'frame ' + gd._transitionData._counter++]);\n    }\n\n    if (_frameHash[frame.name]) {\n      // If frame is present, overwrite its definition:\n      for (j = 0; j < _frames.length; j++) {\n        if ((_frames[j] || {}).name === frame.name) break;\n      }\n\n      ops.push({\n        type: 'replace',\n        index: j,\n        value: frame\n      });\n      revops.unshift({\n        type: 'replace',\n        index: j,\n        value: _frames[j]\n      });\n    } else {\n      // Otherwise insert it at the end of the list:\n      idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n      ops.push({\n        type: 'insert',\n        index: idx,\n        value: frame\n      });\n      revops.unshift({\n        type: 'delete',\n        index: idx\n      });\n      frameCount++;\n    }\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\n\n\nfunction deleteFrames(gd, frameList) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  var i, idx;\n  var _frames = gd._transitionData._frames;\n  var ops = [];\n  var revops = [];\n\n  if (!frameList) {\n    frameList = [];\n\n    for (i = 0; i < _frames.length; i++) {\n      frameList.push(i);\n    }\n  }\n\n  frameList = frameList.slice();\n  frameList.sort();\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    idx = frameList[i];\n    ops.push({\n      type: 'delete',\n      index: idx\n    });\n    revops.unshift({\n      type: 'insert',\n      index: idx,\n      value: _frames[idx]\n    });\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\n\n\nfunction purge(gd) {\n  gd = Lib.getGraphDiv(gd);\n  var fullLayout = gd._fullLayout || {};\n  var fullData = gd._fullData || []; // remove gl contexts\n\n  Plots.cleanPlot([], {}, fullData, fullLayout); // purge properties\n\n  Plots.purge(gd); // purge event emitter methods\n\n  Events.purge(gd); // remove plot container\n\n  if (fullLayout._container) fullLayout._container.remove(); // in contrast to Plotly.Plots.purge which does NOT clear _context!\n\n  delete gd._context;\n  return gd;\n} // -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\n\n\nfunction makePlotFramework(gd) {\n  var gd3 = d3.select(gd);\n  var fullLayout = gd._fullLayout; // Plot container\n\n  fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n\n  fullLayout._container.enter().insert('div', ':first-child').classed('plot-container', true).classed('plotly', true); // Make the svg container\n\n\n  fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n\n  fullLayout._paperdiv.enter().append('div').classed('svg-container', true).style('position', 'relative'); // Make the graph containers\n  // start fresh each time we get here, so we know the order comes out\n  // right, rather than enter/exit which can muck up the order\n  // TODO: sort out all the ordering so we don't have to\n  // explicitly delete anything\n  // FIXME: parcoords reuses this object, not the best pattern\n\n\n  fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container').data([{}]);\n\n  fullLayout._glcontainer.enter().append('div').classed('gl-container', true);\n\n  fullLayout._paperdiv.selectAll('.main-svg').remove();\n\n  fullLayout._paperdiv.select('.modebar-container').remove();\n\n  fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child').classed('main-svg', true);\n  fullLayout._toppaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n  fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n  fullLayout._hoverpaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n\n  if (!fullLayout._uid) {\n    var otherUids = {};\n    d3.selectAll('defs').each(function () {\n      if (this.id) otherUids[this.id.split('-')[1]] = 1;\n    });\n    fullLayout._uid = Lib.randstr(otherUids);\n  }\n\n  fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);\n\n  fullLayout._defs = fullLayout._paper.append('defs').attr('id', 'defs-' + fullLayout._uid);\n  fullLayout._clips = fullLayout._defs.append('g').classed('clips', true);\n  fullLayout._topdefs = fullLayout._toppaper.append('defs').attr('id', 'topdefs-' + fullLayout._uid);\n  fullLayout._topclips = fullLayout._topdefs.append('g').classed('clips', true);\n  fullLayout._bgLayer = fullLayout._paper.append('g').classed('bglayer', true);\n  fullLayout._draggers = fullLayout._paper.append('g').classed('draglayer', true); // lower shape/image layer - note that this is behind\n  // all subplots data/grids but above the backgrounds\n  // except inset subplots, whose backgrounds are drawn\n  // inside their own group so that they appear above\n  // the data for the main subplot\n  // lower shapes and images which are fully referenced to\n  // a subplot still get drawn within the subplot's group\n  // so they will work correctly on insets\n\n  var layerBelow = fullLayout._paper.append('g').classed('layer-below', true);\n\n  fullLayout._imageLowerLayer = layerBelow.append('g').classed('imagelayer', true);\n  fullLayout._shapeLowerLayer = layerBelow.append('g').classed('shapelayer', true); // single cartesian layer for the whole plot\n\n  fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true); // single polar layer for the whole plot\n\n  fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true); // single ternary layer for the whole plot\n\n  fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true); // single geo layer for the whole plot\n\n  fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true); // single funnelarea layer for the whole plot\n\n  fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true); // single pie layer for the whole plot\n\n  fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true); // single treemap layer for the whole plot\n\n  fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true); // single sunburst layer for the whole plot\n\n  fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true); // single indicator layer for the whole plot\n\n  fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true); // fill in image server scrape-svg\n\n  fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true); // lastly upper shapes, info (legend, annotations) and hover layers go on top\n  // these are in a different svg element normally, but get collapsed into a single\n  // svg when exporting (after inserting 3D)\n  // upper shapes/images are only those drawn above the whole plot, including subplots\n\n  var layerAbove = fullLayout._toppaper.append('g').classed('layer-above', true);\n\n  fullLayout._imageUpperLayer = layerAbove.append('g').classed('imagelayer', true);\n  fullLayout._shapeUpperLayer = layerAbove.append('g').classed('shapelayer', true);\n  fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n  fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n  fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n  fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true); // Make the modebar container\n\n  fullLayout._modebardiv.classed('modebar-container', true).style('position', 'absolute').style('top', '0px').style('right', '0px');\n\n  gd.emit('plotly_framework');\n}\n\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\nexports.newPlot = newPlot;\nexports.plot = plot;\nexports.purge = purge;\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\nexports.setPlotConfig = setPlotConfig;\nexports.update = update;\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/plot_api/plot_api.js"],"names":["d3","require","isNumeric","hasHover","Lib","nestedProperty","Events","Queue","Registry","PlotSchema","Plots","Polar","Axes","Drawing","Color","initInteractions","xmlnsNamespaces","svgTextUtils","clearSelect","dfltConfig","manageArrays","helpers","subroutines","editTypes","AX_NAME_PATTERN","numericNameWarningCount","numericNameWarningCountLimit","plot","gd","data","layout","config","frames","getGraphDiv","init","isPlainObject","obj","okToPlot","triggerHandler","Promise","reject","isPlotDiv","warn","addFrames","exports","setPlotContext","select","classed","makeTester","Array","isArray","_promises","graphWasEmpty","length","cleanData","push","apply","empty","cleanLayout","supplyDefaults","fullLayout","_fullLayout","hasCartesian","_has","r","log","plotLegacyPolar","_replotting","_shouldCreateBgLayer","makePlotFramework","framework","initGradients","saveShowSpikeInitial","recalc","calcdata","_fullData","doCalcdata","i","trace","_context","responsive","_responsiveChartHandler","isHidden","resize","window","addEventListener","clearResponsive","oldMargins","extendFlat","_size","drawFrameworkCalls","drawFramework","basePlotModules","_basePlotModules","_glcanvas","_glcontainer","selectAll","key","context","pick","d","enter","append","attr","replace","style","position","top","left","overflow","width","height","regl","Math","floor","_gl","drawingBufferWidth","drawingBufferHeight","msg","error","cleanPlot","modebar","orientation","_modebardiv","previousPromises","marginPushers","clearAutoMarginIds","drawMarginPushers","allowAutoMargin","fullData","type","automargin","uid","doAutoMargin","marginPushersAgain","didMarginChange","syncOrAsync","layoutStyles","positionAndAutorange","doAutoRangeAndConstraints","getComponentMethod","_transitioning","saveRangeInitial","drawAxes","draw","seq","drawData","finalDraw","addLinks","rehover","redrag","plotDone","then","resolve","emitAfterPlot","_redrawFromAutoMarginCount","emit","setPlotConfig","setBackground","bgColor","_paper","e","opaqueSetBackground","blend","combine","extendDeep","base","_baseUrl","size","location","href","split","keys","Object","plot3dPixelRatio","plotGlPixelRatio","editable","undefined","edits","_exportedPlot","staticPlot","autosizable","scrollZoom","doubleClick","showTips","showLink","displayModeBar","_hasZeroHeight","clientHeight","_hasZeroWidth","clientWidth","szIn","szOut","_scrollZoom","cartesian","gl3d","geo","mapbox","parts","plotContainer","insert","paperDiv","html","manager","fillLayout","node","setUndoPoint","polarPlotSVG","svg","opacity","txt","title","text","titleLayout","call","convertToTspans","titleText","placeholderText","_","on","transition","duration","setContenteditable","makeEditable","paper_bgcolor","redraw","Error","newPlot","purge","positivifyIndices","indices","maxIndex","parentLength","positiveIndices","index","assertIndexArray","arrayName","parseInt","indexOf","checkMoveTracesArgs","currentIndices","newIndices","checkAddTracesArgs","traces","value","assertExtendTracesArgs","update","maxPoints","maxPointsIsObject","getExtendProperties","updateProps","target","prop","maxp","j","get","isArrayOrTypedArray","constructor","spliceTraces","updateArray","undoUpdate","undoPoints","out","set","astr","concatTypedArray","arr0","arr1","arr2","extendTraces","newArray","remainder","isTypedArray","none","both","numberOfItemsFromInsert","subarray","numberOfItemsFromTarget","targetBegin","concat","splice","undo","promise","undoArgs","add","prependTraces","arguments","addTraces","undoFunc","deleteTraces","redoFunc","redoArgs","map","startSequence","moveTraces","stopSequence","deletedTrace","sort","sorterDes","newData","movingTraceMap","newIndex","a","b","restyle","val","_traces","clearPromiseQueue","aobj","changed","coerceTraceIndices","specs","_restyle","flags","calc","clearAxisTypes","fullReplot","markerSize","addAxRangeSequence","doTraceStyle","colorbars","doColorBars","undoit","redoit","eventData","undefinedToNull","makeNP","preGUI","guiEditFlag","container","prefix","np","npSet","fullAttr","storeCurrent","newVal","arrayVal","arrayNew","maxLen","max","objVal","objNew","objBoth","_storeDirectGUIEdit","_guiEditing","layoutNP","_preGUI","extendDeepAll","cleanDeprecatedAttributeKeys","traceFlags","axlist","a0","addToAxlist","axid","axName","id2name","autorangeAttr","rangeAttr","getFullTrace","traceIndex","_input","doextra","forEach","hasParent","extraparam","substr","tracei","_tracePreGUI","_fullInput","allBins","binAttr","arrayBins","vij","ai","vi","cont","contFull","param","oldVal","valObject","charAt","finalPart","prefixDot","innerContFull","getTraceValObject","impliedEdits","impliedKey","relativeAttr","gs","orient","topOrBottom","thicknorm","h","w","thickness","lennorm","len","labelsTo","valuesTo","swapAttrs","_pielayer","remove","traceIs","defaultOrientation","x","y","v","swapXYData","dataArrayContainers","manageArrayContainers","arrayOk","swap","hovermode","xaxis","yaxis","extendDeepNoArrays","oldAxisTitleRegex","counterRegex","colorbarRegex","test","oldAttrStr","newAttrStr","relayout","isPolar","_relayout","layoutReplot","axRangeSupplyDefaultsByPass","legend","doLegend","layoutstyle","axrange","rangesAltered","ticks","doTicksRelayout","doModeBar","camera","doCamera","k","axId","axIn","axOut","autorange","range","slice","cleanRange","_matchGroup","axId2","ax2","axIds","skipTitle","id","ax","getFromId","id2","AX_RANGE_RE","AX_AUTORANGE_RE","AX_DOMAIN_RE","axes","list","arrayEdits","arrayStr","scene","_id","axisAttr","newkey","_name","layoutFlags","p","recordAlteredAxis","pleafPlus","name2id","plen","pend","pleaf","ptrunk","join","parentIn","parentFull","vOld","getLayoutValObject","oppositeAttr","_initialAutoSize","match","axFull","_inputDomain","domain","toLog","fromLog","r0","r1","LN10","pow","_subplots","polar","_subplot","viewInitial","fullProp","newType","containerArrayMatch","array","propStr","property","updateValObject","editType","isAddVal","isRemoveVal","objEdits","reverse","finished","applyContainerArrayChanges","constraints","_axisConstraintGroups","group","groupAxId","_constraintShrinkable","updateAutosize","oldWidth","oldHeight","autosize","plotAutoSize","traceUpdate","layoutUpdate","restyleSpecs","restyleFlags","relayoutSpecs","relayoutFlags","guiEdit","func","wrappedEdit","layoutUIControlPatterns","pattern","traceUIControlPatterns","findUIPattern","patternSpecs","spec","head","getNewRev","revAttr","newRev","pop","uirevision","getFullTraceIndexFromUid","getTraceIndexFromUid","valsMatch","v1","v2","v1IsObj","v1IsArray","JSON","stringify","applyUIRevisions","oldFullData","oldFullLayout","layoutPreGUI","oldRev","preGUIVal","newNP","bothInheritAutorange","newRangeAccepted","axAttr","newAx","allTracePreGUI","tracePreGUI","newTrace","fullInput","fulli","fullTrace","newTracei","react","configChanged","oldConfig","diffConfig","skipUpdateCalc","newFullData","newFullLayout","immutable","datarevision","diffLayout","newDataRevision","diffData","supplyDefaultsUpdateCalc","_transitionData","createTransitionData","anim","transitionFromReact","_skipDefaults","componentType","arrays","drawOne","noop","sameTraceLength","nChanges","nChangesAnim","_module","animatable","diffOpts","getValObject","seenUIDs","hasMakesDataTransform","getDiffFlags","oldContainer","newContainer","outerparts","opts","inArray","arrayIndex","pushUnique","valObjectCanBeDataArray","valType","tickMode","tickmode","_compareAsJSON","canBeDataArray","wasArray","nowArray","inputKey","oldValIn","newValIn","_isLinkedToArray","arrayEditIndices","extraIndices","minLen","min","String","newConfig","animate","frameOrGroupNameOrFrameList","animationOpts","trans","_frameQueue","supplyAnimationDefaults","transitionOpts","frameOpts","frame","_frameWaitingCnt","getTransitionOpts","getFrameOpts","callbackOnNthTime","cb","n","cnt","discardExistingFrames","next","onInterrupt","queueFrames","frameList","computedFrame","computeFrame","name","nextFrame","onComplete","mode","_lastFrameAt","Infinity","_animationRaf","beginAnimationLoop","stopAnimationLoop","cancelAnimationFrame","_currentFrame","newFrame","shift","stringName","toString","Date","now","_timeToNext","animation","_runningTransitions","doFrame","requestAnimationFrame","configCounter","setTransitionConfig","allFrames","isFrameArray","isSingleFrame","_frames","frameOrName","_frameHash","direction","currentFrame","fromcurrent","idx","filteredFrameList","bigIndex","insertions","_frameHashLocal","lookupName","newName","collisionPresent","supplyFrameDefaults","ops","revops","frameCount","_counter","unshift","modifyFrames","deleteFrames","_container","gd3","_paperdiv","_toppaper","_hoverpaper","_uid","otherUids","each","randstr","svgAttrs","_defs","_clips","_topdefs","_topclips","_bgLayer","_draggers","layerBelow","_imageLowerLayer","_shapeLowerLayer","_cartesianlayer","_polarlayer","_ternarylayer","_geolayer","_funnelarealayer","_treemaplayer","_sunburstlayer","_indicatorlayer","_glimages","layerAbove","_imageUpperLayer","_shapeUpperLayer","_infolayer","_menulayer","_zoomlayer","_hoverlayer","_guiRelayout","_guiRestyle","_guiUpdate"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\nvar Polar = require('../plots/polar/legacy');\n\nvar Axes = require('../plots/cartesian/axes');\nvar Drawing = require('../components/drawing');\nvar Color = require('../components/color');\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar svgTextUtils = require('../lib/svg_text_utils');\nvar clearSelect = require('../plots/cartesian/select').clearSelect;\n\nvar dfltConfig = require('./plot_config').dfltConfig;\nvar manageArrays = require('./manage_arrays');\nvar helpers = require('./helpers');\nvar subroutines = require('./subroutines');\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction plot(gd, data, layout, config) {\n    var frames;\n\n    gd = Lib.getGraphDiv(gd);\n\n    // Events.init is idempotent and bails early if gd has already been init'd\n    Events.init(gd);\n\n    if(Lib.isPlainObject(data)) {\n        var obj = data;\n        data = obj.data;\n        layout = obj.layout;\n        config = obj.config;\n        frames = obj.frames;\n    }\n\n    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n    if(okToPlot === false) return Promise.reject();\n\n    // if there's no data or layout, and this isn't yet a plotly plot\n    // container, log a warning to help plotly.js users debug\n    if(!data && !layout && !Lib.isPlotDiv(gd)) {\n        Lib.warn('Calling Plotly.plot as if redrawing ' +\n            'but this container doesn\\'t yet have a plot.', gd);\n    }\n\n    function addFrames() {\n        if(frames) {\n            return exports.addFrames(gd, frames);\n        }\n    }\n\n    // transfer configuration options to gd until we move over to\n    // a more OO like model\n    setPlotContext(gd, config);\n\n    if(!layout) layout = {};\n\n    // hook class for plots main container (in case of plotly.js\n    // this won't be #embedded-graph or .js-tab-contents)\n    d3.select(gd).classed('js-plotly-plot', true);\n\n    // off-screen getBoundingClientRect testing space,\n    // in #js-plotly-tester (and stored as Drawing.tester)\n    // so we can share cached text across tabs\n    Drawing.makeTester();\n\n    // collect promises for any async actions during plotting\n    // any part of the plotting code can push to gd._promises, then\n    // before we move to the next step, we check that they're all\n    // complete, and empty out the promise list again.\n    if(!Array.isArray(gd._promises)) gd._promises = [];\n\n    var graphWasEmpty = ((gd.data || []).length === 0 && Array.isArray(data));\n\n    // if there is already data on the graph, append the new data\n    // if you only want to redraw, pass a non-array for data\n    if(Array.isArray(data)) {\n        helpers.cleanData(data);\n\n        if(graphWasEmpty) gd.data = data;\n        else gd.data.push.apply(gd.data, data);\n\n        // for routines outside graph_obj that want a clean tab\n        // (rather than appending to an existing one) gd.empty\n        // is used to determine whether to make a new tab\n        gd.empty = false;\n    }\n\n    if(!gd.layout || graphWasEmpty) {\n        gd.layout = helpers.cleanLayout(layout);\n    }\n\n    Plots.supplyDefaults(gd);\n\n    var fullLayout = gd._fullLayout;\n    var hasCartesian = fullLayout._has('cartesian');\n\n    // Legacy polar plots\n    if(!fullLayout._has('polar') && data && data[0] && data[0].r) {\n        Lib.log('Legacy polar charts are deprecated!');\n        return plotLegacyPolar(gd, data, layout);\n    }\n\n    // so we don't try to re-call Plotly.plot from inside\n    // legend and colorbar, if margins changed\n    fullLayout._replotting = true;\n\n    // make or remake the framework if we need to\n    if(graphWasEmpty || fullLayout._shouldCreateBgLayer) {\n        makePlotFramework(gd);\n\n        if(fullLayout._shouldCreateBgLayer) {\n            delete fullLayout._shouldCreateBgLayer;\n        }\n    }\n\n    // polar need a different framework\n    if(gd.framework !== makePlotFramework) {\n        gd.framework = makePlotFramework;\n        makePlotFramework(gd);\n    }\n\n    // clear gradient defs on each .plot call, because we know we'll loop through all traces\n    Drawing.initGradients(gd);\n\n    // save initial show spikes once per graph\n    if(graphWasEmpty) Axes.saveShowSpikeInitial(gd);\n\n    // prepare the data and find the autorange\n\n    // generate calcdata, if we need to\n    // to force redoing calcdata, just delete it before calling Plotly.plot\n    var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n    if(recalc) Plots.doCalcdata(gd);\n\n    // in case it has changed, attach fullData traces to calcdata\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        gd.calcdata[i][0].trace = gd._fullData[i];\n    }\n\n    // make the figure responsive\n    if(gd._context.responsive) {\n        if(!gd._responsiveChartHandler) {\n            // Keep a reference to the resize handler to purge it down the road\n            gd._responsiveChartHandler = function() { if(!Lib.isHidden(gd)) Plots.resize(gd); };\n\n            // Listen to window resize\n            window.addEventListener('resize', gd._responsiveChartHandler);\n        }\n    } else {\n        Lib.clearResponsive(gd);\n    }\n\n    /*\n     * start async-friendly code - now we're actually drawing things\n     */\n\n    var oldMargins = Lib.extendFlat({}, fullLayout._size);\n\n    // draw framework first so that margin-pushing\n    // components can position themselves correctly\n    var drawFrameworkCalls = 0;\n    function drawFramework() {\n        var basePlotModules = fullLayout._basePlotModules;\n\n        for(var i = 0; i < basePlotModules.length; i++) {\n            if(basePlotModules[i].drawFramework) {\n                basePlotModules[i].drawFramework(gd);\n            }\n        }\n\n        if(!fullLayout._glcanvas && fullLayout._has('gl')) {\n            fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n                key: 'contextLayer',\n                context: true,\n                pick: false\n            }, {\n                key: 'focusLayer',\n                context: false,\n                pick: false\n            }, {\n                key: 'pickLayer',\n                context: false,\n                pick: true\n            }], function(d) { return d.key; });\n\n            fullLayout._glcanvas.enter().append('canvas')\n                .attr('class', function(d) {\n                    return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n                })\n                .style({\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    overflow: 'visible',\n                    'pointer-events': 'none'\n                });\n        }\n\n        if(fullLayout._glcanvas) {\n            fullLayout._glcanvas\n                .attr('width', fullLayout.width)\n                .attr('height', fullLayout.height);\n\n            var regl = fullLayout._glcanvas.data()[0].regl;\n            if(regl) {\n                // Unfortunately, this can happen when relayouting to large\n                // width/height on some browsers.\n                if(Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth ||\n                    Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight\n                 ) {\n                    var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n                    if(drawFrameworkCalls) {\n                        Lib.error(msg);\n                    } else {\n                        Lib.log(msg + ' Clearing graph and plotting again.');\n                        Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n                        Plots.supplyDefaults(gd);\n                        fullLayout = gd._fullLayout;\n                        Plots.doCalcdata(gd);\n                        drawFrameworkCalls++;\n                        return drawFramework();\n                    }\n                }\n            }\n        }\n\n        if(fullLayout.modebar.orientation === 'h') {\n            fullLayout._modebardiv\n              .style('height', null)\n              .style('width', '100%');\n        } else {\n            fullLayout._modebardiv\n              .style('width', null)\n              .style('height', fullLayout.height + 'px');\n        }\n\n        return Plots.previousPromises(gd);\n    }\n\n    // draw anything that can affect margins.\n    function marginPushers() {\n        // First reset the list of things that are allowed to change the margins\n        // So any deleted traces or components will be wiped out of the\n        // automargin calculation.\n        // This means *every* margin pusher must be listed here, even if it\n        // doesn't actually try to push the margins until later.\n        Plots.clearAutoMarginIds(gd);\n\n        subroutines.drawMarginPushers(gd);\n        Axes.allowAutoMargin(gd);\n\n        // TODO can this be moved elsewhere?\n        if(fullLayout._has('pie')) {\n            var fullData = gd._fullData;\n            for(var i = 0; i < fullData.length; i++) {\n                var trace = fullData[i];\n                if(trace.type === 'pie' && trace.automargin) {\n                    Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n                }\n            }\n        }\n\n        Plots.doAutoMargin(gd);\n        return Plots.previousPromises(gd);\n    }\n\n    // in case the margins changed, draw margin pushers again\n    function marginPushersAgain() {\n        if(!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n\n        return Lib.syncOrAsync([\n            marginPushers,\n            subroutines.layoutStyles\n        ], gd);\n    }\n\n    function positionAndAutorange() {\n        if(!recalc) {\n            doAutoRangeAndConstraints();\n            return;\n        }\n\n        // TODO: autosize extra for text markers and images\n        // see https://github.com/plotly/plotly.js/issues/1111\n        return Lib.syncOrAsync([\n            Registry.getComponentMethod('shapes', 'calcAutorange'),\n            Registry.getComponentMethod('annotations', 'calcAutorange'),\n            doAutoRangeAndConstraints\n        ], gd);\n    }\n\n    function doAutoRangeAndConstraints() {\n        if(gd._transitioning) return;\n\n        subroutines.doAutoRangeAndConstraints(gd);\n\n        // store initial ranges *after* enforcing constraints, otherwise\n        // we will never look like we're at the initial ranges\n        if(graphWasEmpty) Axes.saveRangeInitial(gd);\n\n        // this one is different from shapes/annotations calcAutorange\n        // the others incorporate those components into ax._extremes,\n        // this one actually sets the ranges in rangesliders.\n        Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n    }\n\n    // draw ticks, titles, and calculate axis scaling (._b, ._m)\n    function drawAxes() {\n        return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n    }\n\n    var seq = [\n        Plots.previousPromises,\n        addFrames,\n        drawFramework,\n        marginPushers,\n        marginPushersAgain\n    ];\n\n    if(hasCartesian) seq.push(positionAndAutorange);\n\n    seq.push(subroutines.layoutStyles);\n    if(hasCartesian) seq.push(drawAxes);\n\n    seq.push(\n        subroutines.drawData,\n        subroutines.finalDraw,\n        initInteractions,\n        Plots.addLinks,\n        Plots.rehover,\n        Plots.redrag,\n        // TODO: doAutoMargin is only needed here for axis automargin, which\n        // happens outside of marginPushers where all the other automargins are\n        // calculated. Would be much better to separate margin calculations from\n        // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n        Plots.doAutoMargin,\n        Plots.previousPromises\n    );\n\n    // even if everything we did was synchronous, return a promise\n    // so that the caller doesn't care which route we took\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        emitAfterPlot(gd);\n        return gd;\n    });\n}\n\nfunction emitAfterPlot(gd) {\n    var fullLayout = gd._fullLayout;\n\n    if(fullLayout._redrawFromAutoMarginCount) {\n        fullLayout._redrawFromAutoMarginCount--;\n    } else {\n        gd.emit('plotly_afterplot');\n    }\n}\n\nfunction setPlotConfig(obj) {\n    return Lib.extendFlat(dfltConfig, obj);\n}\n\nfunction setBackground(gd, bgColor) {\n    try {\n        gd._fullLayout._paper.style('background', bgColor);\n    } catch(e) {\n        Lib.error(e);\n    }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n    var blend = Color.combine(bgColor, 'white');\n    setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n    if(!gd._context) {\n        gd._context = Lib.extendDeep({}, dfltConfig);\n\n        // stash <base> href, used to make robust clipPath URLs\n        var base = d3.select('base');\n        gd._context._baseUrl = base.size() && base.attr('href') ?\n            window.location.href.split('#')[0] :\n            '';\n    }\n\n    var context = gd._context;\n\n    var i, keys, key;\n\n    if(config) {\n        keys = Object.keys(config);\n        for(i = 0; i < keys.length; i++) {\n            key = keys[i];\n            if(key === 'editable' || key === 'edits') continue;\n            if(key in context) {\n                if(key === 'setBackground' && config[key] === 'opaque') {\n                    context[key] = opaqueSetBackground;\n                } else {\n                    context[key] = config[key];\n                }\n            }\n        }\n\n        // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n        if(config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n            context.plotGlPixelRatio = context.plot3dPixelRatio;\n        }\n\n        // now deal with editable and edits - first editable overrides\n        // everything, then edits refines\n        var editable = config.editable;\n        if(editable !== undefined) {\n            // we're not going to *use* context.editable, we're only going to\n            // use context.edits... but keep it for the record\n            context.editable = editable;\n\n            keys = Object.keys(context.edits);\n            for(i = 0; i < keys.length; i++) {\n                context.edits[keys[i]] = editable;\n            }\n        }\n        if(config.edits) {\n            keys = Object.keys(config.edits);\n            for(i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if(key in context.edits) {\n                    context.edits[key] = config.edits[key];\n                }\n            }\n        }\n\n        // not part of the user-facing config options\n        context._exportedPlot = config._exportedPlot;\n    }\n\n    // staticPlot forces a bunch of others:\n    if(context.staticPlot) {\n        context.editable = false;\n        context.edits = {};\n        context.autosizable = false;\n        context.scrollZoom = false;\n        context.doubleClick = false;\n        context.showTips = false;\n        context.showLink = false;\n        context.displayModeBar = false;\n    }\n\n    // make sure hover-only devices have mode bar visible\n    if(context.displayModeBar === 'hover' && !hasHover) {\n        context.displayModeBar = true;\n    }\n\n    // default and fallback for setBackground\n    if(context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n        context.setBackground = setBackground;\n    }\n\n    // Check if gd has a specified widht/height to begin with\n    context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n    context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;\n\n    // fill context._scrollZoom helper to help manage scrollZoom flaglist\n    var szIn = context.scrollZoom;\n    var szOut = context._scrollZoom = {};\n    if(szIn === true) {\n        szOut.cartesian = 1;\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n    } else if(typeof szIn === 'string') {\n        var parts = szIn.split('+');\n        for(i = 0; i < parts.length; i++) {\n            szOut[parts[i]] = 1;\n        }\n    } else if(szIn !== false) {\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n    }\n}\n\nfunction plotLegacyPolar(gd, data, layout) {\n    // build or reuse the container skeleton\n    var plotContainer = d3.select(gd).selectAll('.plot-container')\n        .data([0]);\n    plotContainer.enter()\n        .insert('div', ':first-child')\n        .classed('plot-container plotly', true);\n    var paperDiv = plotContainer.selectAll('.svg-container')\n        .data([0]);\n    paperDiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // empty it everytime for now\n    paperDiv.html('');\n\n    // fulfill gd requirements\n    if(data) gd.data = data;\n    if(layout) gd.layout = layout;\n    Polar.manager.fillLayout(gd);\n\n    // resize canvas\n    paperDiv.style({\n        width: gd._fullLayout.width + 'px',\n        height: gd._fullLayout.height + 'px'\n    });\n\n    // instantiate framework\n    gd.framework = Polar.manager.framework(gd);\n\n    // plot\n    gd.framework({data: gd.data, layout: gd.layout}, paperDiv.node());\n\n    // set undo point\n    gd.framework.setUndoPoint();\n\n    // get the resulting svg for extending it\n    var polarPlotSVG = gd.framework.svg();\n\n    // editable title\n    var opacity = 1;\n    var txt = gd._fullLayout.title ? gd._fullLayout.title.text : '';\n    if(txt === '' || !txt) opacity = 0;\n\n    var titleLayout = function() {\n        this.call(svgTextUtils.convertToTspans, gd);\n        // TODO: html/mathjax\n        // TODO: center title\n    };\n\n    var title = polarPlotSVG.select('.title-group text')\n        .call(titleLayout);\n\n    if(gd._context.edits.titleText) {\n        var placeholderText = Lib._(gd, 'Click to enter Plot title');\n        if(!txt || txt === placeholderText) {\n            opacity = 0.2;\n            // placeholder is not going through convertToTspans\n            // so needs explicit data-unformatted\n            title.attr({'data-unformatted': placeholderText})\n                .text(placeholderText)\n                .style({opacity: opacity})\n                .on('mouseover.opacity', function() {\n                    d3.select(this).transition().duration(100)\n                        .style('opacity', 1);\n                })\n                .on('mouseout.opacity', function() {\n                    d3.select(this).transition().duration(1000)\n                        .style('opacity', 0);\n                });\n        }\n\n        var setContenteditable = function() {\n            this.call(svgTextUtils.makeEditable, {gd: gd})\n                .on('edit', function(text) {\n                    gd.framework({layout: {title: {text: text}}});\n                    this.text(text)\n                        .call(titleLayout);\n                    this.call(setContenteditable);\n                })\n                .on('cancel', function() {\n                    var txt = this.attr('data-unformatted');\n                    this.text(txt).call(titleLayout);\n                });\n        };\n        title.call(setContenteditable);\n    }\n\n    gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n    Plots.addLinks(gd);\n\n    return Promise.resolve();\n}\n\n// convenience function to force a full redraw, mostly for use by plotly.js\nfunction redraw(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    helpers.cleanData(gd.data);\n    helpers.cleanLayout(gd.layout);\n\n    gd.calcdata = undefined;\n    return exports.plot(gd).then(function() {\n        gd.emit('plotly_redraw');\n        return gd;\n    });\n}\n\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\nfunction newPlot(gd, data, layout, config) {\n    gd = Lib.getGraphDiv(gd);\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n\n    Plots.purge(gd);\n    return exports.plot(gd, data, layout, config);\n}\n\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\nfunction positivifyIndices(indices, maxIndex) {\n    var parentLength = maxIndex + 1;\n    var positiveIndices = [];\n    var i;\n    var index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n        if(index < 0) {\n            positiveIndices.push(parentLength + index);\n        } else {\n            positiveIndices.push(index);\n        }\n    }\n    return positiveIndices;\n}\n\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\nfunction assertIndexArray(gd, indices, arrayName) {\n    var i,\n        index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n\n        // validate that indices are indeed integers\n        if(index !== parseInt(index, 10)) {\n            throw new Error('all values in ' + arrayName + ' must be integers');\n        }\n\n        // check that all indices are in bounds for given gd.data array length\n        if(index >= gd.data.length || index < -gd.data.length) {\n            throw new Error(arrayName + ' must be valid indices for gd.data.');\n        }\n\n        // check that indices aren't repeated\n        if(indices.indexOf(index, i + 1) > -1 ||\n                index >= 0 && indices.indexOf(-gd.data.length + index) > -1 ||\n                index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n            throw new Error('each index in ' + arrayName + ' must be unique.');\n        }\n    }\n}\n\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // validate currentIndices array\n    if(typeof currentIndices === 'undefined') {\n        throw new Error('currentIndices is a required argument.');\n    } else if(!Array.isArray(currentIndices)) {\n        currentIndices = [currentIndices];\n    }\n    assertIndexArray(gd, currentIndices, 'currentIndices');\n\n    // validate newIndices array if it exists\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined') {\n        assertIndexArray(gd, newIndices, 'newIndices');\n    }\n\n    // check currentIndices and newIndices are the same length if newIdices exists\n    if(typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n        throw new Error('current and new indices must be of equal length.');\n    }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n    var i, value;\n\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // make sure traces exists\n    if(typeof traces === 'undefined') {\n        throw new Error('traces must be defined.');\n    }\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure each value in traces is an object\n    for(i = 0; i < traces.length; i++) {\n        value = traces[i];\n        if(typeof value !== 'object' || (Array.isArray(value) || value === null)) {\n            throw new Error('all values in traces array must be non-array objects');\n        }\n    }\n\n    // make sure we have an index for each trace\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n        throw new Error(\n            'if indices is specified, traces.length must equal indices.length'\n        );\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array');\n    }\n    if(!Lib.isPlainObject(update)) {\n        throw new Error('update must be a key:value object');\n    }\n\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers');\n    }\n\n    assertIndexArray(gd, indices, 'indices');\n\n    for(var key in update) {\n        /*\n         * Verify that the attribute to be updated contains as many trace updates\n         * as indices. Failure must result in throw and no-op\n         */\n        if(!Array.isArray(update[key]) || update[key].length !== indices.length) {\n            throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n        }\n\n        /*\n         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n         */\n        if(maxPointsIsObject &&\n            (!(key in maxPoints) || !Array.isArray(maxPoints[key]) ||\n            maxPoints[key].length !== update[key].length)) {\n            throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' +\n                            'corrispondence with the keys and number of traces in the update object');\n        }\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n    var updateProps = [];\n    var trace, target, prop, insert, maxp;\n\n    // allow scalar index to represent a single trace position\n    if(!Array.isArray(indices)) indices = [indices];\n\n    // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // loop through all update keys and traces and harvest validated data.\n    for(var key in update) {\n        for(var j = 0; j < indices.length; j++) {\n            /*\n             * Choose the trace indexed by the indices map argument and get the prop setter-getter\n             * instance that references the key and value for this particular trace.\n             */\n            trace = gd.data[indices[j]];\n            prop = nestedProperty(trace, key);\n\n            /*\n             * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n             * Target must exist as an Array to allow the extend operation to be performed.\n             */\n            target = prop.get();\n            insert = update[key][j];\n\n            if(!Lib.isArrayOrTypedArray(insert)) {\n                throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n            }\n            if(!Lib.isArrayOrTypedArray(target)) {\n                throw new Error('cannot extend missing or non-array attribute: ' + key);\n            }\n            if(target.constructor !== insert.constructor) {\n                throw new Error('cannot extend array with an array of a different type: ' + key);\n            }\n\n            /*\n             * maxPoints may be an object map or a scalar. If object select the key:value, else\n             * Use the scalar maxPoints for all key and trace combinations.\n             */\n            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\n\n            // could have chosen null here, -1 just tells us to not take a window\n            if(!isNumeric(maxp)) maxp = -1;\n\n            /*\n             * Wrap the nestedProperty in an object containing required data\n             * for lengthening and windowing this particular trace - key combination.\n             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n             */\n            updateProps.push({\n                prop: prop,\n                target: target,\n                insert: insert,\n                maxp: Math.floor(maxp)\n            });\n        }\n    }\n\n    // all target and insertion data now validated\n    return updateProps;\n}\n\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n    assertExtendTracesArgs(gd, update, indices, maxPoints);\n\n    var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n    var undoUpdate = {};\n    var undoPoints = {};\n\n    for(var i = 0; i < updateProps.length; i++) {\n        var prop = updateProps[i].prop;\n        var maxp = updateProps[i].maxp;\n\n        // return new array and remainder\n        var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n        prop.set(out[0]);\n\n        // build the inverse update object for the undo operation\n        if(!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n        undoUpdate[prop.astr].push(out[1]);\n\n         // build the matching maxPoints undo object containing original trace lengths\n        if(!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n        undoPoints[prop.astr].push(updateProps[i].target.length);\n    }\n\n    return {update: undoUpdate, maxPoints: undoPoints};\n}\n\nfunction concatTypedArray(arr0, arr1) {\n    var arr2 = new arr0.constructor(arr0.length + arr1.length);\n    arr2.set(arr0);\n    arr2.set(arr1, arr0.length);\n    return arr2;\n}\n\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\nfunction extendTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp < 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(target, insert);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target);\n                    remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n                    var targetBegin = target.length - numberOfItemsFromTarget;\n\n                    newArray.set(target.subarray(targetBegin));\n                    newArray.set(insert, numberOfItemsFromTarget);\n                    remainder.set(target.subarray(0, targetBegin));\n                }\n            }\n        } else {\n            newArray = target.concat(insert);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(0, newArray.length - maxp) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n\n    return promise;\n}\n\nfunction prependTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp <= 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(insert, target);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n                    remainder.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target, numberOfItemsFromInsert);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n\n                    newArray.set(insert);\n                    newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n                    remainder.set(target.subarray(numberOfItemsFromTarget));\n                }\n            }\n        } else {\n            newArray = insert.concat(target);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(maxp, newArray.length) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n\n    return promise;\n}\n\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\nfunction addTraces(gd, traces, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var currentIndices = [];\n    var undoFunc = exports.deleteTraces;\n    var redoFunc = addTraces;\n    var undoArgs = [gd, currentIndices];\n    var redoArgs = [gd, traces];  // no newIndices here\n    var i;\n    var promise;\n\n    // all validation is done elsewhere to remove clutter here\n    checkAddTracesArgs(gd, traces, newIndices);\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure traces do not repeat existing ones\n    traces = traces.map(function(trace) {\n        return Lib.extendFlat({}, trace);\n    });\n\n    helpers.cleanData(traces);\n\n    // add the traces to gd.data (no redrawing yet!)\n    for(i = 0; i < traces.length; i++) {\n        gd.data.push(traces[i]);\n    }\n\n    // to continue, we need to call moveTraces which requires currentIndices\n    for(i = 0; i < traces.length; i++) {\n        currentIndices.push(-traces.length + i);\n    }\n\n    // if the user didn't define newIndices, they just want the traces appended\n    // i.e., we can simply redraw and be done\n    if(typeof newIndices === 'undefined') {\n        promise = exports.redraw(gd);\n        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n        return promise;\n    }\n\n    // make sure indices is property defined\n    if(!Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n\n    try {\n        // this is redundant, but necessary to not catch later possible errors!\n        checkMoveTracesArgs(gd, currentIndices, newIndices);\n    } catch(error) {\n        // something went wrong, reset gd to be safe and rethrow error\n        gd.data.splice(gd.data.length - traces.length, traces.length);\n        throw error;\n    }\n\n    // if we're here, the user has defined specific places to place the new traces\n    // this requires some extra work that moveTraces will do\n    Queue.startSequence(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    promise = exports.moveTraces(gd, currentIndices, newIndices);\n    Queue.stopSequence(gd);\n    return promise;\n}\n\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\nfunction deleteTraces(gd, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var traces = [];\n    var undoFunc = exports.addTraces;\n    var redoFunc = deleteTraces;\n    var undoArgs = [gd, traces, indices];\n    var redoArgs = [gd, indices];\n    var i;\n    var deletedTrace;\n\n    // make sure indices are defined\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers.');\n    } else if(!Array.isArray(indices)) {\n        indices = [indices];\n    }\n    assertIndexArray(gd, indices, 'indices');\n\n    // convert negative indices to positive indices\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // we want descending here so that splicing later doesn't affect indexing\n    indices.sort(Lib.sorterDes);\n    for(i = 0; i < indices.length; i += 1) {\n        deletedTrace = gd.data.splice(indices[i], 1)[0];\n        traces.push(deletedTrace);\n    }\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n}\n\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\nfunction moveTraces(gd, currentIndices, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var newData = [];\n    var movingTraceMap = [];\n    var undoFunc = moveTraces;\n    var redoFunc = moveTraces;\n    var undoArgs = [gd, newIndices, currentIndices];\n    var redoArgs = [gd, currentIndices, newIndices];\n    var i;\n\n    // to reduce complexity here, check args elsewhere\n    // this throws errors where appropriate\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n\n    // make sure currentIndices is an array\n    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\n\n    // if undefined, define newIndices to point to the end of gd.data array\n    if(typeof newIndices === 'undefined') {\n        newIndices = [];\n        for(i = 0; i < currentIndices.length; i++) {\n            newIndices.push(-currentIndices.length + i);\n        }\n    }\n\n    // make sure newIndices is an array if it's user-defined\n    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\n\n    // convert negative indices to positive indices (they're the same length)\n    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n    newIndices = positivifyIndices(newIndices, gd.data.length - 1);\n\n    // at this point, we've coerced the index arrays into predictable forms\n\n    // get the traces that aren't being moved around\n    for(i = 0; i < gd.data.length; i++) {\n        // if index isn't in currentIndices, include it in ignored!\n        if(currentIndices.indexOf(i) === -1) {\n            newData.push(gd.data[i]);\n        }\n    }\n\n    // get a mapping of indices to moving traces\n    for(i = 0; i < currentIndices.length; i++) {\n        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});\n    }\n\n    // reorder this mapping by newIndex, ascending\n    movingTraceMap.sort(function(a, b) {\n        return a.newIndex - b.newIndex;\n    });\n\n    // now, add the moving traces back in, in order!\n    for(i = 0; i < movingTraceMap.length; i += 1) {\n        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n    }\n\n    gd.data = newData;\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n}\n\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\nfunction restyle(gd, astr, val, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var aobj = {};\n    if(typeof astr === 'string') aobj[astr] = val;\n    else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = Lib.extendFlat({}, astr);\n        if(_traces === undefined) _traces = val;\n    } else {\n        Lib.warn('Restyle fail.', astr, val, _traces);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var specs = _restyle(gd, aobj, traces);\n    var flags = specs.flags;\n\n    // clear calcdata and/or axis types if required so they get regenerated\n    if(flags.calc) gd.calcdata = undefined;\n    if(flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(flags.fullReplot) {\n        seq.push(exports.plot);\n    } else {\n        seq.push(Plots.previousPromises);\n\n        // maybe only call Plots.supplyDataDefaults in the splom case,\n        // to skip over long and slow axes defaults\n        Plots.supplyDefaults(gd);\n\n        if(flags.markerSize) {\n            Plots.doCalcdata(gd);\n            addAxRangeSequence(seq);\n\n            // TODO\n            // if all axes have autorange:false, then\n            // proceed to subroutines.doTraceStyle(),\n            // otherwise we must go through addAxRangeSequence,\n            // which in general must redraws 'all' axes\n        }\n\n        if(flags.style) seq.push(subroutines.doTraceStyle);\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n\n    Queue.add(gd,\n        restyle, [gd, specs.undoit, specs.traces],\n        restyle, [gd, specs.redoit, specs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        gd.emit('plotly_restyle', specs.eventData);\n        return gd;\n    });\n}\n\n// for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\nfunction undefinedToNull(val) {\n    if(val === undefined) return null;\n    return val;\n}\n\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\nfunction makeNP(preGUI, guiEditFlag) {\n    if(!guiEditFlag) return nestedProperty;\n\n    return function(container, attr, prefix) {\n        var np = nestedProperty(container, attr);\n        var npSet = np.set;\n        np.set = function(val) {\n            var fullAttr = (prefix || '') + attr;\n            storeCurrent(fullAttr, np.get(), val, preGUI);\n            npSet(val);\n        };\n        return np;\n    };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n    if(Array.isArray(val) || Array.isArray(newVal)) {\n        var arrayVal = Array.isArray(val) ? val : [];\n        var arrayNew = Array.isArray(newVal) ? newVal : [];\n        var maxLen = Math.max(arrayVal.length, arrayNew.length);\n        for(var i = 0; i < maxLen; i++) {\n            storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n        }\n    } else if(Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n        var objVal = Lib.isPlainObject(val) ? val : {};\n        var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n        var objBoth = Lib.extendFlat({}, objVal, objNew);\n        for(var key in objBoth) {\n            storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n        }\n    } else if(preGUI[attr] === undefined) {\n        preGUI[attr] = undefinedToNull(val);\n    }\n}\n\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n    for(var attr in edits) {\n        var np = nestedProperty(container, attr);\n        storeCurrent(attr, np.get(), edits[attr], preGUI);\n    }\n}\n\nfunction _restyle(gd, aobj, traces) {\n    var fullLayout = gd._fullLayout;\n    var fullData = gd._fullData;\n    var data = gd.data;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var i;\n\n    cleanDeprecatedAttributeKeys(aobj);\n\n    // initialize flags\n    var flags = editTypes.traceFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n    var axlist;\n\n    // make a new empty vals array for undoit\n    function a0() { return traces.map(function() { return undefined; }); }\n\n    // for autoranging multiple axes\n    function addToAxlist(axid) {\n        var axName = Axes.id2name(axid);\n        if(axlist.indexOf(axName) === -1) axlist.push(axName);\n    }\n\n    function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }\n\n    function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }\n\n    function getFullTrace(traceIndex) {\n        // usually fullData maps 1:1 onto data, but with groupby transforms\n        // the fullData index can be greater. Take the *first* matching trace.\n        for(var j = traceIndex; j < fullData.length; j++) {\n            if(fullData[j]._input === data[traceIndex]) return fullData[j];\n        }\n        // should never get here - and if we *do* it should cause an error\n        // later on undefined fullTrace is passed to nestedProperty.\n    }\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // val=null will delete the attribute\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val, i) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val, i); });\n            return;\n        }\n        // quit if explicitly setting this elsewhere\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var extraparam;\n        if(attr.substr(0, 6) === 'LAYOUT') {\n            extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n        } else {\n            var tracei = traces[i];\n            var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n            extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n        }\n\n        if(!(attr in undoit)) {\n            undoit[attr] = a0();\n        }\n        if(undoit[attr][i] === undefined) {\n            undoit[attr][i] = undefinedToNull(extraparam.get());\n        }\n        if(val !== undefined) {\n            extraparam.set(val);\n        }\n    }\n\n    function allBins(binAttr) {\n        return function(j) {\n            return fullData[j][binAttr];\n        };\n    }\n\n    function arrayBins(binAttr) {\n        return function(vij, j) {\n            return vij === false ? fullData[traces[j]][binAttr] : null;\n        };\n    }\n\n    // now make the changes to gd.data (and occasionally gd.layout)\n    // and figure out what kind of graphics update we need to do\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n        }\n\n        var vi = aobj[ai];\n        var cont;\n        var contFull;\n        var param;\n        var oldVal;\n        var newVal;\n        var valObject;\n\n        // Backward compatibility shim for turning histogram autobin on,\n        // or freezing previous autobinned values.\n        // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n        // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n        if(ai === 'autobinx' || ai === 'autobiny') {\n            ai = ai.charAt(ai.length - 1) + 'bins';\n            if(Array.isArray(vi)) vi = vi.map(arrayBins(ai));\n            else if(vi === false) vi = traces.map(allBins(ai));\n            else vi = null;\n        }\n\n        redoit[ai] = vi;\n\n        if(ai.substr(0, 6) === 'LAYOUT') {\n            param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n            undoit[ai] = [undefinedToNull(param.get())];\n            // since we're allowing val to be an array, allow it here too,\n            // even though that's meaningless\n            param.set(Array.isArray(vi) ? vi[0] : vi);\n            // ironically, the layout attrs in restyle only require replot,\n            // not relayout\n            flags.calc = true;\n            continue;\n        }\n\n        // set attribute in gd.data\n        undoit[ai] = a0();\n        for(i = 0; i < traces.length; i++) {\n            cont = data[traces[i]];\n            contFull = getFullTrace(traces[i]);\n            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n            param = makeNP(preGUI, guiEditFlag)(cont, ai);\n            oldVal = param.get();\n            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n\n            if(newVal === undefined) continue;\n\n            var finalPart = param.parts[param.parts.length - 1];\n            var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n            var prefixDot = prefix ? prefix + '.' : '';\n            var innerContFull = prefix ?\n                nestedProperty(contFull, prefix).get() : contFull;\n\n            valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n            if(valObject && valObject.impliedEdits && newVal !== null) {\n                for(var impliedKey in valObject.impliedEdits) {\n                    doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n                }\n            } else if((finalPart === 'thicknessmode' || finalPart === 'lenmode') &&\n                    oldVal !== newVal &&\n                    (newVal === 'fraction' || newVal === 'pixels') &&\n                    innerContFull\n            ) {\n                // changing colorbar size modes,\n                // make the resulting size not change\n                // note that colorbar fractional sizing is based on the\n                // original plot size, before anything (like a colorbar)\n                // increases the margins\n\n                var gs = fullLayout._size;\n                var orient = innerContFull.orient;\n                var topOrBottom = (orient === 'top') || (orient === 'bottom');\n                if(finalPart === 'thicknessmode') {\n                    var thicknorm = topOrBottom ? gs.h : gs.w;\n                    doextra(prefixDot + 'thickness', innerContFull.thickness *\n                        (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n                } else {\n                    var lennorm = topOrBottom ? gs.w : gs.h;\n                    doextra(prefixDot + 'len', innerContFull.len *\n                        (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n                }\n            } else if(ai === 'type' && (\n                (newVal === 'pie') !== (oldVal === 'pie') ||\n                (newVal === 'funnelarea') !== (oldVal === 'funnelarea')\n            )) {\n                var labelsTo = 'x';\n                var valuesTo = 'y';\n                if((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n                    labelsTo = 'y';\n                    valuesTo = 'x';\n                }\n                Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n                Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n                Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n                if(oldVal === 'pie' || oldVal === 'funnelarea') {\n                    nestedProperty(cont, 'marker.color')\n                        .set(nestedProperty(cont, 'marker.colors').get());\n\n                    // super kludgy - but if all pies are gone we won't remove them otherwise\n                    fullLayout._pielayer.selectAll('g.trace').remove();\n                } else if(Registry.traceIs(cont, 'cartesian')) {\n                    nestedProperty(cont, 'marker.colors')\n                        .set(nestedProperty(cont, 'marker.color').get());\n                }\n            }\n\n            undoit[ai][i] = undefinedToNull(oldVal);\n            // set the new value - if val is an array, it's one el per trace\n            // first check for attributes that get more complex alterations\n            var swapAttrs = [\n                'swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'\n            ];\n            if(swapAttrs.indexOf(ai) !== -1) {\n                // setting an orientation: make sure it's changing\n                // before we swap everything else\n                if(ai === 'orientation') {\n                    param.set(newVal);\n                    // obnoxious that we need this level of coupling... but in order to\n                    // properly handle setting orientation to `null` we need to mimic\n                    // the logic inside Bars.supplyDefaults for default orientation\n                    var defaultOrientation = (cont.x && !cont.y) ? 'h' : 'v';\n                    if((param.get() || defaultOrientation) === contFull.orientation) {\n                        continue;\n                    }\n                } else if(ai === 'orientationaxes') {\n                    // orientationaxes has no value,\n                    // it flips everything and the axes\n\n                    cont.orientation =\n                        {v: 'h', h: 'v'}[contFull.orientation];\n                }\n                helpers.swapXYData(cont);\n                flags.calc = flags.clearAxisTypes = true;\n            } else if(Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n                // TODO: use manageArrays.applyContainerArrayChanges here too\n                helpers.manageArrayContainers(param, newVal, undoit);\n                flags.calc = true;\n            } else {\n                if(valObject) {\n                    // must redo calcdata when restyling array values of arrayOk attributes\n                    // ... but no need to this for regl-based traces\n                    if(valObject.arrayOk &&\n                        !Registry.traceIs(contFull, 'regl') &&\n                        (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))\n                    ) {\n                        flags.calc = true;\n                    } else editTypes.update(flags, valObject);\n                } else {\n                    /*\n                     * if we couldn't find valObject,  assume a full recalc.\n                     * This can happen if you're changing type and making\n                     * some other edits too, so the modules we're\n                     * looking at don't have these attributes in them.\n                     */\n                    flags.calc = true;\n                }\n\n                // all the other ones, just modify that one attribute\n                param.set(newVal);\n            }\n        }\n\n        // swap the data attributes of the relevant x and y axes?\n        if(['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n            Axes.swap(gd, traces);\n        }\n\n        // swap hovermode if set to \"compare x/y data\"\n        if(ai === 'orientationaxes') {\n            var hovermode = nestedProperty(gd.layout, 'hovermode');\n            if(hovermode.get() === 'x') {\n                hovermode.set('y');\n            } else if(hovermode.get() === 'y') {\n                hovermode.set('x');\n            } else if(hovermode.get() === 'x unified') {\n                hovermode.set('y unified');\n            } else if(hovermode.get() === 'y unified') {\n                hovermode.set('x unified');\n            }\n        }\n\n        // Major enough changes deserve autoscale and\n        // non-reversed axes so people don't get confused\n        //\n        // Note: autobin (or its new analog bin clearing) is not included here\n        // since we're not pushing bins back to gd.data, so if we have bin\n        // info it was explicitly provided by the user.\n        if(['orientation', 'type'].indexOf(ai) !== -1) {\n            axlist = [];\n            for(i = 0; i < traces.length; i++) {\n                var trace = data[traces[i]];\n\n                if(Registry.traceIs(trace, 'cartesian')) {\n                    addToAxlist(trace.xaxis || 'x');\n                    addToAxlist(trace.yaxis || 'y');\n                }\n            }\n\n            doextra(axlist.map(autorangeAttr), true, 0);\n            doextra(axlist.map(rangeAttr), [0, 1], 0);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    return {\n        flags: flags,\n        undoit: undoit,\n        redoit: redoit,\n        traces: traces,\n        eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n    };\n}\n\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\nfunction cleanDeprecatedAttributeKeys(aobj) {\n    var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n    var colorbarRegex = /colorbar\\.title$/;\n    var keys = Object.keys(aobj);\n    var i, key, value;\n\n    for(i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = aobj[key];\n\n        if((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) &&\n          (typeof value === 'string' || typeof value === 'number')) {\n            replace(key, key.replace('title', 'title.text'));\n        } else if(key.indexOf('titlefont') > -1) {\n            replace(key, key.replace('titlefont', 'title.font'));\n        } else if(key.indexOf('titleposition') > -1) {\n            replace(key, key.replace('titleposition', 'title.position'));\n        } else if(key.indexOf('titleside') > -1) {\n            replace(key, key.replace('titleside', 'title.side'));\n        } else if(key.indexOf('titleoffset') > -1) {\n            replace(key, key.replace('titleoffset', 'title.offset'));\n        }\n    }\n\n    function replace(oldAttrStr, newAttrStr) {\n        aobj[newAttrStr] = aobj[oldAttrStr];\n        delete aobj[oldAttrStr];\n    }\n}\n\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\nfunction relayout(gd, astr, val) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = Lib.extendFlat({}, astr);\n    } else {\n        Lib.warn('Relayout fail.', astr, val);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var specs = _relayout(gd, aobj);\n    var flags = specs.flags;\n\n    // clear calcdata if required\n    if(flags.calc) gd.calcdata = undefined;\n\n    // fill in redraw sequence\n\n    // even if we don't have anything left in aobj,\n    // something may have happened within relayout that we\n    // need to wait for\n    var seq = [Plots.previousPromises];\n\n    if(flags.layoutReplot) {\n        seq.push(subroutines.layoutReplot);\n    } else if(Object.keys(aobj).length) {\n        axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n\n        if(flags.legend) seq.push(subroutines.doLegend);\n        if(flags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n        if(flags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(flags.modebar) seq.push(subroutines.doModeBar);\n        if(flags.camera) seq.push(subroutines.doCamera);\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n\n    Queue.add(gd,\n        relayout, [gd, specs.undoit],\n        relayout, [gd, specs.redoit]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_relayout', specs.eventData);\n        return gd;\n    });\n}\n\n// Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n    var fullLayout = gd._fullLayout;\n\n    if(!flags.axrange) return false;\n\n    for(var k in flags) {\n        if(k !== 'axrange' && flags[k]) return false;\n    }\n\n    for(var axId in specs.rangesAltered) {\n        var axName = Axes.id2name(axId);\n        var axIn = gd.layout[axName];\n        var axOut = fullLayout[axName];\n        axOut.autorange = axIn.autorange;\n        axOut.range = axIn.range.slice();\n        axOut.cleanRange();\n\n        if(axOut._matchGroup) {\n            for(var axId2 in axOut._matchGroup) {\n                if(axId2 !== axId) {\n                    var ax2 = fullLayout[Axes.id2name(axId2)];\n                    ax2.autorange = axOut.autorange;\n                    ax2.range = axOut.range.slice();\n                    ax2._input.range = axOut.range.slice();\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n    // N.B. leave as sequence of subroutines (for now) instead of\n    // subroutine of its own so that finalDraw always gets\n    // executed after drawData\n    var drawAxes = rangesAltered ?\n        function(gd) {\n            var axIds = [];\n            var skipTitle = true;\n\n            for(var id in rangesAltered) {\n                var ax = Axes.getFromId(gd, id);\n                axIds.push(id);\n\n                if(ax._matchGroup) {\n                    for(var id2 in ax._matchGroup) {\n                        if(!rangesAltered[id2]) {\n                            axIds.push(id2);\n                        }\n                    }\n                }\n\n                if(ax.automargin) skipTitle = false;\n            }\n\n            return Axes.draw(gd, axIds, {skipTitle: skipTitle});\n        } :\n        function(gd) {\n            return Axes.draw(gd, 'redraw');\n        };\n\n    seq.push(\n        clearSelect,\n        subroutines.doAutoRangeAndConstraints,\n        drawAxes,\n        subroutines.drawData,\n        subroutines.finalDraw\n    );\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n    var layout = gd.layout;\n    var fullLayout = gd._fullLayout;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var keys = Object.keys(aobj);\n    var axes = Axes.list(gd);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var arrayEdits = {};\n\n    var arrayStr, i, j;\n\n    cleanDeprecatedAttributeKeys(aobj);\n    keys = Object.keys(aobj);\n\n    // look for 'allaxes', split out into all axes\n    // in case of 3D the axis are nested within a scene which is held in _id\n    for(i = 0; i < keys.length; i++) {\n        if(keys[i].indexOf('allaxes') === 0) {\n            for(j = 0; j < axes.length; j++) {\n                var scene = axes[j]._id.substr(1);\n                var axisAttr = (scene.indexOf('scene') !== -1) ? (scene + '.') : '';\n                var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n\n                if(!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n            }\n\n            delete aobj[keys[i]];\n        }\n    }\n\n    // initialize flags\n    var flags = editTypes.layoutFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val); });\n            return;\n        }\n\n        // if we have another value for this attribute (explicitly or\n        // via a parent) do not override with this auto-generated extra\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var p = layoutNP(layout, attr);\n        if(!(attr in undoit)) {\n            undoit[attr] = undefinedToNull(p.get());\n        }\n        if(val !== undefined) p.set(val);\n    }\n\n    // for constraint enforcement: keep track of all axes (as {id: name})\n    // we're editing the (auto)range of, so we can tell the others constrained\n    // to scale with them that it's OK for them to shrink\n    var rangesAltered = {};\n    var axId;\n\n    function recordAlteredAxis(pleafPlus) {\n        var axId = Axes.name2id(pleafPlus.split('.')[0]);\n        rangesAltered[axId] = 1;\n        return axId;\n    }\n\n    // alter gd.layout\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n        }\n\n        var p = layoutNP(layout, ai);\n        var vi = aobj[ai];\n        var plen = p.parts.length;\n        // p.parts may end with an index integer if the property is an array\n        var pend = plen - 1;\n        while(pend > 0 && typeof p.parts[pend] !== 'string') pend--;\n        // last property in chain (leaf node)\n        var pleaf = p.parts[pend];\n        // leaf plus immediate parent\n        var pleafPlus = p.parts[pend - 1] + '.' + pleaf;\n        // trunk nodes (everything except the leaf)\n        var ptrunk = p.parts.slice(0, pend).join('.');\n        var parentIn = nestedProperty(gd.layout, ptrunk).get();\n        var parentFull = nestedProperty(fullLayout, ptrunk).get();\n        var vOld = p.get();\n\n        if(vi === undefined) continue;\n\n        redoit[ai] = vi;\n\n        // axis reverse is special - it is its own inverse\n        // op and has no flag.\n        undoit[ai] = (pleaf === 'reverse') ? vi : undefinedToNull(vOld);\n\n        var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n        if(valObject && valObject.impliedEdits && vi !== null) {\n            for(var impliedKey in valObject.impliedEdits) {\n                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n            }\n        }\n\n        // Setting width or height to null must reset the graph's width / height\n        // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        //\n        // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // can't use impliedEdits for this because behavior depends on vi\n        if(['width', 'height'].indexOf(ai) !== -1) {\n            if(vi) {\n                doextra('autosize', null);\n                // currently we don't support autosize one dim only - so\n                // explicitly set the other one. Note that doextra will\n                // ignore this if the same relayout call also provides oppositeAttr\n                var oppositeAttr = ai === 'height' ? 'width' : 'height';\n                doextra(oppositeAttr, fullLayout[oppositeAttr]);\n            } else {\n                fullLayout[ai] = gd._initialAutoSize[ai];\n            }\n        } else if(ai === 'autosize') {\n            // depends on vi here too, so again can't use impliedEdits\n            doextra('width', vi ? null : fullLayout.width);\n            doextra('height', vi ? null : fullLayout.height);\n        } else if(pleafPlus.match(AX_RANGE_RE)) {\n            // check autorange vs range\n\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        } else if(pleafPlus.match(AX_AUTORANGE_RE)) {\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n            var axFull = nestedProperty(fullLayout, ptrunk).get();\n            if(axFull._inputDomain) {\n                // if we're autoranging and this axis has a constrained domain,\n                // reset it so we don't get locked into a shrunken size\n                axFull._input.domain = axFull._inputDomain.slice();\n            }\n        } else if(pleafPlus.match(AX_DOMAIN_RE)) {\n            nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n        }\n\n        // toggling axis type between log and linear: we need to convert\n        // positions for components that are still using linearized values,\n        // not data values like newer components.\n        // previously we did this for log <-> not-log, but now only do it\n        // for log <-> linear\n        if(pleaf === 'type') {\n            var ax = parentIn;\n            var toLog = parentFull.type === 'linear' && vi === 'log';\n            var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n            if(toLog || fromLog) {\n                if(!ax || !ax.range) {\n                    // 2D never gets here, but 3D does\n                    // I don't think this is needed, but left here in case there\n                    // are edge cases I'm not thinking of.\n                    doextra(ptrunk + '.autorange', true);\n                } else if(!parentFull.autorange) {\n                    // toggling log without autorange: need to also recalculate ranges\n                    // because log axes use linearized values for range endpoints\n                    var r0 = ax.range[0];\n                    var r1 = ax.range[1];\n                    if(toLog) {\n                        // if both limits are negative, autorange\n                        if(r0 <= 0 && r1 <= 0) {\n                            doextra(ptrunk + '.autorange', true);\n                        }\n                        // if one is negative, set it 6 orders below the other.\n                        if(r0 <= 0) r0 = r1 / 1e6;\n                        else if(r1 <= 0) r1 = r0 / 1e6;\n                        // now set the range values as appropriate\n                        doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n                        doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n                    } else {\n                        doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n                        doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n                    }\n                } else if(toLog) {\n                    // just make sure the range is positive and in the right\n                    // order, it'll get recalculated later\n                    ax.range = (ax.range[1] > ax.range[0]) ? [1, 2] : [2, 1];\n                }\n\n                // clear polar view initial stash for radial range so that\n                // value get recomputed in correct units\n                if(Array.isArray(fullLayout._subplots.polar) &&\n                    fullLayout._subplots.polar.length &&\n                    fullLayout[p.parts[0]] &&\n                    p.parts[1] === 'radialaxis'\n                ) {\n                    delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n                }\n\n                // Annotations and images also need to convert to/from linearized coords\n                // Shapes do not need this :)\n                Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n                Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n            } else {\n                // any other type changes: the range from the previous type\n                // will not make sense, so autorange it.\n                doextra(ptrunk + '.autorange', true);\n                doextra(ptrunk + '.range', null);\n            }\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        } else if(pleaf.match(AX_NAME_PATTERN)) {\n            var fullProp = nestedProperty(fullLayout, ai).get();\n            var newType = (vi || {}).type;\n\n            // This can potentially cause strange behavior if the autotype is not\n            // numeric (linear, because we don't auto-log) but the previous type\n            // was log. That's a very strange edge case though\n            if(!newType || newType === '-') newType = 'linear';\n            Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n            Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n        }\n\n        // alter gd.layout\n\n        // collect array component edits for execution all together\n        // so we can ensure consistent behavior adding/removing items\n        // and order-independence for add/remove/edit all together in\n        // one relayout call\n        var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n        if(containerArrayMatch) {\n            arrayStr = containerArrayMatch.array;\n            i = containerArrayMatch.index;\n            var propStr = containerArrayMatch.property;\n            var updateValObject = valObject || {editType: 'calc'};\n\n            if(i !== '' && propStr === '') {\n                // special handling of undoit if we're adding or removing an element\n                // ie 'annotations[2]' which can be {...} (add) or null,\n                // does not work when replacing the entire array\n                if(manageArrays.isAddVal(vi)) {\n                    undoit[ai] = null;\n                } else if(manageArrays.isRemoveVal(vi)) {\n                    undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n                } else {\n                    Lib.warn('unrecognized full object value', aobj);\n                }\n            }\n            editTypes.update(flags, updateValObject);\n\n            // prepare the edits object we'll send to applyContainerArrayChanges\n            if(!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n            var objEdits = arrayEdits[arrayStr][i];\n            if(!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n            objEdits[propStr] = vi;\n\n            delete aobj[ai];\n        } else if(pleaf === 'reverse') {\n            // handle axis reversal explicitly, as there's no 'reverse' attribute\n\n            if(parentIn.range) parentIn.range.reverse();\n            else {\n                doextra(ptrunk + '.autorange', true);\n                parentIn.range = [1, 0];\n            }\n\n            if(parentFull.autorange) flags.calc = true;\n            else flags.plot = true;\n        } else {\n            if((fullLayout._has('scatter-like') && fullLayout._has('regl')) &&\n                (ai === 'dragmode' &&\n                (vi === 'lasso' || vi === 'select') &&\n                !(vOld === 'lasso' || vOld === 'select'))\n            ) {\n                flags.plot = true;\n            } else if(fullLayout._has('gl2d')) {\n                flags.plot = true;\n            } else if(valObject) editTypes.update(flags, valObject);\n            else flags.calc = true;\n\n            p.set(vi);\n        }\n    }\n\n    // now we've collected component edits - execute them all together\n    for(arrayStr in arrayEdits) {\n        var finished = manageArrays.applyContainerArrayChanges(gd,\n            layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n        if(!finished) flags.plot = true;\n    }\n\n    // figure out if we need to recalculate axis constraints\n    var constraints = fullLayout._axisConstraintGroups || [];\n    for(axId in rangesAltered) {\n        for(i = 0; i < constraints.length; i++) {\n            var group = constraints[i];\n            if(group[axId]) {\n                // Always recalc if we're changing constrained ranges.\n                // Otherwise it's possible to violate the constraints by\n                // specifying arbitrary ranges for all axes in the group.\n                // this way some ranges may expand beyond what's specified,\n                // as they do at first draw, to satisfy the constraints.\n                flags.calc = true;\n                for(var groupAxId in group) {\n                    if(!rangesAltered[groupAxId]) {\n                        Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the autosize changed or height or width was explicitly specified,\n    // this triggers a redraw\n    // TODO: do we really need special aobj.height/width handling here?\n    // couldn't editType do this?\n    if(updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    // now all attribute mods are done, as are\n    // redo and undo so we can save them\n\n    return {\n        flags: flags,\n        rangesAltered: rangesAltered,\n        undoit: undoit,\n        redoit: redoit,\n        eventData: eventData\n    };\n}\n\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\nfunction updateAutosize(gd) {\n    var fullLayout = gd._fullLayout;\n    var oldWidth = fullLayout.width;\n    var oldHeight = fullLayout.height;\n\n    // calculate autosizing\n    if(gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n\n    return (fullLayout.width !== oldWidth) || (fullLayout.height !== oldHeight);\n}\n\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    if(!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n    if(!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n\n    if(Object.keys(traceUpdate).length) gd.changed = true;\n    if(Object.keys(layoutUpdate).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n    var restyleFlags = restyleSpecs.flags;\n\n    var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n    var relayoutFlags = relayoutSpecs.flags;\n\n    // clear calcdata and/or axis types if required\n    if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n    if(restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(relayoutFlags.layoutReplot) {\n        // N.B. works fine when both\n        // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n        seq.push(subroutines.layoutReplot);\n    } else if(restyleFlags.fullReplot) {\n        seq.push(exports.plot);\n    } else {\n        seq.push(Plots.previousPromises);\n        axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n\n        if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n        if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n        if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n        if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n        if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n        if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n\n    Queue.add(gd,\n        update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],\n        update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_update', {\n            data: restyleSpecs.eventData,\n            layout: relayoutSpecs.eventData\n        });\n\n        return gd;\n    });\n}\n\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\nfunction guiEdit(func) {\n    return function wrappedEdit(gd) {\n        gd._fullLayout._guiEditing = true;\n        var p = func.apply(null, arguments);\n        gd._fullLayout._guiEditing = false;\n        return p;\n    };\n}\n\n// For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\nvar layoutUIControlPatterns = [\n    {pattern: /^hiddenlabels/, attr: 'legend.uirevision'},\n    {pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/},\n\n    // showspikes and modes include those nested inside scenes\n    {pattern: /axis\\d*\\.showspikes$/, attr: 'modebar.uirevision'},\n    {pattern: /(hover|drag)mode$/, attr: 'modebar.uirevision'},\n\n    {pattern: /^(scene\\d*)\\.camera/},\n    {pattern: /^(geo\\d*)\\.(projection|center|fitbounds)/},\n    {pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/},\n    {pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/},\n    {pattern: /^(polar\\d*\\.angularaxis)\\.rotation/},\n    {pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/},\n\n    {pattern: /^legend\\.(x|y)$/, attr: 'editrevision'},\n    {pattern: /^(shapes|annotations)/, attr: 'editrevision'},\n    {pattern: /^title\\.text$/, attr: 'editrevision'}\n];\n\n// same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\nvar traceUIControlPatterns = [\n    {pattern: /^selectedpoints$/, attr: 'selectionrevision'},\n    // \"visible\" includes trace.transforms[i].styles[j].value.visible\n    {pattern: /(^|value\\.)visible$/, attr: 'legend.uirevision'},\n    {pattern: /^dimensions\\[\\d+\\]\\.constraintrange/},\n    {pattern: /^node\\.(x|y|groups)/}, // for Sankey nodes\n    {pattern: /^level$/}, // for Sunburst & Treemap traces\n\n    // below this you must be in editable: true mode\n    // TODO: I still put name and title with `trace.uirevision`\n    // reasonable or should these be `editrevision`?\n    // Also applies to axis titles up in the layout section\n\n    // \"name\" also includes transform.styles\n    {pattern: /(^|value\\.)name$/},\n    // including nested colorbar attributes (ie marker.colorbar)\n    {pattern: /colorbar\\.title\\.text$/},\n    {pattern: /colorbar\\.(x|y)$/, attr: 'editrevision'}\n];\n\nfunction findUIPattern(key, patternSpecs) {\n    for(var i = 0; i < patternSpecs.length; i++) {\n        var spec = patternSpecs[i];\n        var match = key.match(spec.pattern);\n        if(match) {\n            return {head: match[1], attr: spec.attr};\n        }\n    }\n}\n\n// We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\nfunction getNewRev(revAttr, container) {\n    var newRev = nestedProperty(container, revAttr).get();\n    if(newRev !== undefined) return newRev;\n\n    var parts = revAttr.split('.');\n    parts.pop();\n    while(parts.length > 1) {\n        parts.pop();\n        newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n        if(newRev !== undefined) return newRev;\n    }\n\n    return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n    for(var i = 0; i < fullData.length; i++) {\n        if(fullData[i]._fullInput.uid === uid) return i;\n    }\n    return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n    for(var i = 0; i < data.length; i++) {\n        if(data[i].uid === uid) return i;\n    }\n    // fall back on trace order, but only if user didn't provide a uid for that trace\n    return (!data[tracei] || data[tracei].uid) ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n    var v1IsObj = Lib.isPlainObject(v1);\n    var v1IsArray = Array.isArray(v1);\n    if(v1IsObj || v1IsArray) {\n        return (\n            (v1IsObj && Lib.isPlainObject(v2)) ||\n            (v1IsArray && Array.isArray(v2))\n        ) && JSON.stringify(v1) === JSON.stringify(v2);\n    }\n    return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n    var layoutPreGUI = oldFullLayout._preGUI;\n    var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n    var bothInheritAutorange = [];\n    var newRangeAccepted = {};\n    for(key in layoutPreGUI) {\n        match = findUIPattern(key, layoutUIControlPatterns);\n        if(match) {\n            revAttr = match.attr || (match.head + '.uirevision');\n            oldRev = nestedProperty(oldFullLayout, revAttr).get();\n            newRev = oldRev && getNewRev(revAttr, layout);\n            if(newRev && (newRev === oldRev)) {\n                preGUIVal = layoutPreGUI[key];\n                if(preGUIVal === null) preGUIVal = undefined;\n                newNP = nestedProperty(layout, key);\n                newVal = newNP.get();\n                if(valsMatch(newVal, preGUIVal)) {\n                    if(newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n                        bothInheritAutorange.push(key.substr(0, key.length - 10));\n                    }\n                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n                    continue;\n                }\n            }\n        } else {\n            Lib.warn('unrecognized GUI edit: ' + key);\n        }\n        // if we got this far, the new value was accepted as the new starting\n        // point (either because it changed or revision changed)\n        // so remove it from _preGUI for next time.\n        delete layoutPreGUI[key];\n\n        if(key.substr(key.length - 8, 6) === 'range[') {\n            newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n        }\n    }\n\n    // Special logic for `autorange`, since it interacts with `range`:\n    // If the new figure's matching `range` was kept, and `autorange`\n    // wasn't supplied explicitly in either the original or the new figure,\n    // we shouldn't alter that - but we may just have done that, so fix it.\n    for(var i = 0; i < bothInheritAutorange.length; i++) {\n        var axAttr = bothInheritAutorange[i];\n        if(newRangeAccepted[axAttr]) {\n            var newAx = nestedProperty(layout, axAttr).get();\n            if(newAx) delete newAx.autorange;\n        }\n    }\n\n    // Now traces - try to match them up by uid (in case we added/deleted in\n    // the middle), then fall back on index.\n    var allTracePreGUI = oldFullLayout._tracePreGUI;\n    for(var uid in allTracePreGUI) {\n        var tracePreGUI = allTracePreGUI[uid];\n        var newTrace = null;\n        var fullInput;\n        for(key in tracePreGUI) {\n            // wait until we know we have preGUI values to look for traces\n            // but if we don't find both, stop looking at this uid\n            if(!newTrace) {\n                var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n                if(fulli < 0) {\n                    // Somehow we didn't even have this trace in oldFullData...\n                    // I guess this could happen with `deleteTraces` or something\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                var fullTrace = oldFullData[fulli];\n                fullInput = fullTrace._fullInput;\n\n                var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n                if(newTracei < 0) {\n                    // No match in new data\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                newTrace = data[newTracei];\n            }\n\n            match = findUIPattern(key, traceUIControlPatterns);\n            if(match) {\n                if(match.attr) {\n                    oldRev = nestedProperty(oldFullLayout, match.attr).get();\n                    newRev = oldRev && getNewRev(match.attr, layout);\n                } else {\n                    oldRev = fullInput.uirevision;\n                    // inheritance for trace.uirevision is simple, just layout.uirevision\n                    newRev = newTrace.uirevision;\n                    if(newRev === undefined) newRev = layout.uirevision;\n                }\n\n                if(newRev && newRev === oldRev) {\n                    preGUIVal = tracePreGUI[key];\n                    if(preGUIVal === null) preGUIVal = undefined;\n                    newNP = nestedProperty(newTrace, key);\n                    newVal = newNP.get();\n                    if(valsMatch(newVal, preGUIVal)) {\n                        newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n                        continue;\n                    }\n                }\n            } else {\n                Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n            }\n            delete tracePreGUI[key];\n        }\n    }\n}\n\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction react(gd, data, layout, config) {\n    var frames, plotDone;\n\n    function addFrames() { return exports.addFrames(gd, frames); }\n\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var oldFullData = gd._fullData;\n    var oldFullLayout = gd._fullLayout;\n\n    // you can use this as the initial draw as well as to update\n    if(!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n        plotDone = exports.newPlot(gd, data, layout, config);\n    } else {\n        if(Lib.isPlainObject(data)) {\n            var obj = data;\n            data = obj.data;\n            layout = obj.layout;\n            config = obj.config;\n            frames = obj.frames;\n        }\n\n        var configChanged = false;\n        // assume that if there's a config at all, we're reacting to it too,\n        // and completely replace the previous config\n        if(config) {\n            var oldConfig = Lib.extendDeep({}, gd._context);\n            gd._context = undefined;\n            setPlotContext(gd, config);\n            configChanged = diffConfig(oldConfig, gd._context);\n        }\n\n        gd.data = data || [];\n        helpers.cleanData(gd.data);\n        gd.layout = layout || {};\n        helpers.cleanLayout(gd.layout);\n\n        applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);\n\n        // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n        // which supplyDefaults usually does at the end, but we may need to NOT do\n        // if the diff (which we haven't determined yet) says we'll recalc\n        Plots.supplyDefaults(gd, {skipUpdateCalc: true});\n\n        var newFullData = gd._fullData;\n        var newFullLayout = gd._fullLayout;\n        var immutable = newFullLayout.datarevision === undefined;\n        var transition = newFullLayout.transition;\n\n        var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n        var newDataRevision = relayoutFlags.newDataRevision;\n        var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);\n\n        // TODO: how to translate this part of relayout to Plotly.react?\n        // // Setting width or height to null must reset the graph's width / height\n        // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        // //\n        // // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n        //     fullLayout[ai] = gd._initialAutoSize[ai];\n        // }\n\n        if(updateAutosize(gd)) relayoutFlags.layoutReplot = true;\n\n        // clear calcdata if required\n        if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n        // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n        else Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\n\n        // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n        // must be handled by the user when using Plotly.react.\n\n        // fill in redraw sequence\n        var seq = [];\n\n        if(frames) {\n            gd._transitionData = {};\n            Plots.createTransitionData(gd);\n            seq.push(addFrames);\n        }\n\n        // Transition pathway,\n        // only used when 'transition' is set by user and\n        // when at least one animatable attribute has changed,\n        // N.B. config changed aren't animatable\n        if(newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n            Plots.doCalcdata(gd);\n            subroutines.doAutoRangeAndConstraints(gd);\n\n            seq.push(function() {\n                return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n            });\n        } else if(restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n            gd._fullLayout._skipDefaults = true;\n            seq.push(exports.plot);\n        } else {\n            for(var componentType in relayoutFlags.arrays) {\n                var indices = relayoutFlags.arrays[componentType];\n                if(indices.length) {\n                    var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n                    if(drawOne !== Lib.noop) {\n                        for(var i = 0; i < indices.length; i++) {\n                            drawOne(gd, indices[i]);\n                        }\n                    } else {\n                        var draw = Registry.getComponentMethod(componentType, 'draw');\n                        if(draw === Lib.noop) {\n                            throw new Error('cannot draw components: ' + componentType);\n                        }\n                        draw(gd);\n                    }\n                }\n            }\n\n            seq.push(Plots.previousPromises);\n            if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n            if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n            if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n            if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n            if(relayoutFlags.axrange) addAxRangeSequence(seq);\n            if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n            if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n            if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n            seq.push(emitAfterPlot);\n        }\n\n        seq.push(Plots.rehover, Plots.redrag);\n\n        plotDone = Lib.syncOrAsync(seq, gd);\n        if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n    }\n\n    return plotDone.then(function() {\n        gd.emit('plotly_react', {\n            data: data,\n            layout: layout\n        });\n\n        return gd;\n    });\n}\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n    var sameTraceLength = oldFullData.length === newFullData.length;\n\n    if(!transition && !sameTraceLength) {\n        return {\n            fullReplot: true,\n            calc: true\n        };\n    }\n\n    var flags = editTypes.traceFlags();\n    flags.arrays = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    var i, trace;\n\n    function getTraceValObject(parts) {\n        var out = PlotSchema.getTraceValObject(trace, parts);\n        if(!trace._module.animatable && out.anim) {\n            out.anim = false;\n        }\n        return out;\n    }\n\n    var diffOpts = {\n        getValObject: getTraceValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        newDataRevision: newDataRevision,\n        gd: gd\n    };\n\n    var seenUIDs = {};\n\n    for(i = 0; i < oldFullData.length; i++) {\n        if(newFullData[i]) {\n            trace = newFullData[i]._fullInput;\n            if(Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n            if(seenUIDs[trace.uid]) continue;\n            seenUIDs[trace.uid] = 1;\n\n            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = (flags.nChanges === flags.nChangesAnim) && sameTraceLength ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n    var flags = editTypes.layoutFlags();\n    flags.arrays = {};\n    flags.rangesAltered = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    function getLayoutValObject(parts) {\n        return PlotSchema.getLayoutValObject(newFullLayout, parts);\n    }\n\n    var diffOpts = {\n        getValObject: getLayoutValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        gd: gd\n    };\n\n    getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n    var valObject, key, astr;\n\n    var getValObject = opts.getValObject;\n    var flags = opts.flags;\n    var immutable = opts.immutable;\n    var inArray = opts.inArray;\n    var arrayIndex = opts.arrayIndex;\n\n    function changed() {\n        var editType = valObject.editType;\n        if(inArray && editType.indexOf('arraydraw') !== -1) {\n            Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n            return;\n        }\n        editTypes.update(flags, valObject);\n\n        if(editType !== 'none') {\n            flags.nChanges++;\n        }\n\n        // track animatable changes\n        if(opts.transition && valObject.anim) {\n            flags.nChangesAnim++;\n        }\n\n        // track cartesian axes with altered ranges\n        if(AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n            flags.rangesAltered[outerparts[0]] = 1;\n        }\n\n        // clear _inputDomain on cartesian axes with altered domains\n        if(AX_DOMAIN_RE.test(astr)) {\n            nestedProperty(newContainer, '_inputDomain').set(null);\n        }\n\n        // track datarevision changes\n        if(key === 'datarevision') {\n            flags.newDataRevision = 1;\n        }\n    }\n\n    function valObjectCanBeDataArray(valObject) {\n        return valObject.valType === 'data_array' || valObject.arrayOk;\n    }\n\n    for(key in oldContainer) {\n        // short-circuit based on previous calls or previous keys that already maximized the pathway\n        if(flags.calc && !opts.transition) return;\n\n        var oldVal = oldContainer[key];\n        var newVal = newContainer[key];\n        var parts = outerparts.concat(key);\n        astr = parts.join('.');\n\n        if(key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;\n\n        // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n        // and unlike other auto values they don't make it back into the input,\n        // so newContainer won't have them.\n        if((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n            var tickMode = newContainer.tickmode;\n            if(tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n        }\n        // FIXME: Similarly for axis ranges for 3D\n        // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n        if(key === 'range' && newContainer.autorange) continue;\n        if((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n\n        valObject = getValObject(parts);\n\n        // in case type changed, we may not even *have* a valObject.\n        if(!valObject) continue;\n\n        if(valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n\n        var valType = valObject.valType;\n        var i;\n\n        var canBeDataArray = valObjectCanBeDataArray(valObject);\n        var wasArray = Array.isArray(oldVal);\n        var nowArray = Array.isArray(newVal);\n\n        // hack for traces that modify the data in supplyDefaults, like\n        // converting 1D to 2D arrays, which will always create new objects\n        if(wasArray && nowArray) {\n            var inputKey = '_input_' + key;\n            var oldValIn = oldContainer[inputKey];\n            var newValIn = newContainer[inputKey];\n            if(Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n        }\n\n        if(newVal === undefined) {\n            if(canBeDataArray && wasArray) flags.calc = true;\n            else changed();\n        } else if(valObject._isLinkedToArray) {\n            var arrayEditIndices = [];\n            var extraIndices = false;\n            if(!inArray) flags.arrays[key] = arrayEditIndices;\n\n            var minLen = Math.min(oldVal.length, newVal.length);\n            var maxLen = Math.max(oldVal.length, newVal.length);\n            if(minLen !== maxLen) {\n                if(valObject.editType === 'arraydraw') {\n                    extraIndices = true;\n                } else {\n                    changed();\n                    continue;\n                }\n            }\n\n            for(i = 0; i < minLen; i++) {\n                getDiffFlags(oldVal[i], newVal[i], parts.concat(i),\n                    // add array indices, but not if we're already in an array\n                    Lib.extendFlat({inArray: key, arrayIndex: i}, opts));\n            }\n\n            // put this at the end so that we know our collected array indices are sorted\n            // but the check for length changes happens up front so we can short-circuit\n            // diffing if appropriate\n            if(extraIndices) {\n                for(i = minLen; i < maxLen; i++) {\n                    arrayEditIndices.push(i);\n                }\n            }\n        } else if(!valType && Lib.isPlainObject(oldVal)) {\n            getDiffFlags(oldVal, newVal, parts, opts);\n        } else if(canBeDataArray) {\n            if(wasArray && nowArray) {\n                // don't try to diff two data arrays. If immutable we know the data changed,\n                // if not, assume it didn't and let `layout.datarevision` tell us if it did\n                if(immutable) {\n                    flags.calc = true;\n                }\n\n                // look for animatable attributes when the data changed\n                if(immutable || opts.newDataRevision) {\n                    changed();\n                }\n            } else if(wasArray !== nowArray) {\n                flags.calc = true;\n            } else changed();\n        } else if(wasArray && nowArray) {\n            // info array, colorscale, 'any' - these are short, just stringify.\n            // I don't *think* that covers up any real differences post-validation, does it?\n            // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n            // all elements.\n            if(oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n                changed();\n            }\n        } else {\n            changed();\n        }\n    }\n\n    for(key in newContainer) {\n        if(!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n            valObject = getValObject(outerparts.concat(key));\n\n            if(valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n                flags.calc = true;\n                return;\n            } else changed();\n        }\n    }\n}\n\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\nfunction diffConfig(oldConfig, newConfig) {\n    var key;\n\n    for(key in oldConfig) {\n        if(key.charAt(0) === '_') continue;\n        var oldVal = oldConfig[key];\n        var newVal = newConfig[key];\n        if(oldVal !== newVal) {\n            if(Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n                if(diffConfig(oldVal, newVal)) {\n                    return true;\n                }\n            } else if(Array.isArray(oldVal) && Array.isArray(newVal)) {\n                if(oldVal.length !== newVal.length) {\n                    return true;\n                }\n                for(var i = 0; i < oldVal.length; i++) {\n                    if(oldVal[i] !== newVal[i]) {\n                        if(Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n                            if(diffConfig(oldVal[i], newVal[i])) {\n                                return true;\n                            }\n                        } else {\n                            return true;\n                        }\n                    }\n                }\n            } else {\n                return true;\n            }\n        }\n    }\n}\n\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before animating it. For more details, see ' +\n            'https://plotly.com/javascript/animations/'\n        );\n    }\n\n    var trans = gd._transitionData;\n\n    // This is the queue of frames that will be animated as soon as possible. They\n    // are popped immediately upon the *start* of a transition:\n    if(!trans._frameQueue) {\n        trans._frameQueue = [];\n    }\n\n    animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n    var transitionOpts = animationOpts.transition;\n    var frameOpts = animationOpts.frame;\n\n    // Since frames are popped immediately, an empty queue only means all frames have\n    // *started* to transition, not that the animation is complete. To solve that,\n    // track a separate counter that increments at the same time as frames are added\n    // to the queue, but decrements only when the transition is complete.\n    if(trans._frameWaitingCnt === undefined) {\n        trans._frameWaitingCnt = 0;\n    }\n\n    function getTransitionOpts(i) {\n        if(Array.isArray(transitionOpts)) {\n            if(i >= transitionOpts.length) {\n                return transitionOpts[0];\n            } else {\n                return transitionOpts[i];\n            }\n        } else {\n            return transitionOpts;\n        }\n    }\n\n    function getFrameOpts(i) {\n        if(Array.isArray(frameOpts)) {\n            if(i >= frameOpts.length) {\n                return frameOpts[0];\n            } else {\n                return frameOpts[i];\n            }\n        } else {\n            return frameOpts;\n        }\n    }\n\n    // Execute a callback after the wrapper function has been called n times.\n    // This is used to defer the resolution until a transition has resovled *and*\n    // the frame has completed. If it's not done this way, then we get a race\n    // condition in which the animation might resolve before a transition is complete\n    // or vice versa.\n    function callbackOnNthTime(cb, n) {\n        var cnt = 0;\n        return function() {\n            if(cb && ++cnt === n) {\n                return cb();\n            }\n        };\n    }\n\n    return new Promise(function(resolve, reject) {\n        function discardExistingFrames() {\n            if(trans._frameQueue.length === 0) {\n                return;\n            }\n\n            while(trans._frameQueue.length) {\n                var next = trans._frameQueue.pop();\n                if(next.onInterrupt) {\n                    next.onInterrupt();\n                }\n            }\n\n            gd.emit('plotly_animationinterrupted', []);\n        }\n\n        function queueFrames(frameList) {\n            if(frameList.length === 0) return;\n\n            for(var i = 0; i < frameList.length; i++) {\n                var computedFrame;\n\n                if(frameList[i].type === 'byname') {\n                    // If it's a named frame, compute it:\n                    computedFrame = Plots.computeFrame(gd, frameList[i].name);\n                } else {\n                    // Otherwise we must have been given a simple object, so treat\n                    // the input itself as the computed frame.\n                    computedFrame = frameList[i].data;\n                }\n\n                var frameOpts = getFrameOpts(i);\n                var transitionOpts = getTransitionOpts(i);\n\n                // It doesn't make much sense for the transition duration to be greater than\n                // the frame duration, so limit it:\n                transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n\n                var nextFrame = {\n                    frame: computedFrame,\n                    name: frameList[i].name,\n                    frameOpts: frameOpts,\n                    transitionOpts: transitionOpts,\n                };\n                if(i === frameList.length - 1) {\n                    // The last frame in this .animate call stores the promise resolve\n                    // and reject callbacks. This is how we ensure that the animation\n                    // loop (which may exist as a result of a *different* .animate call)\n                    // still resolves or rejecdts this .animate call's promise. once it's\n                    // complete.\n                    nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n                    nextFrame.onInterrupt = reject;\n                }\n\n                trans._frameQueue.push(nextFrame);\n            }\n\n            // Set it as never having transitioned to a frame. This will cause the animation\n            // loop to immediately transition to the next frame (which, for immediate mode,\n            // is the first frame in the list since all others would have been discarded\n            // below)\n            if(animationOpts.mode === 'immediate') {\n                trans._lastFrameAt = -Infinity;\n            }\n\n            // Only it's not already running, start a RAF loop. This could be avoided in the\n            // case that there's only one frame, but it significantly complicated the logic\n            // and only sped things up by about 5% or so for a lorenz attractor simulation.\n            // It would be a fine thing to implement, but the benefit of that optimization\n            // doesn't seem worth the extra complexity.\n            if(!trans._animationRaf) {\n                beginAnimationLoop();\n            }\n        }\n\n        function stopAnimationLoop() {\n            gd.emit('plotly_animated');\n\n            // Be sure to unset also since it's how we know whether a loop is already running:\n            window.cancelAnimationFrame(trans._animationRaf);\n            trans._animationRaf = null;\n        }\n\n        function nextFrame() {\n            if(trans._currentFrame && trans._currentFrame.onComplete) {\n                // Execute the callback and unset it to ensure it doesn't\n                // accidentally get called twice\n                trans._currentFrame.onComplete();\n            }\n\n            var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n            if(newFrame) {\n                // Since it's sometimes necessary to do deep digging into frame data,\n                // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n                // so check when casting the name, just to be absolutely certain:\n                var stringName = newFrame.name ? newFrame.name.toString() : null;\n                gd._fullLayout._currentFrame = stringName;\n\n                trans._lastFrameAt = Date.now();\n                trans._timeToNext = newFrame.frameOpts.duration;\n\n                // This is simply called and it's left to .transition to decide how to manage\n                // interrupting current transitions. That means we don't need to worry about\n                // how it resolves or what happens after this:\n                Plots.transition(gd,\n                    newFrame.frame.data,\n                    newFrame.frame.layout,\n                    helpers.coerceTraceIndices(gd, newFrame.frame.traces),\n                    newFrame.frameOpts,\n                    newFrame.transitionOpts\n                ).then(function() {\n                    if(newFrame.onComplete) {\n                        newFrame.onComplete();\n                    }\n                });\n\n                gd.emit('plotly_animatingframe', {\n                    name: stringName,\n                    frame: newFrame.frame,\n                    animation: {\n                        frame: newFrame.frameOpts,\n                        transition: newFrame.transitionOpts,\n                    }\n                });\n            } else {\n                // If there are no more frames, then stop the RAF loop:\n                stopAnimationLoop();\n            }\n        }\n\n        function beginAnimationLoop() {\n            gd.emit('plotly_animating');\n\n            // If no timer is running, then set last frame = long ago so that the next\n            // frame is immediately transitioned:\n            trans._lastFrameAt = -Infinity;\n            trans._timeToNext = 0;\n            trans._runningTransitions = 0;\n            trans._currentFrame = null;\n\n            var doFrame = function() {\n                // This *must* be requested before nextFrame since nextFrame may decide\n                // to cancel it if there's nothing more to animated:\n                trans._animationRaf = window.requestAnimationFrame(doFrame);\n\n                // Check if we're ready for a new frame:\n                if(Date.now() - trans._lastFrameAt > trans._timeToNext) {\n                    nextFrame();\n                }\n            };\n\n            doFrame();\n        }\n\n        // This is an animate-local counter that helps match up option input list\n        // items with the particular frame.\n        var configCounter = 0;\n        function setTransitionConfig(frame) {\n            if(Array.isArray(transitionOpts)) {\n                if(configCounter >= transitionOpts.length) {\n                    frame.transitionOpts = transitionOpts[configCounter];\n                } else {\n                    frame.transitionOpts = transitionOpts[0];\n                }\n            } else {\n                frame.transitionOpts = transitionOpts;\n            }\n            configCounter++;\n            return frame;\n        }\n\n        // Disambiguate what's sort of frames have been received\n        var i, frame;\n        var frameList = [];\n        var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n        var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n        var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n        if(isSingleFrame) {\n            // In this case, a simple object has been passed to animate.\n            frameList.push({\n                type: 'object',\n                data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n            });\n        } else if(allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n            // In this case, null or undefined has been passed so that we want to\n            // animate *all* currently defined frames\n            for(i = 0; i < trans._frames.length; i++) {\n                frame = trans._frames[i];\n\n                if(!frame) continue;\n\n                if(allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n                    frameList.push({\n                        type: 'byname',\n                        name: String(frame.name),\n                        data: setTransitionConfig({name: frame.name})\n                    });\n                }\n            }\n        } else if(isFrameArray) {\n            for(i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n                var frameOrName = frameOrGroupNameOrFrameList[i];\n                if(['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n                    frameOrName = String(frameOrName);\n                    // In this case, there's an array and this frame is a string name:\n                    frameList.push({\n                        type: 'byname',\n                        name: frameOrName,\n                        data: setTransitionConfig({name: frameOrName})\n                    });\n                } else if(Lib.isPlainObject(frameOrName)) {\n                    frameList.push({\n                        type: 'object',\n                        data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n                    });\n                }\n            }\n        }\n\n        // Verify that all of these frames actually exist; return and reject if not:\n        for(i = 0; i < frameList.length; i++) {\n            frame = frameList[i];\n            if(frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n                Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n                reject();\n                return;\n            }\n        }\n\n        // If the mode is either next or immediate, then all currently queued frames must\n        // be dumped and the corresponding .animate promises rejected.\n        if(['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n            discardExistingFrames();\n        }\n\n        if(animationOpts.direction === 'reverse') {\n            frameList.reverse();\n        }\n\n        var currentFrame = gd._fullLayout._currentFrame;\n        if(currentFrame && animationOpts.fromcurrent) {\n            var idx = -1;\n            for(i = 0; i < frameList.length; i++) {\n                frame = frameList[i];\n                if(frame.type === 'byname' && frame.name === currentFrame) {\n                    idx = i;\n                    break;\n                }\n            }\n\n            if(idx > 0 && idx < frameList.length - 1) {\n                var filteredFrameList = [];\n                for(i = 0; i < frameList.length; i++) {\n                    frame = frameList[i];\n                    if(frameList[i].type !== 'byname' || i > idx) {\n                        filteredFrameList.push(frame);\n                    }\n                }\n                frameList = filteredFrameList;\n            }\n        }\n\n        if(frameList.length > 0) {\n            queueFrames(frameList);\n        } else {\n            // This is the case where there were simply no frames. It's a little strange\n            // since there's not much to do:\n            gd.emit('plotly_animated');\n            resolve();\n        }\n    });\n}\n\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\nfunction addFrames(gd, frameList, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(frameList === null || frameList === undefined) {\n        return Promise.resolve();\n    }\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before adding frames. For more details, see ' +\n            'https://plotly.com/javascript/animations/'\n        );\n    }\n\n    var i, frame, j, idx;\n    var _frames = gd._transitionData._frames;\n    var _frameHash = gd._transitionData._frameHash;\n\n\n    if(!Array.isArray(frameList)) {\n        throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n    }\n\n    // Create a sorted list of insertions since we run into lots of problems if these\n    // aren't in ascending order of index:\n    //\n    // Strictly for sorting. Make sure this is guaranteed to never collide with any\n    // already-exisisting indices:\n    var bigIndex = _frames.length + frameList.length * 2;\n\n    var insertions = [];\n    var _frameHashLocal = {};\n    for(i = frameList.length - 1; i >= 0; i--) {\n        if(!Lib.isPlainObject(frameList[i])) continue;\n\n        // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n        // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n        var lookupName = frameList[i].name;\n        var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n        var newName = frameList[i].name;\n        var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n        if(name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n            numericNameWarningCount++;\n\n            Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name +\n                '\" with a frame whose name of type \"number\" also equates to \"' +\n                name + '\". This is valid but may potentially lead to unexpected ' +\n                'behavior since all plotly.js frame names are stored internally ' +\n                'as strings.');\n\n            if(numericNameWarningCount === numericNameWarningCountLimit) {\n                Lib.warn('addFrames: This API call has yielded too many of these warnings. ' +\n                    'For the rest of this call, further warnings about numeric frame ' +\n                    'names will be suppressed.');\n            }\n        }\n\n        _frameHashLocal[lookupName] = {name: lookupName};\n\n        insertions.push({\n            frame: Plots.supplyFrameDefaults(frameList[i]),\n            index: (indices && indices[i] !== undefined && indices[i] !== null) ? indices[i] : bigIndex + i\n        });\n    }\n\n    // Sort this, taking note that undefined insertions end up at the end:\n    insertions.sort(function(a, b) {\n        if(a.index > b.index) return -1;\n        if(a.index < b.index) return 1;\n        return 0;\n    });\n\n    var ops = [];\n    var revops = [];\n    var frameCount = _frames.length;\n\n    for(i = insertions.length - 1; i >= 0; i--) {\n        frame = insertions[i].frame;\n\n        if(typeof frame.name === 'number') {\n            Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' +\n                'implicitly cast to strings');\n        }\n\n        if(!frame.name) {\n            // Repeatedly assign a default name, incrementing the counter each time until\n            // we get a name that's not in the hashed lookup table:\n            while(_frameHash[(frame.name = 'frame ' + gd._transitionData._counter++)]);\n        }\n\n        if(_frameHash[frame.name]) {\n            // If frame is present, overwrite its definition:\n            for(j = 0; j < _frames.length; j++) {\n                if((_frames[j] || {}).name === frame.name) break;\n            }\n            ops.push({type: 'replace', index: j, value: frame});\n            revops.unshift({type: 'replace', index: j, value: _frames[j]});\n        } else {\n            // Otherwise insert it at the end of the list:\n            idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n\n            ops.push({type: 'insert', index: idx, value: frame});\n            revops.unshift({type: 'delete', index: idx});\n            frameCount++;\n        }\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\nfunction deleteFrames(gd, frameList) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    var i, idx;\n    var _frames = gd._transitionData._frames;\n    var ops = [];\n    var revops = [];\n\n    if(!frameList) {\n        frameList = [];\n        for(i = 0; i < _frames.length; i++) {\n            frameList.push(i);\n        }\n    }\n\n    frameList = frameList.slice();\n    frameList.sort();\n\n    for(i = frameList.length - 1; i >= 0; i--) {\n        idx = frameList[i];\n        ops.push({type: 'delete', index: idx});\n        revops.unshift({type: 'insert', index: idx, value: _frames[idx]});\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\nfunction purge(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    var fullLayout = gd._fullLayout || {};\n    var fullData = gd._fullData || [];\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, fullData, fullLayout);\n\n    // purge properties\n    Plots.purge(gd);\n\n    // purge event emitter methods\n    Events.purge(gd);\n\n    // remove plot container\n    if(fullLayout._container) fullLayout._container.remove();\n\n    // in contrast to Plotly.Plots.purge which does NOT clear _context!\n    delete gd._context;\n\n    return gd;\n}\n\n// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd) {\n    var gd3 = d3.select(gd);\n    var fullLayout = gd._fullLayout;\n\n    // Plot container\n    fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n    fullLayout._container.enter().insert('div', ':first-child')\n        .classed('plot-container', true)\n        .classed('plotly', true);\n\n    // Make the svg container\n    fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n    fullLayout._paperdiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // Make the graph containers\n    // start fresh each time we get here, so we know the order comes out\n    // right, rather than enter/exit which can muck up the order\n    // TODO: sort out all the ordering so we don't have to\n    // explicitly delete anything\n    // FIXME: parcoords reuses this object, not the best pattern\n    fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container')\n        .data([{}]);\n\n    fullLayout._glcontainer.enter().append('div')\n        .classed('gl-container', true);\n\n    fullLayout._paperdiv.selectAll('.main-svg').remove();\n    fullLayout._paperdiv.select('.modebar-container').remove();\n\n    fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child')\n        .classed('main-svg', true);\n\n    fullLayout._toppaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n\n    fullLayout._hoverpaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    if(!fullLayout._uid) {\n        var otherUids = {};\n        d3.selectAll('defs').each(function() {\n            if(this.id) otherUids[this.id.split('-')[1]] = 1;\n        });\n        fullLayout._uid = Lib.randstr(otherUids);\n    }\n\n    fullLayout._paperdiv.selectAll('.main-svg')\n        .attr(xmlnsNamespaces.svgAttrs);\n\n    fullLayout._defs = fullLayout._paper.append('defs')\n        .attr('id', 'defs-' + fullLayout._uid);\n\n    fullLayout._clips = fullLayout._defs.append('g')\n        .classed('clips', true);\n\n    fullLayout._topdefs = fullLayout._toppaper.append('defs')\n        .attr('id', 'topdefs-' + fullLayout._uid);\n\n    fullLayout._topclips = fullLayout._topdefs.append('g')\n        .classed('clips', true);\n\n    fullLayout._bgLayer = fullLayout._paper.append('g')\n        .classed('bglayer', true);\n\n    fullLayout._draggers = fullLayout._paper.append('g')\n        .classed('draglayer', true);\n\n    // lower shape/image layer - note that this is behind\n    // all subplots data/grids but above the backgrounds\n    // except inset subplots, whose backgrounds are drawn\n    // inside their own group so that they appear above\n    // the data for the main subplot\n    // lower shapes and images which are fully referenced to\n    // a subplot still get drawn within the subplot's group\n    // so they will work correctly on insets\n    var layerBelow = fullLayout._paper.append('g')\n        .classed('layer-below', true);\n    fullLayout._imageLowerLayer = layerBelow.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeLowerLayer = layerBelow.append('g')\n        .classed('shapelayer', true);\n\n    // single cartesian layer for the whole plot\n    fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\n\n    // single polar layer for the whole plot\n    fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);\n\n    // single ternary layer for the whole plot\n    fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\n\n    // single geo layer for the whole plot\n    fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\n\n    // single funnelarea layer for the whole plot\n    fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true);\n\n    // single pie layer for the whole plot\n    fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\n\n    // single treemap layer for the whole plot\n    fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true);\n\n    // single sunburst layer for the whole plot\n    fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true);\n\n    // single indicator layer for the whole plot\n    fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true);\n\n    // fill in image server scrape-svg\n    fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\n\n    // lastly upper shapes, info (legend, annotations) and hover layers go on top\n    // these are in a different svg element normally, but get collapsed into a single\n    // svg when exporting (after inserting 3D)\n    // upper shapes/images are only those drawn above the whole plot, including subplots\n    var layerAbove = fullLayout._toppaper.append('g')\n        .classed('layer-above', true);\n    fullLayout._imageUpperLayer = layerAbove.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeUpperLayer = layerAbove.append('g')\n        .classed('shapelayer', true);\n\n    fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n    fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n    fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n    fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true);\n\n    // Make the modebar container\n    fullLayout._modebardiv\n        .classed('modebar-container', true)\n        .style('position', 'absolute')\n        .style('top', '0px')\n        .style('right', '0px');\n\n    gd.emit('plotly_framework');\n}\n\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\n\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\n\nexports.newPlot = newPlot;\nexports.plot = plot;\nexports.purge = purge;\n\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\n\nexports.setPlotConfig = setPlotConfig;\n\nexports.update = update;\n\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\n\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;\n"]},"metadata":{},"sourceType":"script"}