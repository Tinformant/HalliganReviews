{"ast":null,"code":"'use strict';\n\nvar monotoneTriangulate = require('./lib/monotone');\n\nvar makeIndex = require('./lib/triangulation');\n\nvar delaunayFlip = require('./lib/delaunay');\n\nvar filterTriangulation = require('./lib/filter');\n\nmodule.exports = cdt2d;\n\nfunction canonicalizeEdge(e) {\n  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])];\n}\n\nfunction compareEdge(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\nfunction canonicalizeEdges(edges) {\n  return edges.map(canonicalizeEdge).sort(compareEdge);\n}\n\nfunction getDefault(options, property, dflt) {\n  if (property in options) {\n    return options[property];\n  }\n\n  return dflt;\n}\n\nfunction cdt2d(points, edges, options) {\n  if (!Array.isArray(edges)) {\n    options = edges || {};\n    edges = [];\n  } else {\n    options = options || {};\n    edges = edges || [];\n  } //Parse out options\n\n\n  var delaunay = !!getDefault(options, 'delaunay', true);\n  var interior = !!getDefault(options, 'interior', true);\n  var exterior = !!getDefault(options, 'exterior', true);\n  var infinity = !!getDefault(options, 'infinity', false); //Handle trivial case\n\n  if (!interior && !exterior || points.length === 0) {\n    return [];\n  } //Construct initial triangulation\n\n\n  var cells = monotoneTriangulate(points, edges); //If delaunay refinement needed, then improve quality by edge flipping\n\n  if (delaunay || interior !== exterior || infinity) {\n    //Index all of the cells to support fast neighborhood queries\n    var triangulation = makeIndex(points.length, canonicalizeEdges(edges));\n\n    for (var i = 0; i < cells.length; ++i) {\n      var f = cells[i];\n      triangulation.addTriangle(f[0], f[1], f[2]);\n    } //Run edge flipping\n\n\n    if (delaunay) {\n      delaunayFlip(points, triangulation);\n    } //Filter points\n\n\n    if (!exterior) {\n      return filterTriangulation(triangulation, -1);\n    } else if (!interior) {\n      return filterTriangulation(triangulation, 1, infinity);\n    } else if (infinity) {\n      return filterTriangulation(triangulation, 0, infinity);\n    } else {\n      return triangulation.cells();\n    }\n  } else {\n    return cells;\n  }\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/cdt2d/cdt2d.js"],"names":["monotoneTriangulate","require","makeIndex","delaunayFlip","filterTriangulation","module","exports","cdt2d","canonicalizeEdge","e","Math","min","max","compareEdge","a","b","canonicalizeEdges","edges","map","sort","getDefault","options","property","dflt","points","Array","isArray","delaunay","interior","exterior","infinity","length","cells","triangulation","i","f","addTriangle"],"mappings":"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","sourcesContent":["'use strict'\n\nvar monotoneTriangulate = require('./lib/monotone')\nvar makeIndex = require('./lib/triangulation')\nvar delaunayFlip = require('./lib/delaunay')\nvar filterTriangulation = require('./lib/filter')\n\nmodule.exports = cdt2d\n\nfunction canonicalizeEdge(e) {\n  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]\n}\n\nfunction compareEdge(a, b) {\n  return a[0]-b[0] || a[1]-b[1]\n}\n\nfunction canonicalizeEdges(edges) {\n  return edges.map(canonicalizeEdge).sort(compareEdge)\n}\n\nfunction getDefault(options, property, dflt) {\n  if(property in options) {\n    return options[property]\n  }\n  return dflt\n}\n\nfunction cdt2d(points, edges, options) {\n\n  if(!Array.isArray(edges)) {\n    options = edges || {}\n    edges = []\n  } else {\n    options = options || {}\n    edges = edges || []\n  }\n\n  //Parse out options\n  var delaunay = !!getDefault(options, 'delaunay', true)\n  var interior = !!getDefault(options, 'interior', true)\n  var exterior = !!getDefault(options, 'exterior', true)\n  var infinity = !!getDefault(options, 'infinity', false)\n\n  //Handle trivial case\n  if((!interior && !exterior) || points.length === 0) {\n    return []\n  }\n\n  //Construct initial triangulation\n  var cells = monotoneTriangulate(points, edges)\n\n  //If delaunay refinement needed, then improve quality by edge flipping\n  if(delaunay || interior !== exterior || infinity) {\n\n    //Index all of the cells to support fast neighborhood queries\n    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))\n    for(var i=0; i<cells.length; ++i) {\n      var f = cells[i]\n      triangulation.addTriangle(f[0], f[1], f[2])\n    }\n\n    //Run edge flipping\n    if(delaunay) {\n      delaunayFlip(points, triangulation)\n    }\n\n    //Filter points\n    if(!exterior) {\n      return filterTriangulation(triangulation, -1)\n    } else if(!interior) {\n      return filterTriangulation(triangulation,  1, infinity)\n    } else if(infinity) {\n      return filterTriangulation(triangulation, 0, infinity)\n    } else {\n      return triangulation.cells()\n    }\n    \n  } else {\n    return cells\n  }\n}\n"]},"metadata":{},"sourceType":"script"}