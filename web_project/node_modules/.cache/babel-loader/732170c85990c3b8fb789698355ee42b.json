{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar makeColorScaleFn = require('../../components/colorscale').makeColorScaleFuncFromTrace;\n\nvar makePullColorFn = require('../pie/calc').makePullColorFn;\n\nvar generateExtendedColors = require('../pie/calc').generateExtendedColors;\n\nvar colorscaleCalc = require('../../components/colorscale').calc;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar sunburstExtendedColorWays = {};\nvar treemapExtendedColorWays = {};\n\nexports.calc = function (gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var ids = trace.ids;\n  var hasIds = Lib.isArrayOrTypedArray(ids);\n  var labels = trace.labels;\n  var parents = trace.parents;\n  var values = trace.values;\n  var hasValues = Lib.isArrayOrTypedArray(values);\n  var cd = [];\n  var parent2children = {};\n  var refs = {};\n\n  var addToLookup = function (parent, v) {\n    if (parent2children[parent]) parent2children[parent].push(v);else parent2children[parent] = [v];\n    refs[v] = 1;\n  }; // treat number `0` as valid\n\n\n  var isValidKey = function (k) {\n    return k || typeof k === 'number';\n  };\n\n  var isValidVal = function (i) {\n    return !hasValues || isNumeric(values[i]) && values[i] >= 0;\n  };\n\n  var len;\n  var isValid;\n  var getId;\n\n  if (hasIds) {\n    len = Math.min(ids.length, parents.length);\n\n    isValid = function (i) {\n      return isValidKey(ids[i]) && isValidVal(i);\n    };\n\n    getId = function (i) {\n      return String(ids[i]);\n    };\n  } else {\n    len = Math.min(labels.length, parents.length);\n\n    isValid = function (i) {\n      return isValidKey(labels[i]) && isValidVal(i);\n    }; // TODO We could allow some label / parent duplication\n    //\n    // From AJ:\n    //  It would work OK for one level\n    //  (multiple rows with the same name and different parents -\n    //  or even the same parent) but if that name is then used as a parent\n    //  which one is it?\n\n\n    getId = function (i) {\n      return String(labels[i]);\n    };\n  }\n\n  if (hasValues) len = Math.min(len, values.length);\n\n  for (var i = 0; i < len; i++) {\n    if (isValid(i)) {\n      var id = getId(i);\n      var pid = isValidKey(parents[i]) ? String(parents[i]) : '';\n      var cdi = {\n        i: i,\n        id: id,\n        pid: pid,\n        label: isValidKey(labels[i]) ? String(labels[i]) : ''\n      };\n      if (hasValues) cdi.v = +values[i];\n      cd.push(cdi);\n      addToLookup(pid, id);\n    }\n  }\n\n  if (!parent2children['']) {\n    var impliedRoots = [];\n    var k;\n\n    for (k in parent2children) {\n      if (!refs[k]) {\n        impliedRoots.push(k);\n      }\n    } // if an `id` has no ref in the `parents` array,\n    // take it as being the root node\n\n\n    if (impliedRoots.length === 1) {\n      k = impliedRoots[0];\n      cd.unshift({\n        hasImpliedRoot: true,\n        id: k,\n        pid: '',\n        label: k\n      });\n    } else {\n      return Lib.warn('Multiple implied roots, cannot build ' + trace.type + ' hierarchy.');\n    }\n  } else if (parent2children[''].length > 1) {\n    var dummyId = Lib.randstr(); // if multiple rows linked to the root node,\n    // add dummy \"root of roots\" node to make d3 build the hierarchy successfully\n\n    for (var j = 0; j < cd.length; j++) {\n      if (cd[j].pid === '') {\n        cd[j].pid = dummyId;\n      }\n    }\n\n    cd.unshift({\n      hasMultipleRoots: true,\n      id: dummyId,\n      pid: '',\n      label: ''\n    });\n  } // TODO might be better to replace stratify() with our own algorithm\n\n\n  var root;\n\n  try {\n    root = d3Hierarchy.stratify().id(function (d) {\n      return d.id;\n    }).parentId(function (d) {\n      return d.pid;\n    })(cd);\n  } catch (e) {\n    return Lib.warn('Failed to build ' + trace.type + ' hierarchy. Error: ' + e.message);\n  }\n\n  var hierarchy = d3Hierarchy.hierarchy(root);\n  var failed = false;\n\n  if (hasValues) {\n    switch (trace.branchvalues) {\n      case 'remainder':\n        hierarchy.sum(function (d) {\n          return d.data.v;\n        });\n        break;\n\n      case 'total':\n        hierarchy.each(function (d) {\n          var cdi = d.data.data;\n          var v = cdi.v;\n\n          if (d.children) {\n            var partialSum = d.children.reduce(function (a, c) {\n              return a + c.data.data.v;\n            }, 0); // N.B. we must fill in `value` for generated sectors\n            // with the partialSum to compute the correct partition\n\n            if (cdi.hasImpliedRoot || cdi.hasMultipleRoots) {\n              v = partialSum;\n            }\n\n            if (v < partialSum * ALMOST_EQUAL) {\n              failed = true;\n              return Lib.warn(['Total value for node', d.data.data.id, 'is smaller than the sum of its children.', '\\nparent value =', v, '\\nchildren sum =', partialSum].join(' '));\n            }\n          }\n\n          d.value = v;\n        });\n        break;\n    }\n  } else {\n    countDescendants(hierarchy, trace, {\n      branches: trace.count.indexOf('branches') !== -1,\n      leaves: trace.count.indexOf('leaves') !== -1\n    });\n  }\n\n  if (failed) return; // TODO add way to sort by height also?\n\n  hierarchy.sort(function (a, b) {\n    return b.value - a.value;\n  });\n  var pullColor;\n  var scaleColor;\n  var colors = trace.marker.colors || [];\n  var hasColors = !!colors.length;\n\n  if (trace._hasColorscale) {\n    if (!hasColors) {\n      colors = hasValues ? trace.values : trace._values;\n    }\n\n    colorscaleCalc(gd, trace, {\n      vals: colors,\n      containerStr: 'marker',\n      cLetter: 'c'\n    });\n    scaleColor = makeColorScaleFn(trace.marker);\n  } else {\n    pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n  } // TODO keep track of 'root-children' (i.e. branch) for hover info etc.\n\n\n  hierarchy.each(function (d) {\n    var cdi = d.data.data; // N.B. this mutates items in `cd`\n\n    cdi.color = trace._hasColorscale ? scaleColor(colors[cdi.i]) : pullColor(colors[cdi.i], cdi.id);\n  });\n  cd[0].hierarchy = hierarchy;\n  return cd;\n};\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\n\n\nexports._runCrossTraceCalc = function (desiredType, gd) {\n  var fullLayout = gd._fullLayout;\n  var calcdata = gd.calcdata;\n  var colorWay = fullLayout[desiredType + 'colorway'];\n  var colorMap = fullLayout['_' + desiredType + 'colormap'];\n\n  if (fullLayout['extend' + desiredType + 'colors']) {\n    colorWay = generateExtendedColors(colorWay, desiredType === 'treemap' ? treemapExtendedColorWays : sunburstExtendedColorWays);\n  }\n\n  var dfltColorCount = 0;\n\n  function pickColor(d) {\n    var cdi = d.data.data;\n    var id = cdi.id;\n\n    if (cdi.color === false) {\n      if (colorMap[id]) {\n        // have we seen this label and assigned a color to it in a previous trace?\n        cdi.color = colorMap[id];\n      } else if (d.parent) {\n        if (d.parent.parent) {\n          // from third-level on, inherit from parent\n          cdi.color = d.parent.data.data.color;\n        } else {\n          // pick new color for second level\n          colorMap[id] = cdi.color = colorWay[dfltColorCount % colorWay.length];\n          dfltColorCount++;\n        }\n      } else {\n        // root gets no coloring by default\n        cdi.color = 'rgba(0,0,0,0)';\n      }\n    }\n  }\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n\n    if (cd0.trace.type === desiredType && cd0.hierarchy) {\n      cd0.hierarchy.each(pickColor);\n    }\n  }\n};\n\nexports.crossTraceCalc = function (gd) {\n  return exports._runCrossTraceCalc('sunburst', gd);\n};\n\nfunction countDescendants(node, trace, opts) {\n  var nChild = 0;\n  var children = node.children;\n\n  if (children) {\n    var len = children.length;\n\n    for (var i = 0; i < len; i++) {\n      nChild += countDescendants(children[i], trace, opts);\n    }\n\n    if (opts.branches) nChild++; // count this branch\n  } else {\n    if (opts.leaves) nChild++; // count this leaf\n  } // save to the node\n\n\n  node.value = node.data.data.value = nChild; // save to the trace\n\n  if (!trace._values) trace._values = [];\n  trace._values[node.data.data.i] = nChild;\n  return nChild;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/sunburst/calc.js"],"names":["d3Hierarchy","require","isNumeric","Lib","makeColorScaleFn","makeColorScaleFuncFromTrace","makePullColorFn","generateExtendedColors","colorscaleCalc","calc","ALMOST_EQUAL","sunburstExtendedColorWays","treemapExtendedColorWays","exports","gd","trace","fullLayout","_fullLayout","ids","hasIds","isArrayOrTypedArray","labels","parents","values","hasValues","cd","parent2children","refs","addToLookup","parent","v","push","isValidKey","k","isValidVal","i","len","isValid","getId","Math","min","length","String","id","pid","cdi","label","impliedRoots","unshift","hasImpliedRoot","warn","type","dummyId","randstr","j","hasMultipleRoots","root","stratify","d","parentId","e","message","hierarchy","failed","branchvalues","sum","data","each","children","partialSum","reduce","a","c","join","value","countDescendants","branches","count","indexOf","leaves","sort","b","pullColor","scaleColor","colors","marker","hasColors","_hasColorscale","_values","vals","containerStr","cLetter","color","_runCrossTraceCalc","desiredType","calcdata","colorWay","colorMap","dfltColorCount","pickColor","cd0","crossTraceCalc","node","opts","nChild"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3Hierarchy = require('d3-hierarchy');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar makeColorScaleFn = require('../../components/colorscale').makeColorScaleFuncFromTrace;\nvar makePullColorFn = require('../pie/calc').makePullColorFn;\nvar generateExtendedColors = require('../pie/calc').generateExtendedColors;\nvar colorscaleCalc = require('../../components/colorscale').calc;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar sunburstExtendedColorWays = {};\nvar treemapExtendedColorWays = {};\n\nexports.calc = function(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var ids = trace.ids;\n    var hasIds = Lib.isArrayOrTypedArray(ids);\n    var labels = trace.labels;\n    var parents = trace.parents;\n    var values = trace.values;\n    var hasValues = Lib.isArrayOrTypedArray(values);\n    var cd = [];\n\n    var parent2children = {};\n    var refs = {};\n    var addToLookup = function(parent, v) {\n        if(parent2children[parent]) parent2children[parent].push(v);\n        else parent2children[parent] = [v];\n        refs[v] = 1;\n    };\n\n    // treat number `0` as valid\n    var isValidKey = function(k) {\n        return k || typeof k === 'number';\n    };\n\n    var isValidVal = function(i) {\n        return !hasValues || (isNumeric(values[i]) && values[i] >= 0);\n    };\n\n    var len;\n    var isValid;\n    var getId;\n\n    if(hasIds) {\n        len = Math.min(ids.length, parents.length);\n        isValid = function(i) { return isValidKey(ids[i]) && isValidVal(i); };\n        getId = function(i) { return String(ids[i]); };\n    } else {\n        len = Math.min(labels.length, parents.length);\n        isValid = function(i) { return isValidKey(labels[i]) && isValidVal(i); };\n        // TODO We could allow some label / parent duplication\n        //\n        // From AJ:\n        //  It would work OK for one level\n        //  (multiple rows with the same name and different parents -\n        //  or even the same parent) but if that name is then used as a parent\n        //  which one is it?\n        getId = function(i) { return String(labels[i]); };\n    }\n\n    if(hasValues) len = Math.min(len, values.length);\n\n    for(var i = 0; i < len; i++) {\n        if(isValid(i)) {\n            var id = getId(i);\n            var pid = isValidKey(parents[i]) ? String(parents[i]) : '';\n\n            var cdi = {\n                i: i,\n                id: id,\n                pid: pid,\n                label: isValidKey(labels[i]) ? String(labels[i]) : ''\n            };\n\n            if(hasValues) cdi.v = +values[i];\n            cd.push(cdi);\n            addToLookup(pid, id);\n        }\n    }\n\n    if(!parent2children['']) {\n        var impliedRoots = [];\n        var k;\n        for(k in parent2children) {\n            if(!refs[k]) {\n                impliedRoots.push(k);\n            }\n        }\n\n        // if an `id` has no ref in the `parents` array,\n        // take it as being the root node\n\n        if(impliedRoots.length === 1) {\n            k = impliedRoots[0];\n            cd.unshift({\n                hasImpliedRoot: true,\n                id: k,\n                pid: '',\n                label: k\n            });\n        } else {\n            return Lib.warn('Multiple implied roots, cannot build ' + trace.type + ' hierarchy.');\n        }\n    } else if(parent2children[''].length > 1) {\n        var dummyId = Lib.randstr();\n\n        // if multiple rows linked to the root node,\n        // add dummy \"root of roots\" node to make d3 build the hierarchy successfully\n\n        for(var j = 0; j < cd.length; j++) {\n            if(cd[j].pid === '') {\n                cd[j].pid = dummyId;\n            }\n        }\n\n        cd.unshift({\n            hasMultipleRoots: true,\n            id: dummyId,\n            pid: '',\n            label: ''\n        });\n    }\n\n    // TODO might be better to replace stratify() with our own algorithm\n    var root;\n    try {\n        root = d3Hierarchy.stratify()\n            .id(function(d) { return d.id; })\n            .parentId(function(d) { return d.pid; })(cd);\n    } catch(e) {\n        return Lib.warn('Failed to build ' + trace.type + ' hierarchy. Error: ' + e.message);\n    }\n\n    var hierarchy = d3Hierarchy.hierarchy(root);\n    var failed = false;\n\n    if(hasValues) {\n        switch(trace.branchvalues) {\n            case 'remainder':\n                hierarchy.sum(function(d) { return d.data.v; });\n                break;\n            case 'total':\n                hierarchy.each(function(d) {\n                    var cdi = d.data.data;\n                    var v = cdi.v;\n\n                    if(d.children) {\n                        var partialSum = d.children.reduce(function(a, c) {\n                            return a + c.data.data.v;\n                        }, 0);\n\n                        // N.B. we must fill in `value` for generated sectors\n                        // with the partialSum to compute the correct partition\n                        if(cdi.hasImpliedRoot || cdi.hasMultipleRoots) {\n                            v = partialSum;\n                        }\n\n                        if(v < partialSum * ALMOST_EQUAL) {\n                            failed = true;\n                            return Lib.warn([\n                                'Total value for node', d.data.data.id,\n                                'is smaller than the sum of its children.',\n                                '\\nparent value =', v,\n                                '\\nchildren sum =', partialSum\n                            ].join(' '));\n                        }\n                    }\n\n                    d.value = v;\n                });\n                break;\n        }\n    } else {\n        countDescendants(hierarchy, trace, {\n            branches: trace.count.indexOf('branches') !== -1,\n            leaves: trace.count.indexOf('leaves') !== -1\n        });\n    }\n\n    if(failed) return;\n\n    // TODO add way to sort by height also?\n    hierarchy.sort(function(a, b) { return b.value - a.value; });\n\n    var pullColor;\n    var scaleColor;\n    var colors = trace.marker.colors || [];\n    var hasColors = !!colors.length;\n\n    if(trace._hasColorscale) {\n        if(!hasColors) {\n            colors = hasValues ? trace.values : trace._values;\n        }\n\n        colorscaleCalc(gd, trace, {\n            vals: colors,\n            containerStr: 'marker',\n            cLetter: 'c'\n        });\n\n        scaleColor = makeColorScaleFn(trace.marker);\n    } else {\n        pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n    }\n\n    // TODO keep track of 'root-children' (i.e. branch) for hover info etc.\n\n    hierarchy.each(function(d) {\n        var cdi = d.data.data;\n        // N.B. this mutates items in `cd`\n        cdi.color = trace._hasColorscale ?\n            scaleColor(colors[cdi.i]) :\n            pullColor(colors[cdi.i], cdi.id);\n    });\n\n    cd[0].hierarchy = hierarchy;\n\n    return cd;\n};\n\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\nexports._runCrossTraceCalc = function(desiredType, gd) {\n    var fullLayout = gd._fullLayout;\n    var calcdata = gd.calcdata;\n    var colorWay = fullLayout[desiredType + 'colorway'];\n    var colorMap = fullLayout['_' + desiredType + 'colormap'];\n\n    if(fullLayout['extend' + desiredType + 'colors']) {\n        colorWay = generateExtendedColors(colorWay,\n            desiredType === 'treemap' ? treemapExtendedColorWays : sunburstExtendedColorWays\n        );\n    }\n    var dfltColorCount = 0;\n\n    function pickColor(d) {\n        var cdi = d.data.data;\n        var id = cdi.id;\n\n        if(cdi.color === false) {\n            if(colorMap[id]) {\n                // have we seen this label and assigned a color to it in a previous trace?\n                cdi.color = colorMap[id];\n            } else if(d.parent) {\n                if(d.parent.parent) {\n                    // from third-level on, inherit from parent\n                    cdi.color = d.parent.data.data.color;\n                } else {\n                    // pick new color for second level\n                    colorMap[id] = cdi.color = colorWay[dfltColorCount % colorWay.length];\n                    dfltColorCount++;\n                }\n            } else {\n                // root gets no coloring by default\n                cdi.color = 'rgba(0,0,0,0)';\n            }\n        }\n    }\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var cd0 = cd[0];\n        if(cd0.trace.type === desiredType && cd0.hierarchy) {\n            cd0.hierarchy.each(pickColor);\n        }\n    }\n};\n\nexports.crossTraceCalc = function(gd) {\n    return exports._runCrossTraceCalc('sunburst', gd);\n};\n\nfunction countDescendants(node, trace, opts) {\n    var nChild = 0;\n\n    var children = node.children;\n    if(children) {\n        var len = children.length;\n\n        for(var i = 0; i < len; i++) {\n            nChild += countDescendants(children[i], trace, opts);\n        }\n\n        if(opts.branches) nChild++; // count this branch\n    } else {\n        if(opts.leaves) nChild++; // count this leaf\n    }\n\n    // save to the node\n    node.value = node.data.data.value = nChild;\n\n    // save to the trace\n    if(!trace._values) trace._values = [];\n    trace._values[node.data.data.i] = nChild;\n\n    return nChild;\n}\n"]},"metadata":{},"sourceType":"script"}