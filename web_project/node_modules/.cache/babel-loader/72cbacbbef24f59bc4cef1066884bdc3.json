{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar setConvert = require('../../plots/cartesian/set_convert');\n\nvar heatmapPlot = require('../heatmap/plot');\n\nvar makeCrossings = require('./make_crossings');\n\nvar findAllPaths = require('./find_all_paths');\n\nvar emptyPathinfo = require('./empty_pathinfo');\n\nvar convertToConstraints = require('./convert_to_constraints');\n\nvar closeBoundaries = require('./close_boundaries');\n\nvar constants = require('./constants');\n\nvar costConstants = constants.LABELOPTIMIZER;\n\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(contourLayer, cdcontours, 'contour').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var x = cd0.x;\n    var y = cd0.y;\n    var contours = trace.contours;\n    var pathinfo = emptyPathinfo(contours, plotinfo, cd0); // use a heatmap to fill - draw it behind the lines\n\n    var heatmapColoringLayer = Lib.ensureSingle(plotGroup, 'g', 'heatmapcoloring');\n    var cdheatmaps = [];\n\n    if (contours.coloring === 'heatmap') {\n      cdheatmaps = [cd];\n    }\n\n    heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n    makeCrossings(pathinfo);\n    findAllPaths(pathinfo);\n    var leftedge = xa.c2p(x[0], true);\n    var rightedge = xa.c2p(x[x.length - 1], true);\n    var bottomedge = ya.c2p(y[0], true);\n    var topedge = ya.c2p(y[y.length - 1], true);\n    var perimeter = [[leftedge, topedge], [rightedge, topedge], [rightedge, bottomedge], [leftedge, bottomedge]];\n    var fillPathinfo = pathinfo;\n\n    if (contours.type === 'constraint') {\n      // N.B. this also mutates pathinfo\n      fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n    } // draw everything\n\n\n    makeBackground(plotGroup, perimeter, contours);\n    makeFills(plotGroup, fillPathinfo, perimeter, contours);\n    makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours);\n    clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);\n  });\n};\n\nfunction makeBackground(plotgroup, perimeter, contours) {\n  var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n  var bgfill = bggroup.selectAll('path').data(contours.coloring === 'fill' ? [0] : []);\n  bgfill.enter().append('path');\n  bgfill.exit().remove();\n  bgfill.attr('d', 'M' + perimeter.join('L') + 'Z').style('stroke', 'none');\n}\n\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n  var hasFills = contours.coloring === 'fill' || contours.type === 'constraint' && contours._operation !== '=';\n  var boundaryPath = 'M' + perimeter.join('L') + 'Z'; // fills prefixBoundary in pathinfo items\n\n  if (hasFills) {\n    closeBoundaries(pathinfo, contours);\n  }\n\n  var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n  var fillitems = fillgroup.selectAll('path').data(hasFills ? pathinfo : []);\n  fillitems.enter().append('path');\n  fillitems.exit().remove();\n  fillitems.each(function (pi) {\n    // join all paths for this level together into a single path\n    // first follow clockwise around the perimeter to close any open paths\n    // if the whole perimeter is above this level, start with a path\n    // enclosing the whole thing. With all that, the parity should mean\n    // that we always fill everything above the contour, nothing below\n    var fullpath = (pi.prefixBoundary ? boundaryPath : '') + joinAllPaths(pi, perimeter);\n\n    if (!fullpath) {\n      d3.select(this).remove();\n    } else {\n      d3.select(this).attr('d', fullpath).style('stroke', 'none');\n    }\n  });\n}\n\nfunction joinAllPaths(pi, perimeter) {\n  var fullpath = '';\n  var i = 0;\n  var startsleft = pi.edgepaths.map(function (v, i) {\n    return i;\n  });\n  var newloop = true;\n  var endpt;\n  var newendpt;\n  var cnt;\n  var nexti;\n  var possiblei;\n  var addpath;\n\n  function istop(pt) {\n    return Math.abs(pt[1] - perimeter[0][1]) < 0.01;\n  }\n\n  function isbottom(pt) {\n    return Math.abs(pt[1] - perimeter[2][1]) < 0.01;\n  }\n\n  function isleft(pt) {\n    return Math.abs(pt[0] - perimeter[0][0]) < 0.01;\n  }\n\n  function isright(pt) {\n    return Math.abs(pt[0] - perimeter[2][0]) < 0.01;\n  }\n\n  while (startsleft.length) {\n    addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n    fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n    startsleft.splice(startsleft.indexOf(i), 1);\n    endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n    nexti = -1; // now loop through sides, moving our endpoint until we find a new start\n\n    for (cnt = 0; cnt < 4; cnt++) {\n      // just to prevent infinite loops\n      if (!endpt) {\n        Lib.log('Missing end?', i, pi);\n        break;\n      }\n\n      if (istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n      else if (isleft(endpt)) newendpt = perimeter[0]; // left top\n        else if (isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n          else if (isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n      for (possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n        var ptNew = pi.edgepaths[possiblei][0]; // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n\n        if (Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n          if (Math.abs(endpt[0] - ptNew[0]) < 0.01 && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else if (Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n          if (Math.abs(endpt[1] - ptNew[1]) < 0.01 && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else {\n          Lib.log('endpt to newendpt is not vert. or horz.', endpt, newendpt, ptNew);\n        }\n      }\n\n      endpt = newendpt;\n      if (nexti >= 0) break;\n      fullpath += 'L' + newendpt;\n    }\n\n    if (nexti === pi.edgepaths.length) {\n      Lib.log('unclosed perimeter path');\n      break;\n    }\n\n    i = nexti; // if we closed back on a loop we already included,\n    // close it and start a new loop\n\n    newloop = startsleft.indexOf(i) === -1;\n\n    if (newloop) {\n      i = startsleft[0];\n      fullpath += 'Z';\n    }\n  } // finally add the interior paths\n\n\n  for (i = 0; i < pi.paths.length; i++) {\n    fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n  }\n\n  return fullpath;\n}\n\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours) {\n  var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n  var showLines = contours.showlines !== false;\n  var showLabels = contours.showlabels;\n  var clipLinesForLabels = showLines && showLabels; // Even if we're not going to show lines, we need to create them\n  // if we're showing labels, because the fill paths include the perimeter\n  // so can't be used to position the labels correctly.\n  // In this case we'll remove the lines after making the labels.\n\n  var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo);\n  var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);\n  var labelGroup = plotgroup.selectAll('g.contourlabels').data(showLabels ? [0] : []);\n  labelGroup.exit().remove();\n  labelGroup.enter().append('g').classed('contourlabels', true);\n\n  if (showLabels) {\n    var labelClipPathData = [];\n    var labelData = []; // invalidate the getTextLocation cache in case paths changed\n\n    Lib.clearLocationCache();\n    var contourFormat = exports.labelFormatter(gd, cd0);\n    var dummyText = Drawing.tester.append('text').attr('data-notex', 1).call(Drawing.font, contours.labelfont);\n    var xa = pathinfo[0].xaxis;\n    var ya = pathinfo[0].yaxis;\n    var xLen = xa._length;\n    var yLen = ya._length;\n    var xRng = xa.range;\n    var yRng = ya.range;\n    var xMin = Lib.aggNums(Math.min, null, cd0.x);\n    var xMax = Lib.aggNums(Math.max, null, cd0.x);\n    var yMin = Lib.aggNums(Math.min, null, cd0.y);\n    var yMax = Lib.aggNums(Math.max, null, cd0.y);\n    var x0 = Math.max(xa.c2p(xMin, true), 0);\n    var x1 = Math.min(xa.c2p(xMax, true), xLen);\n    var y0 = Math.max(ya.c2p(yMax, true), 0);\n    var y1 = Math.min(ya.c2p(yMin, true), yLen); // visible bounds of the contour trace (and the midpoints, to\n    // help with cost calculations)\n\n    var bounds = {};\n\n    if (xRng[0] < xRng[1]) {\n      bounds.left = x0;\n      bounds.right = x1;\n    } else {\n      bounds.left = x1;\n      bounds.right = x0;\n    }\n\n    if (yRng[0] < yRng[1]) {\n      bounds.top = y0;\n      bounds.bottom = y1;\n    } else {\n      bounds.top = y1;\n      bounds.bottom = y0;\n    }\n\n    bounds.middle = (bounds.top + bounds.bottom) / 2;\n    bounds.center = (bounds.left + bounds.right) / 2;\n    labelClipPathData.push([[bounds.left, bounds.top], [bounds.right, bounds.top], [bounds.right, bounds.bottom], [bounds.left, bounds.bottom]]);\n    var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen); // the path length to use to scale the number of labels to draw:\n\n    var normLength = constants.LABELDISTANCE * plotDiagonal / Math.max(1, pathinfo.length / constants.LABELINCREASE);\n    linegroup.each(function (d) {\n      var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n      d3.select(this).selectAll('path').each(function () {\n        var path = this;\n        var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n        if (!pathBounds) return;\n        if (pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n        var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength), constants.LABELMAX);\n\n        for (var i = 0; i < maxLabels; i++) {\n          var loc = exports.findBestTextLocation(path, pathBounds, textOpts, labelData, bounds);\n          if (!loc) break;\n          exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n        }\n      });\n    });\n    dummyText.remove();\n    exports.drawLabels(labelGroup, labelData, gd, lineClip, clipLinesForLabels ? labelClipPathData : null);\n  }\n\n  if (showLabels && !showLines) linegroup.remove();\n}\n\nexports.createLines = function (lineContainer, makeLines, pathinfo) {\n  var smoothing = pathinfo[0].smoothing;\n  var linegroup = lineContainer.selectAll('g.contourlevel').data(makeLines ? pathinfo : []);\n  linegroup.exit().remove();\n  linegroup.enter().append('g').classed('contourlevel', true);\n\n  if (makeLines) {\n    // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n    // edgepaths / paths are used by contour since it's in x/y from the start\n    var opencontourlines = linegroup.selectAll('path.openline').data(function (d) {\n      return d.pedgepaths || d.edgepaths;\n    });\n    opencontourlines.exit().remove();\n    opencontourlines.enter().append('path').classed('openline', true);\n    opencontourlines.attr('d', function (d) {\n      return Drawing.smoothopen(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', 'non-scaling-stroke');\n    var closedcontourlines = linegroup.selectAll('path.closedline').data(function (d) {\n      return d.ppaths || d.paths;\n    });\n    closedcontourlines.exit().remove();\n    closedcontourlines.enter().append('path').classed('closedline', true);\n    closedcontourlines.attr('d', function (d) {\n      return Drawing.smoothclosed(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', 'non-scaling-stroke');\n  }\n\n  return linegroup;\n};\n\nexports.createLineClip = function (lineContainer, clipLinesForLabels, gd, uid) {\n  var clips = gd._fullLayout._clips;\n  var clipId = clipLinesForLabels ? 'clipline' + uid : null;\n  var lineClip = clips.selectAll('#' + clipId).data(clipLinesForLabels ? [0] : []);\n  lineClip.exit().remove();\n  lineClip.enter().append('clipPath').classed('contourlineclip', true).attr('id', clipId);\n  Drawing.setClipUrl(lineContainer, clipId, gd);\n  return lineClip;\n};\n\nexports.labelFormatter = function (gd, cd0) {\n  var fullLayout = gd._fullLayout;\n  var trace = cd0.trace;\n  var contours = trace.contours;\n  var formatAxis = {\n    type: 'linear',\n    _id: 'ycontour',\n    showexponent: 'all',\n    exponentformat: 'B'\n  };\n\n  if (contours.labelformat) {\n    formatAxis.tickformat = contours.labelformat;\n    setConvert(formatAxis, fullLayout);\n  } else {\n    var cOpts = Colorscale.extractOpts(trace);\n\n    if (cOpts && cOpts.colorbar && cOpts.colorbar._axis) {\n      formatAxis = cOpts.colorbar._axis;\n    } else {\n      if (contours.type === 'constraint') {\n        var value = contours.value;\n\n        if (Array.isArray(value)) {\n          formatAxis.range = [value[0], value[value.length - 1]];\n        } else formatAxis.range = [value, value];\n      } else {\n        formatAxis.range = [contours.start, contours.end];\n        formatAxis.nticks = (contours.end - contours.start) / contours.size;\n      }\n\n      if (formatAxis.range[0] === formatAxis.range[1]) {\n        formatAxis.range[1] += formatAxis.range[0] || 1;\n      }\n\n      if (!formatAxis.nticks) formatAxis.nticks = 1000;\n      setConvert(formatAxis, fullLayout);\n      Axes.prepTicks(formatAxis);\n      formatAxis._tmin = null;\n      formatAxis._tmax = null;\n    }\n  }\n\n  return function (v) {\n    return Axes.tickText(formatAxis, v).text;\n  };\n};\n\nexports.calcTextOpts = function (level, contourFormat, dummyText, gd) {\n  var text = contourFormat(level);\n  dummyText.text(text).call(svgTextUtils.convertToTspans, gd);\n  var el = dummyText.node();\n  var bBox = Drawing.bBox(el, true);\n  return {\n    text: text,\n    width: bBox.width,\n    height: bBox.height,\n    fontSize: +el.style['font-size'].replace('px', ''),\n    level: level,\n    dy: (bBox.top + bBox.bottom) / 2\n  };\n};\n\nexports.findBestTextLocation = function (path, pathBounds, textOpts, labelData, plotBounds) {\n  var textWidth = textOpts.width;\n  var p0, dp, pMax, pMin, loc;\n\n  if (pathBounds.isClosed) {\n    dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n    p0 = pathBounds.min + dp / 2;\n    pMax = pathBounds.max;\n  } else {\n    dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n    p0 = pathBounds.min + dp + textWidth / 2;\n    pMax = pathBounds.max - (dp + textWidth) / 2;\n  }\n\n  var cost = Infinity;\n\n  for (var j = 0; j < costConstants.ITERATIONS; j++) {\n    for (var p = p0; p < pMax; p += dp) {\n      var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n      var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n\n      if (newCost < cost) {\n        cost = newCost;\n        loc = newLocation;\n        pMin = p;\n      }\n    }\n\n    if (cost > costConstants.MAXCOST * 2) break; // subsequent iterations just look half steps away from the\n    // best we found in the previous iteration\n\n    if (j) dp /= 2;\n    p0 = pMin - dp / 2;\n    pMax = p0 + dp * 1.5;\n  }\n\n  if (cost <= costConstants.MAXCOST) return loc;\n};\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\n\n\nfunction locationCost(loc, textOpts, labelData, bounds) {\n  var halfWidth = textOpts.width / 2;\n  var halfHeight = textOpts.height / 2;\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var dx = Math.cos(theta) * halfWidth;\n  var dy = Math.sin(theta) * halfWidth; // cost for being near an edge\n\n  var normX = (x > bounds.center ? bounds.right - x : x - bounds.left) / (dx + Math.abs(Math.sin(theta) * halfHeight));\n  var normY = (y > bounds.middle ? bounds.bottom - y : y - bounds.top) / (Math.abs(dy) + Math.cos(theta) * halfHeight);\n  if (normX < 1 || normY < 1) return Infinity;\n  var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1)); // cost for not being horizontal\n\n  cost += costConstants.ANGLECOST * theta * theta; // cost for being close to other labels\n\n  var x1 = x - dx;\n  var y1 = y - dy;\n  var x2 = x + dx;\n  var y2 = y + dy;\n\n  for (var i = 0; i < labelData.length; i++) {\n    var labeli = labelData[i];\n    var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n    var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n    var dist = Lib.segmentDistance(x1, y1, x2, y2, labeli.x - dxd, labeli.y - dyd, labeli.x + dxd, labeli.y + dyd) * 2 / (textOpts.height + labeli.height);\n    var sameLevel = labeli.level === textOpts.level;\n    var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n    if (dist <= distOffset) return Infinity;\n    var distFactor = costConstants.NEIGHBORCOST * (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n    cost += distFactor / (dist - distOffset);\n  }\n\n  return cost;\n}\n\nexports.addLabelData = function (loc, textOpts, labelData, labelClipPathData) {\n  var fontSize = textOpts.fontSize;\n  var w = textOpts.width + fontSize / 3;\n  var h = Math.max(0, textOpts.height - fontSize / 3);\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var sin = Math.sin(theta);\n  var cos = Math.cos(theta);\n\n  var rotateXY = function (dx, dy) {\n    return [x + dx * cos - dy * sin, y + dx * sin + dy * cos];\n  };\n\n  var bBoxPts = [rotateXY(-w / 2, -h / 2), rotateXY(-w / 2, h / 2), rotateXY(w / 2, h / 2), rotateXY(w / 2, -h / 2)];\n  labelData.push({\n    text: textOpts.text,\n    x: x,\n    y: y,\n    dy: textOpts.dy,\n    theta: theta,\n    level: textOpts.level,\n    width: w,\n    height: h\n  });\n  labelClipPathData.push(bBoxPts);\n};\n\nexports.drawLabels = function (labelGroup, labelData, gd, lineClip, labelClipPathData) {\n  var labels = labelGroup.selectAll('text').data(labelData, function (d) {\n    return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n  });\n  labels.exit().remove();\n  labels.enter().append('text').attr({\n    'data-notex': 1,\n    'text-anchor': 'middle'\n  }).each(function (d) {\n    var x = d.x + Math.sin(d.theta) * d.dy;\n    var y = d.y - Math.cos(d.theta) * d.dy;\n    d3.select(this).text(d.text).attr({\n      x: x,\n      y: y,\n      transform: 'rotate(' + 180 * d.theta / Math.PI + ' ' + x + ' ' + y + ')'\n    }).call(svgTextUtils.convertToTspans, gd);\n  });\n\n  if (labelClipPathData) {\n    var clipPath = '';\n\n    for (var i = 0; i < labelClipPathData.length; i++) {\n      clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n    }\n\n    var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n    lineClipPath.attr('d', clipPath);\n  }\n};\n\nfunction clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {\n  var trace = cd0.trace;\n  var clips = gd._fullLayout._clips;\n  var clipId = 'clip' + trace.uid;\n  var clipPath = clips.selectAll('#' + clipId).data(trace.connectgaps ? [] : [0]);\n  clipPath.enter().append('clipPath').classed('contourclip', true).attr('id', clipId);\n  clipPath.exit().remove();\n\n  if (trace.connectgaps === false) {\n    var clipPathInfo = {\n      // fraction of the way from missing to present point\n      // to draw the boundary.\n      // if you make this 1 (or 1-epsilon) then a point in\n      // a sea of missing data will disappear entirely.\n      level: 0.9,\n      crossings: {},\n      starts: [],\n      edgepaths: [],\n      paths: [],\n      xaxis: plotinfo.xaxis,\n      yaxis: plotinfo.yaxis,\n      x: cd0.x,\n      y: cd0.y,\n      // 0 = no data, 1 = data\n      z: makeClipMask(cd0),\n      smoothing: 0\n    };\n    makeCrossings([clipPathInfo]);\n    findAllPaths([clipPathInfo]);\n    closeBoundaries([clipPathInfo], {\n      type: 'levels'\n    });\n    var path = Lib.ensureSingle(clipPath, 'path', '');\n    path.attr('d', (clipPathInfo.prefixBoundary ? 'M' + perimeter.join('L') + 'Z' : '') + joinAllPaths(clipPathInfo, perimeter));\n  } else clipId = null;\n\n  Drawing.setClipUrl(plotGroup, clipId, gd);\n}\n\nfunction makeClipMask(cd0) {\n  var empties = cd0.trace._emptypoints;\n  var z = [];\n  var m = cd0.z.length;\n  var n = cd0.z[0].length;\n  var i;\n  var row = [];\n  var emptyPoint;\n\n  for (i = 0; i < n; i++) row.push(1);\n\n  for (i = 0; i < m; i++) z.push(row.slice());\n\n  for (i = 0; i < empties.length; i++) {\n    emptyPoint = empties[i];\n    z[emptyPoint[0]][emptyPoint[1]] = 0;\n  } // save this mask to determine whether to show this data in hover\n\n\n  cd0.zmask = z;\n  return z;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/contour/plot.js"],"names":["d3","require","Lib","Drawing","Colorscale","svgTextUtils","Axes","setConvert","heatmapPlot","makeCrossings","findAllPaths","emptyPathinfo","convertToConstraints","closeBoundaries","constants","costConstants","LABELOPTIMIZER","exports","plot","gd","plotinfo","cdcontours","contourLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","plotGroup","select","cd0","trace","x","y","contours","pathinfo","heatmapColoringLayer","ensureSingle","cdheatmaps","coloring","leftedge","c2p","rightedge","length","bottomedge","topedge","perimeter","fillPathinfo","type","_operation","makeBackground","makeFills","makeLinesAndLabels","clipGaps","plotgroup","bggroup","bgfill","selectAll","data","enter","append","exit","remove","attr","join","style","hasFills","boundaryPath","fillgroup","fillitems","pi","fullpath","prefixBoundary","joinAllPaths","i","startsleft","edgepaths","map","v","newloop","endpt","newendpt","cnt","nexti","possiblei","addpath","istop","pt","Math","abs","isbottom","isleft","isright","smoothopen","smoothing","replace","splice","indexOf","log","ptNew","paths","smoothclosed","lineContainer","showLines","showlines","showLabels","showlabels","clipLinesForLabels","linegroup","createLines","lineClip","createLineClip","uid","labelGroup","classed","labelClipPathData","labelData","clearLocationCache","contourFormat","labelFormatter","dummyText","tester","call","font","labelfont","xLen","_length","yLen","xRng","range","yRng","xMin","aggNums","min","xMax","max","yMin","yMax","x0","x1","y0","y1","bounds","left","right","top","bottom","middle","center","push","plotDiagonal","sqrt","normLength","LABELDISTANCE","LABELINCREASE","d","textOpts","calcTextOpts","level","path","pathBounds","getVisibleSegment","height","len","width","LABELMIN","maxLabels","ceil","LABELMAX","loc","findBestTextLocation","addLabelData","drawLabels","makeLines","opencontourlines","pedgepaths","closedcontourlines","ppaths","clips","_fullLayout","_clips","clipId","setClipUrl","fullLayout","formatAxis","_id","showexponent","exponentformat","labelformat","tickformat","cOpts","extractOpts","colorbar","_axis","value","Array","isArray","start","end","nticks","size","prepTicks","_tmin","_tmax","tickText","text","convertToTspans","el","node","bBox","fontSize","dy","plotBounds","textWidth","p0","dp","pMax","pMin","isClosed","INITIALSEARCHPOINTS","cost","Infinity","j","ITERATIONS","p","newLocation","getTextLocation","total","newCost","locationCost","MAXCOST","halfWidth","halfHeight","theta","dx","cos","sin","normX","normY","EDGECOST","ANGLECOST","x2","y2","labeli","dxd","dyd","dist","segmentDistance","sameLevel","distOffset","SAMELEVELDISTANCE","distFactor","NEIGHBORCOST","SAMELEVELFACTOR","w","h","rotateXY","bBoxPts","labels","transform","PI","clipPath","lineClipPath","connectgaps","clipPathInfo","crossings","starts","z","makeClipMask","empties","_emptypoints","m","n","row","emptyPoint","slice","zmask"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar Colorscale = require('../../components/colorscale');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvert = require('../../plots/cartesian/set_convert');\n\nvar heatmapPlot = require('../heatmap/plot');\nvar makeCrossings = require('./make_crossings');\nvar findAllPaths = require('./find_all_paths');\nvar emptyPathinfo = require('./empty_pathinfo');\nvar convertToConstraints = require('./convert_to_constraints');\nvar closeBoundaries = require('./close_boundaries');\nvar constants = require('./constants');\nvar costConstants = constants.LABELOPTIMIZER;\n\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(contourLayer, cdcontours, 'contour').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var x = cd0.x;\n        var y = cd0.y;\n        var contours = trace.contours;\n        var pathinfo = emptyPathinfo(contours, plotinfo, cd0);\n\n        // use a heatmap to fill - draw it behind the lines\n        var heatmapColoringLayer = Lib.ensureSingle(plotGroup, 'g', 'heatmapcoloring');\n        var cdheatmaps = [];\n        if(contours.coloring === 'heatmap') {\n            cdheatmaps = [cd];\n        }\n        heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n\n        makeCrossings(pathinfo);\n        findAllPaths(pathinfo);\n\n        var leftedge = xa.c2p(x[0], true);\n        var rightedge = xa.c2p(x[x.length - 1], true);\n        var bottomedge = ya.c2p(y[0], true);\n        var topedge = ya.c2p(y[y.length - 1], true);\n        var perimeter = [\n            [leftedge, topedge],\n            [rightedge, topedge],\n            [rightedge, bottomedge],\n            [leftedge, bottomedge]\n        ];\n\n        var fillPathinfo = pathinfo;\n        if(contours.type === 'constraint') {\n            // N.B. this also mutates pathinfo\n            fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n        }\n\n        // draw everything\n        makeBackground(plotGroup, perimeter, contours);\n        makeFills(plotGroup, fillPathinfo, perimeter, contours);\n        makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours);\n        clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);\n    });\n};\n\nfunction makeBackground(plotgroup, perimeter, contours) {\n    var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n\n    var bgfill = bggroup.selectAll('path')\n        .data(contours.coloring === 'fill' ? [0] : []);\n    bgfill.enter().append('path');\n    bgfill.exit().remove();\n    bgfill\n        .attr('d', 'M' + perimeter.join('L') + 'Z')\n        .style('stroke', 'none');\n}\n\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n    var hasFills = contours.coloring === 'fill' || (contours.type === 'constraint' && contours._operation !== '=');\n    var boundaryPath = 'M' + perimeter.join('L') + 'Z';\n\n    // fills prefixBoundary in pathinfo items\n    if(hasFills) {\n        closeBoundaries(pathinfo, contours);\n    }\n\n    var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n\n    var fillitems = fillgroup.selectAll('path').data(hasFills ? pathinfo : []);\n    fillitems.enter().append('path');\n    fillitems.exit().remove();\n    fillitems.each(function(pi) {\n        // join all paths for this level together into a single path\n        // first follow clockwise around the perimeter to close any open paths\n        // if the whole perimeter is above this level, start with a path\n        // enclosing the whole thing. With all that, the parity should mean\n        // that we always fill everything above the contour, nothing below\n        var fullpath = (pi.prefixBoundary ? boundaryPath : '') +\n            joinAllPaths(pi, perimeter);\n\n        if(!fullpath) {\n            d3.select(this).remove();\n        } else {\n            d3.select(this)\n                .attr('d', fullpath)\n                .style('stroke', 'none');\n        }\n    });\n}\n\nfunction joinAllPaths(pi, perimeter) {\n    var fullpath = '';\n    var i = 0;\n    var startsleft = pi.edgepaths.map(function(v, i) { return i; });\n    var newloop = true;\n    var endpt;\n    var newendpt;\n    var cnt;\n    var nexti;\n    var possiblei;\n    var addpath;\n\n    function istop(pt) { return Math.abs(pt[1] - perimeter[0][1]) < 0.01; }\n    function isbottom(pt) { return Math.abs(pt[1] - perimeter[2][1]) < 0.01; }\n    function isleft(pt) { return Math.abs(pt[0] - perimeter[0][0]) < 0.01; }\n    function isright(pt) { return Math.abs(pt[0] - perimeter[2][0]) < 0.01; }\n\n    while(startsleft.length) {\n        addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n        fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n        startsleft.splice(startsleft.indexOf(i), 1);\n        endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n        nexti = -1;\n\n        // now loop through sides, moving our endpoint until we find a new start\n        for(cnt = 0; cnt < 4; cnt++) { // just to prevent infinite loops\n            if(!endpt) {\n                Lib.log('Missing end?', i, pi);\n                break;\n            }\n\n            if(istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n            else if(isleft(endpt)) newendpt = perimeter[0]; // left top\n            else if(isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n            else if(isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n            for(possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n                var ptNew = pi.edgepaths[possiblei][0];\n                // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n                if(Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n                    if(Math.abs(endpt[0] - ptNew[0]) < 0.01 &&\n                            (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else if(Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n                    if(Math.abs(endpt[1] - ptNew[1]) < 0.01 &&\n                            (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else {\n                    Lib.log('endpt to newendpt is not vert. or horz.',\n                        endpt, newendpt, ptNew);\n                }\n            }\n\n            endpt = newendpt;\n\n            if(nexti >= 0) break;\n            fullpath += 'L' + newendpt;\n        }\n\n        if(nexti === pi.edgepaths.length) {\n            Lib.log('unclosed perimeter path');\n            break;\n        }\n\n        i = nexti;\n\n        // if we closed back on a loop we already included,\n        // close it and start a new loop\n        newloop = (startsleft.indexOf(i) === -1);\n        if(newloop) {\n            i = startsleft[0];\n            fullpath += 'Z';\n        }\n    }\n\n    // finally add the interior paths\n    for(i = 0; i < pi.paths.length; i++) {\n        fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n    }\n\n    return fullpath;\n}\n\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours) {\n    var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n    var showLines = contours.showlines !== false;\n    var showLabels = contours.showlabels;\n    var clipLinesForLabels = showLines && showLabels;\n\n    // Even if we're not going to show lines, we need to create them\n    // if we're showing labels, because the fill paths include the perimeter\n    // so can't be used to position the labels correctly.\n    // In this case we'll remove the lines after making the labels.\n    var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo);\n\n    var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);\n\n    var labelGroup = plotgroup.selectAll('g.contourlabels')\n        .data(showLabels ? [0] : []);\n\n    labelGroup.exit().remove();\n\n    labelGroup.enter().append('g')\n        .classed('contourlabels', true);\n\n    if(showLabels) {\n        var labelClipPathData = [];\n        var labelData = [];\n\n        // invalidate the getTextLocation cache in case paths changed\n        Lib.clearLocationCache();\n\n        var contourFormat = exports.labelFormatter(gd, cd0);\n\n        var dummyText = Drawing.tester.append('text')\n            .attr('data-notex', 1)\n            .call(Drawing.font, contours.labelfont);\n\n        var xa = pathinfo[0].xaxis;\n        var ya = pathinfo[0].yaxis;\n        var xLen = xa._length;\n        var yLen = ya._length;\n        var xRng = xa.range;\n        var yRng = ya.range;\n        var xMin = Lib.aggNums(Math.min, null, cd0.x);\n        var xMax = Lib.aggNums(Math.max, null, cd0.x);\n        var yMin = Lib.aggNums(Math.min, null, cd0.y);\n        var yMax = Lib.aggNums(Math.max, null, cd0.y);\n        var x0 = Math.max(xa.c2p(xMin, true), 0);\n        var x1 = Math.min(xa.c2p(xMax, true), xLen);\n        var y0 = Math.max(ya.c2p(yMax, true), 0);\n        var y1 = Math.min(ya.c2p(yMin, true), yLen);\n\n        // visible bounds of the contour trace (and the midpoints, to\n        // help with cost calculations)\n        var bounds = {};\n\n        if(xRng[0] < xRng[1]) {\n            bounds.left = x0;\n            bounds.right = x1;\n        } else {\n            bounds.left = x1;\n            bounds.right = x0;\n        }\n\n        if(yRng[0] < yRng[1]) {\n            bounds.top = y0;\n            bounds.bottom = y1;\n        } else {\n            bounds.top = y1;\n            bounds.bottom = y0;\n        }\n\n        bounds.middle = (bounds.top + bounds.bottom) / 2;\n        bounds.center = (bounds.left + bounds.right) / 2;\n\n        labelClipPathData.push([\n            [bounds.left, bounds.top],\n            [bounds.right, bounds.top],\n            [bounds.right, bounds.bottom],\n            [bounds.left, bounds.bottom]\n        ]);\n\n        var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen);\n\n        // the path length to use to scale the number of labels to draw:\n        var normLength = constants.LABELDISTANCE * plotDiagonal /\n            Math.max(1, pathinfo.length / constants.LABELINCREASE);\n\n        linegroup.each(function(d) {\n            var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n\n            d3.select(this).selectAll('path').each(function() {\n                var path = this;\n                var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n                if(!pathBounds) return;\n\n                if(pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n\n                var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength),\n                    constants.LABELMAX);\n\n                for(var i = 0; i < maxLabels; i++) {\n                    var loc = exports.findBestTextLocation(path, pathBounds, textOpts,\n                        labelData, bounds);\n\n                    if(!loc) break;\n\n                    exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n                }\n            });\n        });\n\n        dummyText.remove();\n\n        exports.drawLabels(labelGroup, labelData, gd, lineClip,\n            clipLinesForLabels ? labelClipPathData : null);\n    }\n\n    if(showLabels && !showLines) linegroup.remove();\n}\n\nexports.createLines = function(lineContainer, makeLines, pathinfo) {\n    var smoothing = pathinfo[0].smoothing;\n\n    var linegroup = lineContainer.selectAll('g.contourlevel')\n        .data(makeLines ? pathinfo : []);\n\n    linegroup.exit().remove();\n    linegroup.enter().append('g')\n        .classed('contourlevel', true);\n\n    if(makeLines) {\n        // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n        // edgepaths / paths are used by contour since it's in x/y from the start\n        var opencontourlines = linegroup.selectAll('path.openline')\n            .data(function(d) { return d.pedgepaths || d.edgepaths; });\n\n        opencontourlines.exit().remove();\n        opencontourlines.enter().append('path')\n            .classed('openline', true);\n\n        opencontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothopen(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', 'non-scaling-stroke');\n\n        var closedcontourlines = linegroup.selectAll('path.closedline')\n            .data(function(d) { return d.ppaths || d.paths; });\n\n        closedcontourlines.exit().remove();\n        closedcontourlines.enter().append('path')\n            .classed('closedline', true);\n\n        closedcontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothclosed(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', 'non-scaling-stroke');\n    }\n\n    return linegroup;\n};\n\nexports.createLineClip = function(lineContainer, clipLinesForLabels, gd, uid) {\n    var clips = gd._fullLayout._clips;\n    var clipId = clipLinesForLabels ? ('clipline' + uid) : null;\n\n    var lineClip = clips.selectAll('#' + clipId)\n        .data(clipLinesForLabels ? [0] : []);\n    lineClip.exit().remove();\n\n    lineClip.enter().append('clipPath')\n        .classed('contourlineclip', true)\n        .attr('id', clipId);\n\n    Drawing.setClipUrl(lineContainer, clipId, gd);\n\n    return lineClip;\n};\n\nexports.labelFormatter = function(gd, cd0) {\n    var fullLayout = gd._fullLayout;\n    var trace = cd0.trace;\n    var contours = trace.contours;\n\n    var formatAxis = {\n        type: 'linear',\n        _id: 'ycontour',\n        showexponent: 'all',\n        exponentformat: 'B'\n    };\n\n    if(contours.labelformat) {\n        formatAxis.tickformat = contours.labelformat;\n        setConvert(formatAxis, fullLayout);\n    } else {\n        var cOpts = Colorscale.extractOpts(trace);\n        if(cOpts && cOpts.colorbar && cOpts.colorbar._axis) {\n            formatAxis = cOpts.colorbar._axis;\n        } else {\n            if(contours.type === 'constraint') {\n                var value = contours.value;\n                if(Array.isArray(value)) {\n                    formatAxis.range = [value[0], value[value.length - 1]];\n                } else formatAxis.range = [value, value];\n            } else {\n                formatAxis.range = [contours.start, contours.end];\n                formatAxis.nticks = (contours.end - contours.start) / contours.size;\n            }\n\n            if(formatAxis.range[0] === formatAxis.range[1]) {\n                formatAxis.range[1] += formatAxis.range[0] || 1;\n            }\n            if(!formatAxis.nticks) formatAxis.nticks = 1000;\n\n            setConvert(formatAxis, fullLayout);\n            Axes.prepTicks(formatAxis);\n            formatAxis._tmin = null;\n            formatAxis._tmax = null;\n        }\n    }\n\n    return function(v) { return Axes.tickText(formatAxis, v).text; };\n};\n\nexports.calcTextOpts = function(level, contourFormat, dummyText, gd) {\n    var text = contourFormat(level);\n    dummyText.text(text)\n        .call(svgTextUtils.convertToTspans, gd);\n\n    var el = dummyText.node();\n    var bBox = Drawing.bBox(el, true);\n\n    return {\n        text: text,\n        width: bBox.width,\n        height: bBox.height,\n        fontSize: +(el.style['font-size'].replace('px', '')),\n        level: level,\n        dy: (bBox.top + bBox.bottom) / 2\n    };\n};\n\nexports.findBestTextLocation = function(path, pathBounds, textOpts, labelData, plotBounds) {\n    var textWidth = textOpts.width;\n\n    var p0, dp, pMax, pMin, loc;\n    if(pathBounds.isClosed) {\n        dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n        p0 = pathBounds.min + dp / 2;\n        pMax = pathBounds.max;\n    } else {\n        dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n        p0 = pathBounds.min + dp + textWidth / 2;\n        pMax = pathBounds.max - (dp + textWidth) / 2;\n    }\n\n    var cost = Infinity;\n    for(var j = 0; j < costConstants.ITERATIONS; j++) {\n        for(var p = p0; p < pMax; p += dp) {\n            var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n            var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n            if(newCost < cost) {\n                cost = newCost;\n                loc = newLocation;\n                pMin = p;\n            }\n        }\n        if(cost > costConstants.MAXCOST * 2) break;\n\n        // subsequent iterations just look half steps away from the\n        // best we found in the previous iteration\n        if(j) dp /= 2;\n        p0 = pMin - dp / 2;\n        pMax = p0 + dp * 1.5;\n    }\n    if(cost <= costConstants.MAXCOST) return loc;\n};\n\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\nfunction locationCost(loc, textOpts, labelData, bounds) {\n    var halfWidth = textOpts.width / 2;\n    var halfHeight = textOpts.height / 2;\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n    var dx = Math.cos(theta) * halfWidth;\n    var dy = Math.sin(theta) * halfWidth;\n\n    // cost for being near an edge\n    var normX = ((x > bounds.center) ? (bounds.right - x) : (x - bounds.left)) /\n        (dx + Math.abs(Math.sin(theta) * halfHeight));\n    var normY = ((y > bounds.middle) ? (bounds.bottom - y) : (y - bounds.top)) /\n        (Math.abs(dy) + Math.cos(theta) * halfHeight);\n    if(normX < 1 || normY < 1) return Infinity;\n    var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1));\n\n    // cost for not being horizontal\n    cost += costConstants.ANGLECOST * theta * theta;\n\n    // cost for being close to other labels\n    var x1 = x - dx;\n    var y1 = y - dy;\n    var x2 = x + dx;\n    var y2 = y + dy;\n    for(var i = 0; i < labelData.length; i++) {\n        var labeli = labelData[i];\n        var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n        var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n        var dist = Lib.segmentDistance(\n            x1, y1,\n            x2, y2,\n            labeli.x - dxd, labeli.y - dyd,\n            labeli.x + dxd, labeli.y + dyd\n        ) * 2 / (textOpts.height + labeli.height);\n\n        var sameLevel = labeli.level === textOpts.level;\n        var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n\n        if(dist <= distOffset) return Infinity;\n\n        var distFactor = costConstants.NEIGHBORCOST *\n            (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n\n        cost += distFactor / (dist - distOffset);\n    }\n\n    return cost;\n}\n\nexports.addLabelData = function(loc, textOpts, labelData, labelClipPathData) {\n    var fontSize = textOpts.fontSize;\n    var w = textOpts.width + fontSize / 3;\n    var h = Math.max(0, textOpts.height - fontSize / 3);\n\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n\n    var sin = Math.sin(theta);\n    var cos = Math.cos(theta);\n\n    var rotateXY = function(dx, dy) {\n        return [\n            x + dx * cos - dy * sin,\n            y + dx * sin + dy * cos\n        ];\n    };\n\n    var bBoxPts = [\n        rotateXY(-w / 2, -h / 2),\n        rotateXY(-w / 2, h / 2),\n        rotateXY(w / 2, h / 2),\n        rotateXY(w / 2, -h / 2)\n    ];\n\n    labelData.push({\n        text: textOpts.text,\n        x: x,\n        y: y,\n        dy: textOpts.dy,\n        theta: theta,\n        level: textOpts.level,\n        width: w,\n        height: h\n    });\n\n    labelClipPathData.push(bBoxPts);\n};\n\nexports.drawLabels = function(labelGroup, labelData, gd, lineClip, labelClipPathData) {\n    var labels = labelGroup.selectAll('text')\n        .data(labelData, function(d) {\n            return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n        });\n\n    labels.exit().remove();\n\n    labels.enter().append('text')\n        .attr({\n            'data-notex': 1,\n            'text-anchor': 'middle'\n        })\n        .each(function(d) {\n            var x = d.x + Math.sin(d.theta) * d.dy;\n            var y = d.y - Math.cos(d.theta) * d.dy;\n            d3.select(this)\n                .text(d.text)\n                .attr({\n                    x: x,\n                    y: y,\n                    transform: 'rotate(' + (180 * d.theta / Math.PI) + ' ' + x + ' ' + y + ')'\n                })\n                .call(svgTextUtils.convertToTspans, gd);\n        });\n\n    if(labelClipPathData) {\n        var clipPath = '';\n        for(var i = 0; i < labelClipPathData.length; i++) {\n            clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n        }\n\n        var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n        lineClipPath.attr('d', clipPath);\n    }\n};\n\nfunction clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {\n    var trace = cd0.trace;\n    var clips = gd._fullLayout._clips;\n    var clipId = 'clip' + trace.uid;\n\n    var clipPath = clips.selectAll('#' + clipId)\n        .data(trace.connectgaps ? [] : [0]);\n    clipPath.enter().append('clipPath')\n        .classed('contourclip', true)\n        .attr('id', clipId);\n    clipPath.exit().remove();\n\n    if(trace.connectgaps === false) {\n        var clipPathInfo = {\n            // fraction of the way from missing to present point\n            // to draw the boundary.\n            // if you make this 1 (or 1-epsilon) then a point in\n            // a sea of missing data will disappear entirely.\n            level: 0.9,\n            crossings: {},\n            starts: [],\n            edgepaths: [],\n            paths: [],\n            xaxis: plotinfo.xaxis,\n            yaxis: plotinfo.yaxis,\n            x: cd0.x,\n            y: cd0.y,\n            // 0 = no data, 1 = data\n            z: makeClipMask(cd0),\n            smoothing: 0\n        };\n\n        makeCrossings([clipPathInfo]);\n        findAllPaths([clipPathInfo]);\n        closeBoundaries([clipPathInfo], {type: 'levels'});\n\n        var path = Lib.ensureSingle(clipPath, 'path', '');\n        path.attr('d',\n            (clipPathInfo.prefixBoundary ? 'M' + perimeter.join('L') + 'Z' : '') +\n            joinAllPaths(clipPathInfo, perimeter)\n        );\n    } else clipId = null;\n\n    Drawing.setClipUrl(plotGroup, clipId, gd);\n}\n\nfunction makeClipMask(cd0) {\n    var empties = cd0.trace._emptypoints;\n    var z = [];\n    var m = cd0.z.length;\n    var n = cd0.z[0].length;\n    var i;\n    var row = [];\n    var emptyPoint;\n\n    for(i = 0; i < n; i++) row.push(1);\n    for(i = 0; i < m; i++) z.push(row.slice());\n    for(i = 0; i < empties.length; i++) {\n        emptyPoint = empties[i];\n        z[emptyPoint[0]][emptyPoint[1]] = 0;\n    }\n    // save this mask to determine whether to show this data in hover\n    cd0.zmask = z;\n    return z;\n}\n"]},"metadata":{},"sourceType":"script"}