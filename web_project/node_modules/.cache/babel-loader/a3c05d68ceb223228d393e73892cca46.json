{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar ensureSingle = Lib.ensureSingle;\nvar identity = Lib.identity;\n\nvar Drawing = require('../../components/drawing');\n\nvar subTypes = require('./subtypes');\n\nvar linePoints = require('./line_points');\n\nvar linkTraces = require('./link_traces');\n\nvar polygonTester = require('../../lib/polygon').tester;\n\nmodule.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {\n  var join, onComplete; // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n\n  var isFullReplot = !transitionOpts;\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0; // Link traces so the z-order of fill layers is correct\n\n  var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);\n  join = scatterLayer.selectAll('g.trace').data(cdscatterSorted, function (d) {\n    return d[0].trace.uid;\n  }); // Append new traces:\n\n  join.enter().append('g').attr('class', function (d) {\n    return 'trace scatter trace' + d[0].trace.uid;\n  }).style('stroke-miterlimit', 2);\n  join.order();\n  createFills(gd, join, plotinfo);\n\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      scatterLayer.selectAll('g.trace').each(function (d, i) {\n        plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (d, i) {\n      plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n    });\n  }\n\n  if (isFullReplot) {\n    join.exit().remove();\n  } // remove paths that didn't get used\n\n\n  scatterLayer.selectAll('path:not([d])').remove();\n};\n\nfunction createFills(gd, traceJoin, plotinfo) {\n  traceJoin.each(function (d) {\n    var fills = ensureSingle(d3.select(this), 'g', 'fills');\n    Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);\n    var trace = d[0].trace;\n    var fillData = [];\n    if (trace._ownfill) fillData.push('_ownFill');\n    if (trace._nexttrace) fillData.push('_nextFill');\n    var fillJoin = fills.selectAll('g').data(fillData, identity);\n    fillJoin.enter().append('g');\n    fillJoin.exit().each(function (d) {\n      trace[d] = null;\n    }).remove();\n    fillJoin.order().each(function (d) {\n      // make a path element inside the fill group, just so\n      // we can give it its own data later on and the group can\n      // keep its simple '_*Fill' data\n      trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');\n    });\n  });\n}\n\nfunction plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {\n  var i; // Since this has been reorganized and we're executing this on individual traces,\n  // we need to pass it the full list of cdscatter as well as this trace's index (idx)\n  // since it does an internal n^2 loop over comparisons with other traces:\n\n  selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n  function transition(selection) {\n    return hasTransition ? selection.transition() : selection;\n  }\n\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var trace = cdscatter[0].trace;\n  var line = trace.line;\n  var tr = d3.select(element);\n  var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');\n  var lines = ensureSingle(tr, 'g', 'lines');\n  var points = ensureSingle(tr, 'g', 'points');\n  var text = ensureSingle(tr, 'g', 'text'); // error bars are at the bottom\n\n  Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);\n  if (trace.visible !== true) return;\n  transition(tr).style('opacity', trace.opacity); // BUILD LINES AND FILLS\n\n  var ownFillEl3, tonext;\n  var ownFillDir = trace.fill.charAt(trace.fill.length - 1);\n  if (ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = ''; // store node for tweaking by selectPoints\n\n  cdscatter[0][plotinfo.isRangePlot ? 'nodeRangePlot3' : 'node3'] = tr;\n  var prevRevpath = '';\n  var prevPolygons = [];\n  var prevtrace = trace._prevtrace;\n\n  if (prevtrace) {\n    prevRevpath = prevtrace._prevRevpath || '';\n    tonext = prevtrace._nextFill;\n    prevPolygons = prevtrace._polygons;\n  }\n\n  var thispath;\n  var thisrevpath; // fullpath is all paths for this curve, joined together straight\n  // across gaps, for filling\n\n  var fullpath = ''; // revpath is fullpath reversed, for fill-to-next\n\n  var revpath = ''; // functions for converting a point array to a path\n\n  var pathfn, revpathbase, revpathfn; // variables used before and after the data join\n\n  var pt0, lastSegment, pt1, thisPolygons; // initialize line join data / method\n\n  var segments = [];\n  var makeUpdate = Lib.noop;\n  ownFillEl3 = trace._ownFill;\n\n  if (subTypes.hasLines(trace) || trace.fill !== 'none') {\n    if (tonext) {\n      // This tells .style which trace to use for fill information:\n      tonext.datum(cdscatter);\n    }\n\n    if (['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {\n      pathfn = Drawing.steps(line.shape);\n      revpathbase = Drawing.steps(line.shape.split('').reverse().join(''));\n    } else if (line.shape === 'spline') {\n      pathfn = revpathbase = function (pts) {\n        var pLast = pts[pts.length - 1];\n\n        if (pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {\n          // identical start and end points: treat it as a\n          // closed curve so we don't get a kink\n          return Drawing.smoothclosed(pts.slice(1), line.smoothing);\n        } else {\n          return Drawing.smoothopen(pts, line.smoothing);\n        }\n      };\n    } else {\n      pathfn = revpathbase = function (pts) {\n        return 'M' + pts.join('L');\n      };\n    }\n\n    revpathfn = function (pts) {\n      // note: this is destructive (reverses pts in place) so can't use pts after this\n      return revpathbase(pts.reverse());\n    };\n\n    segments = linePoints(cdscatter, {\n      xaxis: xa,\n      yaxis: ya,\n      connectGaps: trace.connectgaps,\n      baseTolerance: Math.max(line.width || 1, 3) / 4,\n      shape: line.shape,\n      simplify: line.simplify,\n      fill: trace.fill\n    }); // since we already have the pixel segments here, use them to make\n    // polygons for hover on fill\n    // TODO: can we skip this if hoveron!=fills? That would mean we\n    // need to redraw when you change hoveron...\n\n    thisPolygons = trace._polygons = new Array(segments.length);\n\n    for (i = 0; i < segments.length; i++) {\n      trace._polygons[i] = polygonTester(segments[i]);\n    }\n\n    if (segments.length) {\n      pt0 = segments[0][0];\n      lastSegment = segments[segments.length - 1];\n      pt1 = lastSegment[lastSegment.length - 1];\n    }\n\n    makeUpdate = function (isEnter) {\n      return function (pts) {\n        thispath = pathfn(pts);\n        thisrevpath = revpathfn(pts);\n\n        if (!fullpath) {\n          fullpath = thispath;\n          revpath = thisrevpath;\n        } else if (ownFillDir) {\n          fullpath += 'L' + thispath.substr(1);\n          revpath = thisrevpath + ('L' + revpath.substr(1));\n        } else {\n          fullpath += 'Z' + thispath;\n          revpath = thisrevpath + 'Z' + revpath;\n        }\n\n        if (subTypes.hasLines(trace) && pts.length > 1) {\n          var el = d3.select(this); // This makes the coloring work correctly:\n\n          el.datum(cdscatter);\n\n          if (isEnter) {\n            transition(el.style('opacity', 0).attr('d', thispath).call(Drawing.lineGroupStyle)).style('opacity', 1);\n          } else {\n            var sel = transition(el);\n            sel.attr('d', thispath);\n            Drawing.singleLineStyle(cdscatter, sel);\n          }\n        }\n      };\n    };\n  }\n\n  var lineJoin = lines.selectAll('.js-line').data(segments);\n  transition(lineJoin.exit()).style('opacity', 0).remove();\n  lineJoin.each(makeUpdate(false));\n  lineJoin.enter().append('path').classed('js-line', true).style('vector-effect', 'non-scaling-stroke').call(Drawing.lineGroupStyle).each(makeUpdate(true));\n  Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);\n\n  function clearFill(selection) {\n    transition(selection).attr('d', 'M0,0Z');\n  }\n\n  if (segments.length) {\n    if (ownFillEl3) {\n      ownFillEl3.datum(cdscatter);\n\n      if (pt0 && pt1) {\n        if (ownFillDir) {\n          if (ownFillDir === 'y') {\n            pt0[1] = pt1[1] = ya.c2p(0, true);\n          } else if (ownFillDir === 'x') {\n            pt0[0] = pt1[0] = xa.c2p(0, true);\n          } // fill to zero: full trace path, plus extension of\n          // the endpoints to the appropriate axis\n          // For the sake of animations, wrap the points around so that\n          // the points on the axes are the first two points. Otherwise\n          // animations get a little crazy if the number of points changes.\n\n\n          transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1)).call(Drawing.singleFillStyle);\n        } else {\n          // fill to self: just join the path to itself\n          transition(ownFillEl3).attr('d', fullpath + 'Z').call(Drawing.singleFillStyle);\n        }\n      }\n    } else if (tonext) {\n      if (trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {\n        // fill to next: full trace path, plus the previous path reversed\n        if (trace.fill === 'tonext') {\n          // tonext: for use by concentric shapes, like manually constructed\n          // contours, we just add the two paths closed on themselves.\n          // This makes strange results if one path is *not* entirely\n          // inside the other, but then that is a strange usage.\n          transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z').call(Drawing.singleFillStyle);\n        } else {\n          // tonextx/y: for now just connect endpoints with lines. This is\n          // the correct behavior if the endpoints are at the same value of\n          // y/x, but if they *aren't*, we should ideally do more complicated\n          // things depending on whether the new endpoint projects onto the\n          // existing curve or off the end of it\n          transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z').call(Drawing.singleFillStyle);\n        }\n\n        trace._polygons = trace._polygons.concat(prevPolygons);\n      } else {\n        clearFill(tonext);\n        trace._polygons = null;\n      }\n    }\n\n    trace._prevRevpath = revpath;\n    trace._prevPolygons = thisPolygons;\n  } else {\n    if (ownFillEl3) clearFill(ownFillEl3);else if (tonext) clearFill(tonext);\n    trace._polygons = trace._prevRevpath = trace._prevPolygons = null;\n  }\n\n  function visFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap && v.vis;\n    });\n  }\n\n  function visFilterWithGaps(d) {\n    return d.filter(function (v) {\n      return v.vis;\n    });\n  }\n\n  function gapFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap;\n    });\n  }\n\n  function keyFunc(d) {\n    return d.id;\n  } // Returns a function if the trace is keyed, otherwise returns undefined\n\n\n  function getKeyFunc(trace) {\n    if (trace.ids) {\n      return keyFunc;\n    }\n  }\n\n  function hideFilter() {\n    return false;\n  }\n\n  function makePoints(points, text, cdscatter) {\n    var join, selection, hasNode;\n    var trace = cdscatter[0].trace;\n    var showMarkers = subTypes.hasMarkers(trace);\n    var showText = subTypes.hasText(trace);\n    var keyFunc = getKeyFunc(trace);\n    var markerFilter = hideFilter;\n    var textFilter = hideFilter;\n\n    if (showMarkers || showText) {\n      var showFilter = identity; // if we're stacking, \"infer zero\" gap mode gets markers in the\n      // gap points - because we've inferred a zero there - but other\n      // modes (currently \"interpolate\", later \"interrupt\" hopefully)\n      // we don't draw generated markers\n\n      var stackGroup = trace.stackgroup;\n      var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero';\n\n      if (trace.marker.maxdisplayed || trace._needsCull) {\n        showFilter = isInferZero ? visFilterWithGaps : visFilter;\n      } else if (stackGroup && !isInferZero) {\n        showFilter = gapFilter;\n      }\n\n      if (showMarkers) markerFilter = showFilter;\n      if (showText) textFilter = showFilter;\n    } // marker points\n\n\n    selection = points.selectAll('path.point');\n    join = selection.data(markerFilter, keyFunc);\n    var enter = join.enter().append('path').classed('point', true);\n\n    if (hasTransition) {\n      enter.call(Drawing.pointStyle, trace, gd).call(Drawing.translatePoints, xa, ya).style('opacity', 0).transition().style('opacity', 1);\n    }\n\n    join.order();\n    var styleFns;\n\n    if (showMarkers) {\n      styleFns = Drawing.makePointStyleFns(trace);\n    }\n\n    join.each(function (d) {\n      var el = d3.select(this);\n      var sel = transition(el);\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n      if (hasNode) {\n        Drawing.singlePointStyle(d, sel, trace, styleFns, gd);\n\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n\n        if (trace.customdata) {\n          el.classed('plotly-customdata', d.data !== null && d.data !== undefined);\n        }\n      } else {\n        sel.remove();\n      }\n    });\n\n    if (hasTransition) {\n      join.exit().transition().style('opacity', 0).remove();\n    } else {\n      join.exit().remove();\n    } // text points\n\n\n    selection = text.selectAll('g');\n    join = selection.data(textFilter, keyFunc); // each text needs to go in its own 'g' in case\n    // it gets converted to mathjax\n\n    join.enter().append('g').classed('textpoint', true).append('text');\n    join.order();\n    join.each(function (d) {\n      var g = d3.select(this);\n      var sel = transition(g.select('text'));\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n      if (hasNode) {\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n      } else {\n        g.remove();\n      }\n    });\n    join.selectAll('text').call(Drawing.textPointStyle, trace, gd).each(function (d) {\n      // This just *has* to be totally custom becuase of SVG text positioning :(\n      // It's obviously copied from translatePoint; we just can't use that\n      var x = xa.c2p(d.x);\n      var y = ya.c2p(d.y);\n      d3.select(this).selectAll('tspan.line').each(function () {\n        transition(d3.select(this)).attr({\n          x: x,\n          y: y\n        });\n      });\n    });\n    join.exit().remove();\n  }\n\n  points.datum(cdscatter);\n  text.datum(cdscatter);\n  makePoints(points, text, cdscatter); // lastly, clip points groups of `cliponaxis !== false` traces\n  // on `plotinfo._hasClipOnAxisFalse === true` subplots\n\n  var hasClipOnAxisFalse = trace.cliponaxis === false;\n  var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;\n  Drawing.setClipUrl(points, clipUrl, gd);\n  Drawing.setClipUrl(text, clipUrl, gd);\n}\n\nfunction selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));\n  var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));\n  var trace = cdscatter[0].trace;\n  if (!subTypes.hasMarkers(trace)) return; // if marker.maxdisplayed is used, select a maximum of\n  // mnum markers to show, from the set that are in the viewport\n\n  var mnum = trace.marker.maxdisplayed; // TODO: remove some as we get away from the viewport?\n\n  if (mnum === 0) return;\n  var cd = cdscatter.filter(function (v) {\n    return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];\n  });\n  var inc = Math.ceil(cd.length / mnum);\n  var tnum = 0;\n  cdscatterAll.forEach(function (cdj, j) {\n    var tracei = cdj[0].trace;\n\n    if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {\n      tnum++;\n    }\n  }); // if multiple traces use maxdisplayed, stagger which markers we\n  // display this formula offsets successive traces by 1/3 of the\n  // increment, adding an extra small amount after each triplet so\n  // it's not quite periodic\n\n  var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1); // for error bars: save in cd which markers to show\n  // so we don't have to repeat this\n\n  cdscatter.forEach(function (v) {\n    delete v.vis;\n  });\n  cd.forEach(function (v, i) {\n    if (Math.round((i + i0) % inc) === 0) v.vis = true;\n  });\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/scatter/plot.js"],"names":["d3","require","Registry","Lib","ensureSingle","identity","Drawing","subTypes","linePoints","linkTraces","polygonTester","tester","module","exports","plot","gd","plotinfo","cdscatter","scatterLayer","transitionOpts","makeOnCompleteCallback","join","onComplete","isFullReplot","hasTransition","duration","cdscatterSorted","selectAll","data","d","trace","uid","enter","append","attr","style","order","createFills","transition","ease","easing","each","i","plotOne","exit","remove","traceJoin","fills","select","setClipUrl","layerClipId","fillData","_ownfill","push","_nexttrace","fillJoin","idx","cdscatterAll","element","selectMarkers","selection","xa","xaxis","ya","yaxis","line","tr","errorBarGroup","lines","points","text","getComponentMethod","visible","opacity","ownFillEl3","tonext","ownFillDir","fill","charAt","length","isRangePlot","prevRevpath","prevPolygons","prevtrace","_prevtrace","_prevRevpath","_nextFill","_polygons","thispath","thisrevpath","fullpath","revpath","pathfn","revpathbase","revpathfn","pt0","lastSegment","pt1","thisPolygons","segments","makeUpdate","noop","_ownFill","hasLines","datum","indexOf","shape","steps","split","reverse","pts","pLast","smoothclosed","slice","smoothing","smoothopen","connectGaps","connectgaps","baseTolerance","Math","max","width","simplify","Array","isEnter","substr","el","call","lineGroupStyle","sel","singleLineStyle","lineJoin","classed","clearFill","c2p","singleFillStyle","concat","_prevPolygons","visFilter","filter","v","gap","vis","visFilterWithGaps","gapFilter","keyFunc","id","getKeyFunc","ids","hideFilter","makePoints","hasNode","showMarkers","hasMarkers","showText","hasText","markerFilter","textFilter","showFilter","stackGroup","stackgroup","isInferZero","_fullLayout","_scatterStackOpts","_id","stackgaps","marker","maxdisplayed","_needsCull","pointStyle","translatePoints","styleFns","makePointStyleFns","translatePoint","singlePointStyle","hideOutsideRangePoint","xcalendar","ycalendar","customdata","undefined","g","textPointStyle","x","y","hasClipOnAxisFalse","cliponaxis","clipUrl","xr","extent","simpleMap","range","r2c","yr","mnum","cd","inc","ceil","tnum","forEach","cdj","j","tracei","i0","round","floor"],"mappings":"AAAA;;;;;;;AASA;;AAEA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;;AAEA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIE,GAAG,GAAGF,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIG,YAAY,GAAGD,GAAG,CAACC,YAAvB;AACA,IAAIC,QAAQ,GAAGF,GAAG,CAACE,QAAnB;;AACA,IAAIC,OAAO,GAAGL,OAAO,CAAC,0BAAD,CAArB;;AAEA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIO,UAAU,GAAGP,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAIQ,UAAU,GAAGR,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAIS,aAAa,GAAGT,OAAO,CAAC,mBAAD,CAAP,CAA6BU,MAAjD;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,IAAT,CAAcC,EAAd,EAAkBC,QAAlB,EAA4BC,SAA5B,EAAuCC,YAAvC,EAAqDC,cAArD,EAAqEC,sBAArE,EAA6F;AAC1G,MAAIC,IAAJ,EAAUC,UAAV,CAD0G,CAG1G;AACA;;AACA,MAAIC,YAAY,GAAG,CAACJ,cAApB;AACA,MAAIK,aAAa,GAAG,CAAC,CAACL,cAAF,IAAoBA,cAAc,CAACM,QAAf,GAA0B,CAAlE,CAN0G,CAQ1G;;AACA,MAAIC,eAAe,GAAGjB,UAAU,CAACM,EAAD,EAAKC,QAAL,EAAeC,SAAf,CAAhC;AAEAI,EAAAA,IAAI,GAAGH,YAAY,CAACS,SAAb,CAAuB,SAAvB,EACFC,IADE,CACGF,eADH,EACoB,UAASG,CAAT,EAAY;AAAE,WAAOA,CAAC,CAAC,CAAD,CAAD,CAAKC,KAAL,CAAWC,GAAlB;AAAwB,GAD1D,CAAP,CAX0G,CAc1G;;AACAV,EAAAA,IAAI,CAACW,KAAL,GAAaC,MAAb,CAAoB,GAApB,EACKC,IADL,CACU,OADV,EACmB,UAASL,CAAT,EAAY;AACvB,WAAO,wBAAwBA,CAAC,CAAC,CAAD,CAAD,CAAKC,KAAL,CAAWC,GAA1C;AACH,GAHL,EAIKI,KAJL,CAIW,mBAJX,EAIgC,CAJhC;AAKAd,EAAAA,IAAI,CAACe,KAAL;AAEAC,EAAAA,WAAW,CAACtB,EAAD,EAAKM,IAAL,EAAWL,QAAX,CAAX;;AAEA,MAAGQ,aAAH,EAAkB;AACd,QAAGJ,sBAAH,EAA2B;AACvB;AACA;AACA;AACAE,MAAAA,UAAU,GAAGF,sBAAsB,EAAnC;AACH;;AAED,QAAIkB,UAAU,GAAGtC,EAAE,CAACsC,UAAH,GACZb,QADY,CACHN,cAAc,CAACM,QADZ,EAEZc,IAFY,CAEPpB,cAAc,CAACqB,MAFR,EAGZC,IAHY,CAGP,KAHO,EAGA,YAAW;AACpBnB,MAAAA,UAAU,IAAIA,UAAU,EAAxB;AACH,KALY,EAMZmB,IANY,CAMP,WANO,EAMM,YAAW;AAC1BnB,MAAAA,UAAU,IAAIA,UAAU,EAAxB;AACH,KARY,CAAjB;AAUAgB,IAAAA,UAAU,CAACG,IAAX,CAAgB,YAAW;AACvB;AACA;AACAvB,MAAAA,YAAY,CAACS,SAAb,CAAuB,SAAvB,EAAkCc,IAAlC,CAAuC,UAASZ,CAAT,EAAYa,CAAZ,EAAe;AAClDC,QAAAA,OAAO,CAAC5B,EAAD,EAAK2B,CAAL,EAAQ1B,QAAR,EAAkBa,CAAlB,EAAqBH,eAArB,EAAsC,IAAtC,EAA4CP,cAA5C,CAAP;AACH,OAFD;AAGH,KAND;AAOH,GAzBD,MAyBO;AACHE,IAAAA,IAAI,CAACoB,IAAL,CAAU,UAASZ,CAAT,EAAYa,CAAZ,EAAe;AACrBC,MAAAA,OAAO,CAAC5B,EAAD,EAAK2B,CAAL,EAAQ1B,QAAR,EAAkBa,CAAlB,EAAqBH,eAArB,EAAsC,IAAtC,EAA4CP,cAA5C,CAAP;AACH,KAFD;AAGH;;AAED,MAAGI,YAAH,EAAiB;AACbF,IAAAA,IAAI,CAACuB,IAAL,GAAYC,MAAZ;AACH,GAzDyG,CA2D1G;;;AACA3B,EAAAA,YAAY,CAACS,SAAb,CAAuB,eAAvB,EAAwCkB,MAAxC;AACH,CA7DD;;AA+DA,SAASR,WAAT,CAAqBtB,EAArB,EAAyB+B,SAAzB,EAAoC9B,QAApC,EAA8C;AAC1C8B,EAAAA,SAAS,CAACL,IAAV,CAAe,UAASZ,CAAT,EAAY;AACvB,QAAIkB,KAAK,GAAG3C,YAAY,CAACJ,EAAE,CAACgD,MAAH,CAAU,IAAV,CAAD,EAAkB,GAAlB,EAAuB,OAAvB,CAAxB;AACA1C,IAAAA,OAAO,CAAC2C,UAAR,CAAmBF,KAAnB,EAA0B/B,QAAQ,CAACkC,WAAnC,EAAgDnC,EAAhD;AAEA,QAAIe,KAAK,GAAGD,CAAC,CAAC,CAAD,CAAD,CAAKC,KAAjB;AAEA,QAAIqB,QAAQ,GAAG,EAAf;AACA,QAAGrB,KAAK,CAACsB,QAAT,EAAmBD,QAAQ,CAACE,IAAT,CAAc,UAAd;AACnB,QAAGvB,KAAK,CAACwB,UAAT,EAAqBH,QAAQ,CAACE,IAAT,CAAc,WAAd;AAErB,QAAIE,QAAQ,GAAGR,KAAK,CAACpB,SAAN,CAAgB,GAAhB,EAAqBC,IAArB,CAA0BuB,QAA1B,EAAoC9C,QAApC,CAAf;AAEAkD,IAAAA,QAAQ,CAACvB,KAAT,GAAiBC,MAAjB,CAAwB,GAAxB;AAEAsB,IAAAA,QAAQ,CAACX,IAAT,GACKH,IADL,CACU,UAASZ,CAAT,EAAY;AAAEC,MAAAA,KAAK,CAACD,CAAD,CAAL,GAAW,IAAX;AAAkB,KAD1C,EAEKgB,MAFL;AAIAU,IAAAA,QAAQ,CAACnB,KAAT,GAAiBK,IAAjB,CAAsB,UAASZ,CAAT,EAAY;AAC9B;AACA;AACA;AACAC,MAAAA,KAAK,CAACD,CAAD,CAAL,GAAWzB,YAAY,CAACJ,EAAE,CAACgD,MAAH,CAAU,IAAV,CAAD,EAAkB,MAAlB,EAA0B,SAA1B,CAAvB;AACH,KALD;AAMH,GAxBD;AAyBH;;AAED,SAASL,OAAT,CAAiB5B,EAAjB,EAAqByC,GAArB,EAA0BxC,QAA1B,EAAoCC,SAApC,EAA+CwC,YAA/C,EAA6DC,OAA7D,EAAsEvC,cAAtE,EAAsF;AAClF,MAAIuB,CAAJ,CADkF,CAGlF;AACA;AACA;;AACAiB,EAAAA,aAAa,CAAC5C,EAAD,EAAKyC,GAAL,EAAUxC,QAAV,EAAoBC,SAApB,EAA+BwC,YAA/B,CAAb;AAEA,MAAIjC,aAAa,GAAG,CAAC,CAACL,cAAF,IAAoBA,cAAc,CAACM,QAAf,GAA0B,CAAlE;;AAEA,WAASa,UAAT,CAAoBsB,SAApB,EAA+B;AAC3B,WAAOpC,aAAa,GAAGoC,SAAS,CAACtB,UAAV,EAAH,GAA4BsB,SAAhD;AACH;;AAED,MAAIC,EAAE,GAAG7C,QAAQ,CAAC8C,KAAlB;AACA,MAAIC,EAAE,GAAG/C,QAAQ,CAACgD,KAAlB;AAEA,MAAIlC,KAAK,GAAGb,SAAS,CAAC,CAAD,CAAT,CAAaa,KAAzB;AACA,MAAImC,IAAI,GAAGnC,KAAK,CAACmC,IAAjB;AACA,MAAIC,EAAE,GAAGlE,EAAE,CAACgD,MAAH,CAAUU,OAAV,CAAT;AAEA,MAAIS,aAAa,GAAG/D,YAAY,CAAC8D,EAAD,EAAK,GAAL,EAAU,WAAV,CAAhC;AACA,MAAIE,KAAK,GAAGhE,YAAY,CAAC8D,EAAD,EAAK,GAAL,EAAU,OAAV,CAAxB;AACA,MAAIG,MAAM,GAAGjE,YAAY,CAAC8D,EAAD,EAAK,GAAL,EAAU,QAAV,CAAzB;AACA,MAAII,IAAI,GAAGlE,YAAY,CAAC8D,EAAD,EAAK,GAAL,EAAU,MAAV,CAAvB,CAxBkF,CA0BlF;;AACAhE,EAAAA,QAAQ,CAACqE,kBAAT,CAA4B,WAA5B,EAAyC,MAAzC,EAAiDxD,EAAjD,EAAqDoD,aAArD,EAAoEnD,QAApE,EAA8EG,cAA9E;AAEA,MAAGW,KAAK,CAAC0C,OAAN,KAAkB,IAArB,EAA2B;AAE3BlC,EAAAA,UAAU,CAAC4B,EAAD,CAAV,CAAe/B,KAAf,CAAqB,SAArB,EAAgCL,KAAK,CAAC2C,OAAtC,EA/BkF,CAiClF;;AACA,MAAIC,UAAJ,EAAgBC,MAAhB;AACA,MAAIC,UAAU,GAAG9C,KAAK,CAAC+C,IAAN,CAAWC,MAAX,CAAkBhD,KAAK,CAAC+C,IAAN,CAAWE,MAAX,GAAoB,CAAtC,CAAjB;AACA,MAAGH,UAAU,KAAK,GAAf,IAAsBA,UAAU,KAAK,GAAxC,EAA6CA,UAAU,GAAG,EAAb,CApCqC,CAsClF;;AACA3D,EAAAA,SAAS,CAAC,CAAD,CAAT,CAAaD,QAAQ,CAACgE,WAAT,GAAuB,gBAAvB,GAA0C,OAAvD,IAAkEd,EAAlE;AAEA,MAAIe,WAAW,GAAG,EAAlB;AACA,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,SAAS,GAAGrD,KAAK,CAACsD,UAAtB;;AAEA,MAAGD,SAAH,EAAc;AACVF,IAAAA,WAAW,GAAGE,SAAS,CAACE,YAAV,IAA0B,EAAxC;AACAV,IAAAA,MAAM,GAAGQ,SAAS,CAACG,SAAnB;AACAJ,IAAAA,YAAY,GAAGC,SAAS,CAACI,SAAzB;AACH;;AAED,MAAIC,QAAJ;AACA,MAAIC,WAAJ,CApDkF,CAqDlF;AACA;;AACA,MAAIC,QAAQ,GAAG,EAAf,CAvDkF,CAwDlF;;AACA,MAAIC,OAAO,GAAG,EAAd,CAzDkF,CA0DlF;;AACA,MAAIC,MAAJ,EAAYC,WAAZ,EAAyBC,SAAzB,CA3DkF,CA4DlF;;AACA,MAAIC,GAAJ,EAASC,WAAT,EAAsBC,GAAtB,EAA2BC,YAA3B,CA7DkF,CA+DlF;;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,UAAU,GAAGjG,GAAG,CAACkG,IAArB;AAEA3B,EAAAA,UAAU,GAAG5C,KAAK,CAACwE,QAAnB;;AAEA,MAAG/F,QAAQ,CAACgG,QAAT,CAAkBzE,KAAlB,KAA4BA,KAAK,CAAC+C,IAAN,KAAe,MAA9C,EAAsD;AAClD,QAAGF,MAAH,EAAW;AACP;AACAA,MAAAA,MAAM,CAAC6B,KAAP,CAAavF,SAAb;AACH;;AAED,QAAG,CAAC,IAAD,EAAO,IAAP,EAAa,KAAb,EAAoB,KAApB,EAA2BwF,OAA3B,CAAmCxC,IAAI,CAACyC,KAAxC,MAAmD,CAAC,CAAvD,EAA0D;AACtDd,MAAAA,MAAM,GAAGtF,OAAO,CAACqG,KAAR,CAAc1C,IAAI,CAACyC,KAAnB,CAAT;AACAb,MAAAA,WAAW,GAAGvF,OAAO,CAACqG,KAAR,CACV1C,IAAI,CAACyC,KAAL,CAAWE,KAAX,CAAiB,EAAjB,EAAqBC,OAArB,GAA+BxF,IAA/B,CAAoC,EAApC,CADU,CAAd;AAGH,KALD,MAKO,IAAG4C,IAAI,CAACyC,KAAL,KAAe,QAAlB,EAA4B;AAC/Bd,MAAAA,MAAM,GAAGC,WAAW,GAAG,UAASiB,GAAT,EAAc;AACjC,YAAIC,KAAK,GAAGD,GAAG,CAACA,GAAG,CAAC/B,MAAJ,GAAa,CAAd,CAAf;;AACA,YAAG+B,GAAG,CAAC/B,MAAJ,GAAa,CAAb,IAAkB+B,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,MAAcC,KAAK,CAAC,CAAD,CAArC,IAA4CD,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,MAAcC,KAAK,CAAC,CAAD,CAAlE,EAAuE;AACnE;AACA;AACA,iBAAOzG,OAAO,CAAC0G,YAAR,CAAqBF,GAAG,CAACG,KAAJ,CAAU,CAAV,CAArB,EAAmChD,IAAI,CAACiD,SAAxC,CAAP;AACH,SAJD,MAIO;AACH,iBAAO5G,OAAO,CAAC6G,UAAR,CAAmBL,GAAnB,EAAwB7C,IAAI,CAACiD,SAA7B,CAAP;AACH;AACJ,OATD;AAUH,KAXM,MAWA;AACHtB,MAAAA,MAAM,GAAGC,WAAW,GAAG,UAASiB,GAAT,EAAc;AACjC,eAAO,MAAMA,GAAG,CAACzF,IAAJ,CAAS,GAAT,CAAb;AACH,OAFD;AAGH;;AAEDyE,IAAAA,SAAS,GAAG,UAASgB,GAAT,EAAc;AACtB;AACA,aAAOjB,WAAW,CAACiB,GAAG,CAACD,OAAJ,EAAD,CAAlB;AACH,KAHD;;AAKAV,IAAAA,QAAQ,GAAG3F,UAAU,CAACS,SAAD,EAAY;AAC7B6C,MAAAA,KAAK,EAAED,EADsB;AAE7BG,MAAAA,KAAK,EAAED,EAFsB;AAG7BqD,MAAAA,WAAW,EAAEtF,KAAK,CAACuF,WAHU;AAI7BC,MAAAA,aAAa,EAAEC,IAAI,CAACC,GAAL,CAASvD,IAAI,CAACwD,KAAL,IAAc,CAAvB,EAA0B,CAA1B,IAA+B,CAJjB;AAK7Bf,MAAAA,KAAK,EAAEzC,IAAI,CAACyC,KALiB;AAM7BgB,MAAAA,QAAQ,EAAEzD,IAAI,CAACyD,QANc;AAO7B7C,MAAAA,IAAI,EAAE/C,KAAK,CAAC+C;AAPiB,KAAZ,CAArB,CAjCkD,CA2ClD;AACA;AACA;AACA;;AACAqB,IAAAA,YAAY,GAAGpE,KAAK,CAACyD,SAAN,GAAkB,IAAIoC,KAAJ,CAAUxB,QAAQ,CAACpB,MAAnB,CAAjC;;AACA,SAAIrC,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGyD,QAAQ,CAACpB,MAAxB,EAAgCrC,CAAC,EAAjC,EAAqC;AACjCZ,MAAAA,KAAK,CAACyD,SAAN,CAAgB7C,CAAhB,IAAqBhC,aAAa,CAACyF,QAAQ,CAACzD,CAAD,CAAT,CAAlC;AACH;;AAED,QAAGyD,QAAQ,CAACpB,MAAZ,EAAoB;AAChBgB,MAAAA,GAAG,GAAGI,QAAQ,CAAC,CAAD,CAAR,CAAY,CAAZ,CAAN;AACAH,MAAAA,WAAW,GAAGG,QAAQ,CAACA,QAAQ,CAACpB,MAAT,GAAkB,CAAnB,CAAtB;AACAkB,MAAAA,GAAG,GAAGD,WAAW,CAACA,WAAW,CAACjB,MAAZ,GAAqB,CAAtB,CAAjB;AACH;;AAEDqB,IAAAA,UAAU,GAAG,UAASwB,OAAT,EAAkB;AAC3B,aAAO,UAASd,GAAT,EAAc;AACjBtB,QAAAA,QAAQ,GAAGI,MAAM,CAACkB,GAAD,CAAjB;AACArB,QAAAA,WAAW,GAAGK,SAAS,CAACgB,GAAD,CAAvB;;AACA,YAAG,CAACpB,QAAJ,EAAc;AACVA,UAAAA,QAAQ,GAAGF,QAAX;AACAG,UAAAA,OAAO,GAAGF,WAAV;AACH,SAHD,MAGO,IAAGb,UAAH,EAAe;AAClBc,UAAAA,QAAQ,IAAI,MAAMF,QAAQ,CAACqC,MAAT,CAAgB,CAAhB,CAAlB;AACAlC,UAAAA,OAAO,GAAGF,WAAW,IAAI,MAAME,OAAO,CAACkC,MAAR,CAAe,CAAf,CAAV,CAArB;AACH,SAHM,MAGA;AACHnC,UAAAA,QAAQ,IAAI,MAAMF,QAAlB;AACAG,UAAAA,OAAO,GAAGF,WAAW,GAAG,GAAd,GAAoBE,OAA9B;AACH;;AAED,YAAGpF,QAAQ,CAACgG,QAAT,CAAkBzE,KAAlB,KAA4BgF,GAAG,CAAC/B,MAAJ,GAAa,CAA5C,EAA+C;AAC3C,cAAI+C,EAAE,GAAG9H,EAAE,CAACgD,MAAH,CAAU,IAAV,CAAT,CAD2C,CAG3C;;AACA8E,UAAAA,EAAE,CAACtB,KAAH,CAASvF,SAAT;;AAEA,cAAG2G,OAAH,EAAY;AACRtF,YAAAA,UAAU,CAACwF,EAAE,CAAC3F,KAAH,CAAS,SAAT,EAAoB,CAApB,EACND,IADM,CACD,GADC,EACIsD,QADJ,EAENuC,IAFM,CAEDzH,OAAO,CAAC0H,cAFP,CAAD,CAAV,CAGS7F,KAHT,CAGe,SAHf,EAG0B,CAH1B;AAIH,WALD,MAKO;AACH,gBAAI8F,GAAG,GAAG3F,UAAU,CAACwF,EAAD,CAApB;AACAG,YAAAA,GAAG,CAAC/F,IAAJ,CAAS,GAAT,EAAcsD,QAAd;AACAlF,YAAAA,OAAO,CAAC4H,eAAR,CAAwBjH,SAAxB,EAAmCgH,GAAnC;AACH;AACJ;AACJ,OA/BD;AAgCH,KAjCD;AAkCH;;AAED,MAAIE,QAAQ,GAAG/D,KAAK,CAACzC,SAAN,CAAgB,UAAhB,EAA4BC,IAA5B,CAAiCuE,QAAjC,CAAf;AAEA7D,EAAAA,UAAU,CAAC6F,QAAQ,CAACvF,IAAT,EAAD,CAAV,CACKT,KADL,CACW,SADX,EACsB,CADtB,EAEKU,MAFL;AAIAsF,EAAAA,QAAQ,CAAC1F,IAAT,CAAc2D,UAAU,CAAC,KAAD,CAAxB;AAEA+B,EAAAA,QAAQ,CAACnG,KAAT,GAAiBC,MAAjB,CAAwB,MAAxB,EACKmG,OADL,CACa,SADb,EACwB,IADxB,EAEKjG,KAFL,CAEW,eAFX,EAE4B,oBAF5B,EAGK4F,IAHL,CAGUzH,OAAO,CAAC0H,cAHlB,EAIKvF,IAJL,CAIU2D,UAAU,CAAC,IAAD,CAJpB;AAMA9F,EAAAA,OAAO,CAAC2C,UAAR,CAAmBkF,QAAnB,EAA6BnH,QAAQ,CAACkC,WAAtC,EAAmDnC,EAAnD;;AAEA,WAASsH,SAAT,CAAmBzE,SAAnB,EAA8B;AAC1BtB,IAAAA,UAAU,CAACsB,SAAD,CAAV,CAAsB1B,IAAtB,CAA2B,GAA3B,EAAgC,OAAhC;AACH;;AAED,MAAGiE,QAAQ,CAACpB,MAAZ,EAAoB;AAChB,QAAGL,UAAH,EAAe;AACXA,MAAAA,UAAU,CAAC8B,KAAX,CAAiBvF,SAAjB;;AACA,UAAG8E,GAAG,IAAIE,GAAV,EAAe;AACX,YAAGrB,UAAH,EAAe;AACX,cAAGA,UAAU,KAAK,GAAlB,EAAuB;AACnBmB,YAAAA,GAAG,CAAC,CAAD,CAAH,GAASE,GAAG,CAAC,CAAD,CAAH,GAASlC,EAAE,CAACuE,GAAH,CAAO,CAAP,EAAU,IAAV,CAAlB;AACH,WAFD,MAEO,IAAG1D,UAAU,KAAK,GAAlB,EAAuB;AAC1BmB,YAAAA,GAAG,CAAC,CAAD,CAAH,GAASE,GAAG,CAAC,CAAD,CAAH,GAASpC,EAAE,CAACyE,GAAH,CAAO,CAAP,EAAU,IAAV,CAAlB;AACH,WALU,CAOX;AACA;AACA;AACA;AACA;;;AACAhG,UAAAA,UAAU,CAACoC,UAAD,CAAV,CAAuBxC,IAAvB,CAA4B,GAA5B,EAAiC,MAAM+D,GAAN,GAAY,GAAZ,GAAkBF,GAAlB,GAAwB,GAAxB,GAA8BL,QAAQ,CAACmC,MAAT,CAAgB,CAAhB,CAA/D,EACKE,IADL,CACUzH,OAAO,CAACiI,eADlB;AAEH,SAdD,MAcO;AACH;AACAjG,UAAAA,UAAU,CAACoC,UAAD,CAAV,CAAuBxC,IAAvB,CAA4B,GAA5B,EAAiCwD,QAAQ,GAAG,GAA5C,EACKqC,IADL,CACUzH,OAAO,CAACiI,eADlB;AAEH;AACJ;AACJ,KAvBD,MAuBO,IAAG5D,MAAH,EAAW;AACd,UAAG7C,KAAK,CAAC+C,IAAN,CAAWgD,MAAX,CAAkB,CAAlB,EAAqB,CAArB,MAA4B,QAA5B,IAAwCnC,QAAxC,IAAoDT,WAAvD,EAAoE;AAChE;AACA,YAAGnD,KAAK,CAAC+C,IAAN,KAAe,QAAlB,EAA4B;AACxB;AACA;AACA;AACA;AACAvC,UAAAA,UAAU,CAACqC,MAAD,CAAV,CAAmBzC,IAAnB,CAAwB,GAAxB,EAA6BwD,QAAQ,GAAG,GAAX,GAAiBT,WAAjB,GAA+B,GAA5D,EACK8C,IADL,CACUzH,OAAO,CAACiI,eADlB;AAEH,SAPD,MAOO;AACH;AACA;AACA;AACA;AACA;AACAjG,UAAAA,UAAU,CAACqC,MAAD,CAAV,CAAmBzC,IAAnB,CAAwB,GAAxB,EAA6BwD,QAAQ,GAAG,GAAX,GAAiBT,WAAW,CAAC4C,MAAZ,CAAmB,CAAnB,CAAjB,GAAyC,GAAtE,EACKE,IADL,CACUzH,OAAO,CAACiI,eADlB;AAEH;;AACDzG,QAAAA,KAAK,CAACyD,SAAN,GAAkBzD,KAAK,CAACyD,SAAN,CAAgBiD,MAAhB,CAAuBtD,YAAvB,CAAlB;AACH,OAnBD,MAmBO;AACHmD,QAAAA,SAAS,CAAC1D,MAAD,CAAT;AACA7C,QAAAA,KAAK,CAACyD,SAAN,GAAkB,IAAlB;AACH;AACJ;;AACDzD,IAAAA,KAAK,CAACuD,YAAN,GAAqBM,OAArB;AACA7D,IAAAA,KAAK,CAAC2G,aAAN,GAAsBvC,YAAtB;AACH,GAnDD,MAmDO;AACH,QAAGxB,UAAH,EAAe2D,SAAS,CAAC3D,UAAD,CAAT,CAAf,KACK,IAAGC,MAAH,EAAW0D,SAAS,CAAC1D,MAAD,CAAT;AAChB7C,IAAAA,KAAK,CAACyD,SAAN,GAAkBzD,KAAK,CAACuD,YAAN,GAAqBvD,KAAK,CAAC2G,aAAN,GAAsB,IAA7D;AACH;;AAGD,WAASC,SAAT,CAAmB7G,CAAnB,EAAsB;AAClB,WAAOA,CAAC,CAAC8G,MAAF,CAAS,UAASC,CAAT,EAAY;AAAE,aAAO,CAACA,CAAC,CAACC,GAAH,IAAUD,CAAC,CAACE,GAAnB;AAAyB,KAAhD,CAAP;AACH;;AAED,WAASC,iBAAT,CAA2BlH,CAA3B,EAA8B;AAC1B,WAAOA,CAAC,CAAC8G,MAAF,CAAS,UAASC,CAAT,EAAY;AAAE,aAAOA,CAAC,CAACE,GAAT;AAAe,KAAtC,CAAP;AACH;;AAED,WAASE,SAAT,CAAmBnH,CAAnB,EAAsB;AAClB,WAAOA,CAAC,CAAC8G,MAAF,CAAS,UAASC,CAAT,EAAY;AAAE,aAAO,CAACA,CAAC,CAACC,GAAV;AAAgB,KAAvC,CAAP;AACH;;AAED,WAASI,OAAT,CAAiBpH,CAAjB,EAAoB;AAChB,WAAOA,CAAC,CAACqH,EAAT;AACH,GA/PiF,CAiQlF;;;AACA,WAASC,UAAT,CAAoBrH,KAApB,EAA2B;AACvB,QAAGA,KAAK,CAACsH,GAAT,EAAc;AACV,aAAOH,OAAP;AACH;AACJ;;AAED,WAASI,UAAT,GAAsB;AAClB,WAAO,KAAP;AACH;;AAED,WAASC,UAAT,CAAoBjF,MAApB,EAA4BC,IAA5B,EAAkCrD,SAAlC,EAA6C;AACzC,QAAII,IAAJ,EAAUuC,SAAV,EAAqB2F,OAArB;AAEA,QAAIzH,KAAK,GAAGb,SAAS,CAAC,CAAD,CAAT,CAAaa,KAAzB;AACA,QAAI0H,WAAW,GAAGjJ,QAAQ,CAACkJ,UAAT,CAAoB3H,KAApB,CAAlB;AACA,QAAI4H,QAAQ,GAAGnJ,QAAQ,CAACoJ,OAAT,CAAiB7H,KAAjB,CAAf;AAEA,QAAImH,OAAO,GAAGE,UAAU,CAACrH,KAAD,CAAxB;AACA,QAAI8H,YAAY,GAAGP,UAAnB;AACA,QAAIQ,UAAU,GAAGR,UAAjB;;AAEA,QAAGG,WAAW,IAAIE,QAAlB,EAA4B;AACxB,UAAII,UAAU,GAAGzJ,QAAjB,CADwB,CAExB;AACA;AACA;AACA;;AACA,UAAI0J,UAAU,GAAGjI,KAAK,CAACkI,UAAvB;AACA,UAAIC,WAAW,GAAGF,UAAU,IACxBhJ,EAAE,CAACmJ,WAAH,CAAeC,iBAAf,CAAiCtG,EAAE,CAACuG,GAAH,GAASrG,EAAE,CAACqG,GAA7C,EAAkDL,UAAlD,EAA8DM,SAA9D,KAA4E,YADhF;;AAEA,UAAGvI,KAAK,CAACwI,MAAN,CAAaC,YAAb,IAA6BzI,KAAK,CAAC0I,UAAtC,EAAkD;AAC9CV,QAAAA,UAAU,GAAGG,WAAW,GAAGlB,iBAAH,GAAuBL,SAA/C;AACH,OAFD,MAEO,IAAGqB,UAAU,IAAI,CAACE,WAAlB,EAA+B;AAClCH,QAAAA,UAAU,GAAGd,SAAb;AACH;;AAED,UAAGQ,WAAH,EAAgBI,YAAY,GAAGE,UAAf;AAChB,UAAGJ,QAAH,EAAaG,UAAU,GAAGC,UAAb;AAChB,KA5BwC,CA8BzC;;;AAEAlG,IAAAA,SAAS,GAAGS,MAAM,CAAC1C,SAAP,CAAiB,YAAjB,CAAZ;AAEAN,IAAAA,IAAI,GAAGuC,SAAS,CAAChC,IAAV,CAAegI,YAAf,EAA6BX,OAA7B,CAAP;AAEA,QAAIjH,KAAK,GAAGX,IAAI,CAACW,KAAL,GAAaC,MAAb,CAAoB,MAApB,EACPmG,OADO,CACC,OADD,EACU,IADV,CAAZ;;AAGA,QAAG5G,aAAH,EAAkB;AACdQ,MAAAA,KAAK,CACA+F,IADL,CACUzH,OAAO,CAACmK,UADlB,EAC8B3I,KAD9B,EACqCf,EADrC,EAEKgH,IAFL,CAEUzH,OAAO,CAACoK,eAFlB,EAEmC7G,EAFnC,EAEuCE,EAFvC,EAGK5B,KAHL,CAGW,SAHX,EAGsB,CAHtB,EAIKG,UAJL,GAKKH,KALL,CAKW,SALX,EAKsB,CALtB;AAMH;;AAEDd,IAAAA,IAAI,CAACe,KAAL;AAEA,QAAIuI,QAAJ;;AACA,QAAGnB,WAAH,EAAgB;AACZmB,MAAAA,QAAQ,GAAGrK,OAAO,CAACsK,iBAAR,CAA0B9I,KAA1B,CAAX;AACH;;AAEDT,IAAAA,IAAI,CAACoB,IAAL,CAAU,UAASZ,CAAT,EAAY;AAClB,UAAIiG,EAAE,GAAG9H,EAAE,CAACgD,MAAH,CAAU,IAAV,CAAT;AACA,UAAIiF,GAAG,GAAG3F,UAAU,CAACwF,EAAD,CAApB;AACAyB,MAAAA,OAAO,GAAGjJ,OAAO,CAACuK,cAAR,CAAuBhJ,CAAvB,EAA0BoG,GAA1B,EAA+BpE,EAA/B,EAAmCE,EAAnC,CAAV;;AAEA,UAAGwF,OAAH,EAAY;AACRjJ,QAAAA,OAAO,CAACwK,gBAAR,CAAyBjJ,CAAzB,EAA4BoG,GAA5B,EAAiCnG,KAAjC,EAAwC6I,QAAxC,EAAkD5J,EAAlD;;AAEA,YAAGC,QAAQ,CAACkC,WAAZ,EAAyB;AACrB5C,UAAAA,OAAO,CAACyK,qBAAR,CAA8BlJ,CAA9B,EAAiCoG,GAAjC,EAAsCpE,EAAtC,EAA0CE,EAA1C,EAA8CjC,KAAK,CAACkJ,SAApD,EAA+DlJ,KAAK,CAACmJ,SAArE;AACH;;AAED,YAAGnJ,KAAK,CAACoJ,UAAT,EAAqB;AACjBpD,UAAAA,EAAE,CAACM,OAAH,CAAW,mBAAX,EAAgCvG,CAAC,CAACD,IAAF,KAAW,IAAX,IAAmBC,CAAC,CAACD,IAAF,KAAWuJ,SAA9D;AACH;AACJ,OAVD,MAUO;AACHlD,QAAAA,GAAG,CAACpF,MAAJ;AACH;AACJ,KAlBD;;AAoBA,QAAGrB,aAAH,EAAkB;AACdH,MAAAA,IAAI,CAACuB,IAAL,GAAYN,UAAZ,GACKH,KADL,CACW,SADX,EACsB,CADtB,EAEKU,MAFL;AAGH,KAJD,MAIO;AACHxB,MAAAA,IAAI,CAACuB,IAAL,GAAYC,MAAZ;AACH,KAjFwC,CAmFzC;;;AACAe,IAAAA,SAAS,GAAGU,IAAI,CAAC3C,SAAL,CAAe,GAAf,CAAZ;AACAN,IAAAA,IAAI,GAAGuC,SAAS,CAAChC,IAAV,CAAeiI,UAAf,EAA2BZ,OAA3B,CAAP,CArFyC,CAuFzC;AACA;;AACA5H,IAAAA,IAAI,CAACW,KAAL,GAAaC,MAAb,CAAoB,GAApB,EAAyBmG,OAAzB,CAAiC,WAAjC,EAA8C,IAA9C,EAAoDnG,MAApD,CAA2D,MAA3D;AAEAZ,IAAAA,IAAI,CAACe,KAAL;AAEAf,IAAAA,IAAI,CAACoB,IAAL,CAAU,UAASZ,CAAT,EAAY;AAClB,UAAIuJ,CAAC,GAAGpL,EAAE,CAACgD,MAAH,CAAU,IAAV,CAAR;AACA,UAAIiF,GAAG,GAAG3F,UAAU,CAAC8I,CAAC,CAACpI,MAAF,CAAS,MAAT,CAAD,CAApB;AACAuG,MAAAA,OAAO,GAAGjJ,OAAO,CAACuK,cAAR,CAAuBhJ,CAAvB,EAA0BoG,GAA1B,EAA+BpE,EAA/B,EAAmCE,EAAnC,CAAV;;AAEA,UAAGwF,OAAH,EAAY;AACR,YAAGvI,QAAQ,CAACkC,WAAZ,EAAyB;AACrB5C,UAAAA,OAAO,CAACyK,qBAAR,CAA8BlJ,CAA9B,EAAiCuJ,CAAjC,EAAoCvH,EAApC,EAAwCE,EAAxC,EAA4CjC,KAAK,CAACkJ,SAAlD,EAA6DlJ,KAAK,CAACmJ,SAAnE;AACH;AACJ,OAJD,MAIO;AACHG,QAAAA,CAAC,CAACvI,MAAF;AACH;AACJ,KAZD;AAcAxB,IAAAA,IAAI,CAACM,SAAL,CAAe,MAAf,EACKoG,IADL,CACUzH,OAAO,CAAC+K,cADlB,EACkCvJ,KADlC,EACyCf,EADzC,EAEK0B,IAFL,CAEU,UAASZ,CAAT,EAAY;AACd;AACA;AACA,UAAIyJ,CAAC,GAAGzH,EAAE,CAACyE,GAAH,CAAOzG,CAAC,CAACyJ,CAAT,CAAR;AACA,UAAIC,CAAC,GAAGxH,EAAE,CAACuE,GAAH,CAAOzG,CAAC,CAAC0J,CAAT,CAAR;AAEAvL,MAAAA,EAAE,CAACgD,MAAH,CAAU,IAAV,EAAgBrB,SAAhB,CAA0B,YAA1B,EAAwCc,IAAxC,CAA6C,YAAW;AACpDH,QAAAA,UAAU,CAACtC,EAAE,CAACgD,MAAH,CAAU,IAAV,CAAD,CAAV,CAA4Bd,IAA5B,CAAiC;AAACoJ,UAAAA,CAAC,EAAEA,CAAJ;AAAOC,UAAAA,CAAC,EAAEA;AAAV,SAAjC;AACH,OAFD;AAGH,KAXL;AAaAlK,IAAAA,IAAI,CAACuB,IAAL,GAAYC,MAAZ;AACH;;AAEDwB,EAAAA,MAAM,CAACmC,KAAP,CAAavF,SAAb;AACAqD,EAAAA,IAAI,CAACkC,KAAL,CAAWvF,SAAX;AACAqI,EAAAA,UAAU,CAACjF,MAAD,EAASC,IAAT,EAAerD,SAAf,CAAV,CAzYkF,CA2YlF;AACA;;AACA,MAAIuK,kBAAkB,GAAG1J,KAAK,CAAC2J,UAAN,KAAqB,KAA9C;AACA,MAAIC,OAAO,GAAGF,kBAAkB,GAAG,IAAH,GAAUxK,QAAQ,CAACkC,WAAnD;AACA5C,EAAAA,OAAO,CAAC2C,UAAR,CAAmBoB,MAAnB,EAA2BqH,OAA3B,EAAoC3K,EAApC;AACAT,EAAAA,OAAO,CAAC2C,UAAR,CAAmBqB,IAAnB,EAAyBoH,OAAzB,EAAkC3K,EAAlC;AACH;;AAED,SAAS4C,aAAT,CAAuB5C,EAAvB,EAA2ByC,GAA3B,EAAgCxC,QAAhC,EAA0CC,SAA1C,EAAqDwC,YAArD,EAAmE;AAC/D,MAAII,EAAE,GAAG7C,QAAQ,CAAC8C,KAAlB;AACA,MAAIC,EAAE,GAAG/C,QAAQ,CAACgD,KAAlB;AACA,MAAI2H,EAAE,GAAG3L,EAAE,CAAC4L,MAAH,CAAUzL,GAAG,CAAC0L,SAAJ,CAAchI,EAAE,CAACiI,KAAjB,EAAwBjI,EAAE,CAACkI,GAA3B,CAAV,CAAT;AACA,MAAIC,EAAE,GAAGhM,EAAE,CAAC4L,MAAH,CAAUzL,GAAG,CAAC0L,SAAJ,CAAc9H,EAAE,CAAC+H,KAAjB,EAAwB/H,EAAE,CAACgI,GAA3B,CAAV,CAAT;AAEA,MAAIjK,KAAK,GAAGb,SAAS,CAAC,CAAD,CAAT,CAAaa,KAAzB;AACA,MAAG,CAACvB,QAAQ,CAACkJ,UAAT,CAAoB3H,KAApB,CAAJ,EAAgC,OAP+B,CAQ/D;AACA;;AACA,MAAImK,IAAI,GAAGnK,KAAK,CAACwI,MAAN,CAAaC,YAAxB,CAV+D,CAY/D;;AACA,MAAG0B,IAAI,KAAK,CAAZ,EAAe;AAEf,MAAIC,EAAE,GAAGjL,SAAS,CAAC0H,MAAV,CAAiB,UAASC,CAAT,EAAY;AAClC,WAAOA,CAAC,CAAC0C,CAAF,IAAOK,EAAE,CAAC,CAAD,CAAT,IAAgB/C,CAAC,CAAC0C,CAAF,IAAOK,EAAE,CAAC,CAAD,CAAzB,IAAgC/C,CAAC,CAAC2C,CAAF,IAAOS,EAAE,CAAC,CAAD,CAAzC,IAAgDpD,CAAC,CAAC2C,CAAF,IAAOS,EAAE,CAAC,CAAD,CAAhE;AACH,GAFQ,CAAT;AAGA,MAAIG,GAAG,GAAG5E,IAAI,CAAC6E,IAAL,CAAUF,EAAE,CAACnH,MAAH,GAAYkH,IAAtB,CAAV;AACA,MAAII,IAAI,GAAG,CAAX;AACA5I,EAAAA,YAAY,CAAC6I,OAAb,CAAqB,UAASC,GAAT,EAAcC,CAAd,EAAiB;AAClC,QAAIC,MAAM,GAAGF,GAAG,CAAC,CAAD,CAAH,CAAOzK,KAApB;;AACA,QAAGvB,QAAQ,CAACkJ,UAAT,CAAoBgD,MAApB,KACKA,MAAM,CAACnC,MAAP,CAAcC,YAAd,GAA6B,CADlC,IACuCiC,CAAC,GAAGhJ,GAD9C,EACmD;AAC/C6I,MAAAA,IAAI;AACP;AACJ,GAND,EApB+D,CA4B/D;AACA;AACA;AACA;;AACA,MAAIK,EAAE,GAAGnF,IAAI,CAACoF,KAAL,CAAWN,IAAI,GAAGF,GAAP,GAAa,CAAb,GAAiB5E,IAAI,CAACqF,KAAL,CAAWP,IAAI,GAAG,CAAlB,IAAuBF,GAAvB,GAA6B,GAAzD,CAAT,CAhC+D,CAkC/D;AACA;;AACAlL,EAAAA,SAAS,CAACqL,OAAV,CAAkB,UAAS1D,CAAT,EAAY;AAAE,WAAOA,CAAC,CAACE,GAAT;AAAe,GAA/C;AACAoD,EAAAA,EAAE,CAACI,OAAH,CAAW,UAAS1D,CAAT,EAAYlG,CAAZ,EAAe;AACtB,QAAG6E,IAAI,CAACoF,KAAL,CAAW,CAACjK,CAAC,GAAGgK,EAAL,IAAWP,GAAtB,MAA+B,CAAlC,EAAqCvD,CAAC,CAACE,GAAF,GAAQ,IAAR;AACxC,GAFD;AAGH","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar ensureSingle = Lib.ensureSingle;\nvar identity = Lib.identity;\nvar Drawing = require('../../components/drawing');\n\nvar subTypes = require('./subtypes');\nvar linePoints = require('./line_points');\nvar linkTraces = require('./link_traces');\nvar polygonTester = require('../../lib/polygon').tester;\n\nmodule.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {\n    var join, onComplete;\n\n    // If transition config is provided, then it is only a partial replot and traces not\n    // updated are removed.\n    var isFullReplot = !transitionOpts;\n    var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n    // Link traces so the z-order of fill layers is correct\n    var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);\n\n    join = scatterLayer.selectAll('g.trace')\n        .data(cdscatterSorted, function(d) { return d[0].trace.uid; });\n\n    // Append new traces:\n    join.enter().append('g')\n        .attr('class', function(d) {\n            return 'trace scatter trace' + d[0].trace.uid;\n        })\n        .style('stroke-miterlimit', 2);\n    join.order();\n\n    createFills(gd, join, plotinfo);\n\n    if(hasTransition) {\n        if(makeOnCompleteCallback) {\n            // If it was passed a callback to register completion, make a callback. If\n            // this is created, then it must be executed on completion, otherwise the\n            // pos-transition redraw will not execute:\n            onComplete = makeOnCompleteCallback();\n        }\n\n        var transition = d3.transition()\n            .duration(transitionOpts.duration)\n            .ease(transitionOpts.easing)\n            .each('end', function() {\n                onComplete && onComplete();\n            })\n            .each('interrupt', function() {\n                onComplete && onComplete();\n            });\n\n        transition.each(function() {\n            // Must run the selection again since otherwise enters/updates get grouped together\n            // and these get executed out of order. Except we need them in order!\n            scatterLayer.selectAll('g.trace').each(function(d, i) {\n                plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n            });\n        });\n    } else {\n        join.each(function(d, i) {\n            plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n        });\n    }\n\n    if(isFullReplot) {\n        join.exit().remove();\n    }\n\n    // remove paths that didn't get used\n    scatterLayer.selectAll('path:not([d])').remove();\n};\n\nfunction createFills(gd, traceJoin, plotinfo) {\n    traceJoin.each(function(d) {\n        var fills = ensureSingle(d3.select(this), 'g', 'fills');\n        Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);\n\n        var trace = d[0].trace;\n\n        var fillData = [];\n        if(trace._ownfill) fillData.push('_ownFill');\n        if(trace._nexttrace) fillData.push('_nextFill');\n\n        var fillJoin = fills.selectAll('g').data(fillData, identity);\n\n        fillJoin.enter().append('g');\n\n        fillJoin.exit()\n            .each(function(d) { trace[d] = null; })\n            .remove();\n\n        fillJoin.order().each(function(d) {\n            // make a path element inside the fill group, just so\n            // we can give it its own data later on and the group can\n            // keep its simple '_*Fill' data\n            trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');\n        });\n    });\n}\n\nfunction plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {\n    var i;\n\n    // Since this has been reorganized and we're executing this on individual traces,\n    // we need to pass it the full list of cdscatter as well as this trace's index (idx)\n    // since it does an internal n^2 loop over comparisons with other traces:\n    selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);\n\n    var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n    function transition(selection) {\n        return hasTransition ? selection.transition() : selection;\n    }\n\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var trace = cdscatter[0].trace;\n    var line = trace.line;\n    var tr = d3.select(element);\n\n    var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');\n    var lines = ensureSingle(tr, 'g', 'lines');\n    var points = ensureSingle(tr, 'g', 'points');\n    var text = ensureSingle(tr, 'g', 'text');\n\n    // error bars are at the bottom\n    Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);\n\n    if(trace.visible !== true) return;\n\n    transition(tr).style('opacity', trace.opacity);\n\n    // BUILD LINES AND FILLS\n    var ownFillEl3, tonext;\n    var ownFillDir = trace.fill.charAt(trace.fill.length - 1);\n    if(ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = '';\n\n    // store node for tweaking by selectPoints\n    cdscatter[0][plotinfo.isRangePlot ? 'nodeRangePlot3' : 'node3'] = tr;\n\n    var prevRevpath = '';\n    var prevPolygons = [];\n    var prevtrace = trace._prevtrace;\n\n    if(prevtrace) {\n        prevRevpath = prevtrace._prevRevpath || '';\n        tonext = prevtrace._nextFill;\n        prevPolygons = prevtrace._polygons;\n    }\n\n    var thispath;\n    var thisrevpath;\n    // fullpath is all paths for this curve, joined together straight\n    // across gaps, for filling\n    var fullpath = '';\n    // revpath is fullpath reversed, for fill-to-next\n    var revpath = '';\n    // functions for converting a point array to a path\n    var pathfn, revpathbase, revpathfn;\n    // variables used before and after the data join\n    var pt0, lastSegment, pt1, thisPolygons;\n\n    // initialize line join data / method\n    var segments = [];\n    var makeUpdate = Lib.noop;\n\n    ownFillEl3 = trace._ownFill;\n\n    if(subTypes.hasLines(trace) || trace.fill !== 'none') {\n        if(tonext) {\n            // This tells .style which trace to use for fill information:\n            tonext.datum(cdscatter);\n        }\n\n        if(['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {\n            pathfn = Drawing.steps(line.shape);\n            revpathbase = Drawing.steps(\n                line.shape.split('').reverse().join('')\n            );\n        } else if(line.shape === 'spline') {\n            pathfn = revpathbase = function(pts) {\n                var pLast = pts[pts.length - 1];\n                if(pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {\n                    // identical start and end points: treat it as a\n                    // closed curve so we don't get a kink\n                    return Drawing.smoothclosed(pts.slice(1), line.smoothing);\n                } else {\n                    return Drawing.smoothopen(pts, line.smoothing);\n                }\n            };\n        } else {\n            pathfn = revpathbase = function(pts) {\n                return 'M' + pts.join('L');\n            };\n        }\n\n        revpathfn = function(pts) {\n            // note: this is destructive (reverses pts in place) so can't use pts after this\n            return revpathbase(pts.reverse());\n        };\n\n        segments = linePoints(cdscatter, {\n            xaxis: xa,\n            yaxis: ya,\n            connectGaps: trace.connectgaps,\n            baseTolerance: Math.max(line.width || 1, 3) / 4,\n            shape: line.shape,\n            simplify: line.simplify,\n            fill: trace.fill\n        });\n\n        // since we already have the pixel segments here, use them to make\n        // polygons for hover on fill\n        // TODO: can we skip this if hoveron!=fills? That would mean we\n        // need to redraw when you change hoveron...\n        thisPolygons = trace._polygons = new Array(segments.length);\n        for(i = 0; i < segments.length; i++) {\n            trace._polygons[i] = polygonTester(segments[i]);\n        }\n\n        if(segments.length) {\n            pt0 = segments[0][0];\n            lastSegment = segments[segments.length - 1];\n            pt1 = lastSegment[lastSegment.length - 1];\n        }\n\n        makeUpdate = function(isEnter) {\n            return function(pts) {\n                thispath = pathfn(pts);\n                thisrevpath = revpathfn(pts);\n                if(!fullpath) {\n                    fullpath = thispath;\n                    revpath = thisrevpath;\n                } else if(ownFillDir) {\n                    fullpath += 'L' + thispath.substr(1);\n                    revpath = thisrevpath + ('L' + revpath.substr(1));\n                } else {\n                    fullpath += 'Z' + thispath;\n                    revpath = thisrevpath + 'Z' + revpath;\n                }\n\n                if(subTypes.hasLines(trace) && pts.length > 1) {\n                    var el = d3.select(this);\n\n                    // This makes the coloring work correctly:\n                    el.datum(cdscatter);\n\n                    if(isEnter) {\n                        transition(el.style('opacity', 0)\n                            .attr('d', thispath)\n                            .call(Drawing.lineGroupStyle))\n                                .style('opacity', 1);\n                    } else {\n                        var sel = transition(el);\n                        sel.attr('d', thispath);\n                        Drawing.singleLineStyle(cdscatter, sel);\n                    }\n                }\n            };\n        };\n    }\n\n    var lineJoin = lines.selectAll('.js-line').data(segments);\n\n    transition(lineJoin.exit())\n        .style('opacity', 0)\n        .remove();\n\n    lineJoin.each(makeUpdate(false));\n\n    lineJoin.enter().append('path')\n        .classed('js-line', true)\n        .style('vector-effect', 'non-scaling-stroke')\n        .call(Drawing.lineGroupStyle)\n        .each(makeUpdate(true));\n\n    Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);\n\n    function clearFill(selection) {\n        transition(selection).attr('d', 'M0,0Z');\n    }\n\n    if(segments.length) {\n        if(ownFillEl3) {\n            ownFillEl3.datum(cdscatter);\n            if(pt0 && pt1) {\n                if(ownFillDir) {\n                    if(ownFillDir === 'y') {\n                        pt0[1] = pt1[1] = ya.c2p(0, true);\n                    } else if(ownFillDir === 'x') {\n                        pt0[0] = pt1[0] = xa.c2p(0, true);\n                    }\n\n                    // fill to zero: full trace path, plus extension of\n                    // the endpoints to the appropriate axis\n                    // For the sake of animations, wrap the points around so that\n                    // the points on the axes are the first two points. Otherwise\n                    // animations get a little crazy if the number of points changes.\n                    transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1))\n                        .call(Drawing.singleFillStyle);\n                } else {\n                    // fill to self: just join the path to itself\n                    transition(ownFillEl3).attr('d', fullpath + 'Z')\n                        .call(Drawing.singleFillStyle);\n                }\n            }\n        } else if(tonext) {\n            if(trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {\n                // fill to next: full trace path, plus the previous path reversed\n                if(trace.fill === 'tonext') {\n                    // tonext: for use by concentric shapes, like manually constructed\n                    // contours, we just add the two paths closed on themselves.\n                    // This makes strange results if one path is *not* entirely\n                    // inside the other, but then that is a strange usage.\n                    transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z')\n                        .call(Drawing.singleFillStyle);\n                } else {\n                    // tonextx/y: for now just connect endpoints with lines. This is\n                    // the correct behavior if the endpoints are at the same value of\n                    // y/x, but if they *aren't*, we should ideally do more complicated\n                    // things depending on whether the new endpoint projects onto the\n                    // existing curve or off the end of it\n                    transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z')\n                        .call(Drawing.singleFillStyle);\n                }\n                trace._polygons = trace._polygons.concat(prevPolygons);\n            } else {\n                clearFill(tonext);\n                trace._polygons = null;\n            }\n        }\n        trace._prevRevpath = revpath;\n        trace._prevPolygons = thisPolygons;\n    } else {\n        if(ownFillEl3) clearFill(ownFillEl3);\n        else if(tonext) clearFill(tonext);\n        trace._polygons = trace._prevRevpath = trace._prevPolygons = null;\n    }\n\n\n    function visFilter(d) {\n        return d.filter(function(v) { return !v.gap && v.vis; });\n    }\n\n    function visFilterWithGaps(d) {\n        return d.filter(function(v) { return v.vis; });\n    }\n\n    function gapFilter(d) {\n        return d.filter(function(v) { return !v.gap; });\n    }\n\n    function keyFunc(d) {\n        return d.id;\n    }\n\n    // Returns a function if the trace is keyed, otherwise returns undefined\n    function getKeyFunc(trace) {\n        if(trace.ids) {\n            return keyFunc;\n        }\n    }\n\n    function hideFilter() {\n        return false;\n    }\n\n    function makePoints(points, text, cdscatter) {\n        var join, selection, hasNode;\n\n        var trace = cdscatter[0].trace;\n        var showMarkers = subTypes.hasMarkers(trace);\n        var showText = subTypes.hasText(trace);\n\n        var keyFunc = getKeyFunc(trace);\n        var markerFilter = hideFilter;\n        var textFilter = hideFilter;\n\n        if(showMarkers || showText) {\n            var showFilter = identity;\n            // if we're stacking, \"infer zero\" gap mode gets markers in the\n            // gap points - because we've inferred a zero there - but other\n            // modes (currently \"interpolate\", later \"interrupt\" hopefully)\n            // we don't draw generated markers\n            var stackGroup = trace.stackgroup;\n            var isInferZero = stackGroup && (\n                gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero');\n            if(trace.marker.maxdisplayed || trace._needsCull) {\n                showFilter = isInferZero ? visFilterWithGaps : visFilter;\n            } else if(stackGroup && !isInferZero) {\n                showFilter = gapFilter;\n            }\n\n            if(showMarkers) markerFilter = showFilter;\n            if(showText) textFilter = showFilter;\n        }\n\n        // marker points\n\n        selection = points.selectAll('path.point');\n\n        join = selection.data(markerFilter, keyFunc);\n\n        var enter = join.enter().append('path')\n            .classed('point', true);\n\n        if(hasTransition) {\n            enter\n                .call(Drawing.pointStyle, trace, gd)\n                .call(Drawing.translatePoints, xa, ya)\n                .style('opacity', 0)\n                .transition()\n                .style('opacity', 1);\n        }\n\n        join.order();\n\n        var styleFns;\n        if(showMarkers) {\n            styleFns = Drawing.makePointStyleFns(trace);\n        }\n\n        join.each(function(d) {\n            var el = d3.select(this);\n            var sel = transition(el);\n            hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n            if(hasNode) {\n                Drawing.singlePointStyle(d, sel, trace, styleFns, gd);\n\n                if(plotinfo.layerClipId) {\n                    Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);\n                }\n\n                if(trace.customdata) {\n                    el.classed('plotly-customdata', d.data !== null && d.data !== undefined);\n                }\n            } else {\n                sel.remove();\n            }\n        });\n\n        if(hasTransition) {\n            join.exit().transition()\n                .style('opacity', 0)\n                .remove();\n        } else {\n            join.exit().remove();\n        }\n\n        // text points\n        selection = text.selectAll('g');\n        join = selection.data(textFilter, keyFunc);\n\n        // each text needs to go in its own 'g' in case\n        // it gets converted to mathjax\n        join.enter().append('g').classed('textpoint', true).append('text');\n\n        join.order();\n\n        join.each(function(d) {\n            var g = d3.select(this);\n            var sel = transition(g.select('text'));\n            hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n            if(hasNode) {\n                if(plotinfo.layerClipId) {\n                    Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);\n                }\n            } else {\n                g.remove();\n            }\n        });\n\n        join.selectAll('text')\n            .call(Drawing.textPointStyle, trace, gd)\n            .each(function(d) {\n                // This just *has* to be totally custom becuase of SVG text positioning :(\n                // It's obviously copied from translatePoint; we just can't use that\n                var x = xa.c2p(d.x);\n                var y = ya.c2p(d.y);\n\n                d3.select(this).selectAll('tspan.line').each(function() {\n                    transition(d3.select(this)).attr({x: x, y: y});\n                });\n            });\n\n        join.exit().remove();\n    }\n\n    points.datum(cdscatter);\n    text.datum(cdscatter);\n    makePoints(points, text, cdscatter);\n\n    // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;\n    Drawing.setClipUrl(points, clipUrl, gd);\n    Drawing.setClipUrl(text, clipUrl, gd);\n}\n\nfunction selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));\n    var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));\n\n    var trace = cdscatter[0].trace;\n    if(!subTypes.hasMarkers(trace)) return;\n    // if marker.maxdisplayed is used, select a maximum of\n    // mnum markers to show, from the set that are in the viewport\n    var mnum = trace.marker.maxdisplayed;\n\n    // TODO: remove some as we get away from the viewport?\n    if(mnum === 0) return;\n\n    var cd = cdscatter.filter(function(v) {\n        return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];\n    });\n    var inc = Math.ceil(cd.length / mnum);\n    var tnum = 0;\n    cdscatterAll.forEach(function(cdj, j) {\n        var tracei = cdj[0].trace;\n        if(subTypes.hasMarkers(tracei) &&\n                tracei.marker.maxdisplayed > 0 && j < idx) {\n            tnum++;\n        }\n    });\n\n    // if multiple traces use maxdisplayed, stagger which markers we\n    // display this formula offsets successive traces by 1/3 of the\n    // increment, adding an extra small amount after each triplet so\n    // it's not quite periodic\n    var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);\n\n    // for error bars: save in cd which markers to show\n    // so we don't have to repeat this\n    cdscatter.forEach(function(v) { delete v.vis; });\n    cd.forEach(function(v, i) {\n        if(Math.round((i + i0) % inc) === 0) v.vis = true;\n    });\n}\n"]},"metadata":{},"sourceType":"script"}