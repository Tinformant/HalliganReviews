{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar boxCalc = require('../box/calc');\n\nvar helpers = require('./helpers');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function calc(gd, trace) {\n  var cd = boxCalc(gd, trace);\n  if (cd[0].t.empty) return cd;\n  var fullLayout = gd._fullLayout;\n  var valAxis = Axes.getFromId(gd, trace[trace.orientation === 'h' ? 'xaxis' : 'yaxis']);\n  var spanMin = Infinity;\n  var spanMax = -Infinity;\n  var maxKDE = 0;\n  var maxCount = 0;\n\n  for (var i = 0; i < cd.length; i++) {\n    var cdi = cd[i];\n    var vals = cdi.pts.map(helpers.extractVal);\n    var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);\n    var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);\n\n    if (cdi.min === cdi.max && bandwidth === 0) {\n      // if span is zero and bandwidth is zero, we want a violin with zero width\n      span = cdi.span = [cdi.min, cdi.max];\n      cdi.density = [{\n        v: 1,\n        t: span[0]\n      }];\n      cdi.bandwidth = bandwidth;\n      maxKDE = Math.max(maxKDE, 1);\n    } else {\n      // step that well covers the bandwidth and is multiple of span distance\n      var dist = span[1] - span[0];\n      var n = Math.ceil(dist / (bandwidth / 3));\n      var step = dist / n;\n\n      if (!isFinite(step) || !isFinite(n)) {\n        Lib.error('Something went wrong with computing the violin span');\n        cd[0].t.empty = true;\n        return cd;\n      }\n\n      var kde = helpers.makeKDE(cdi, trace, vals);\n      cdi.density = new Array(n);\n\n      for (var k = 0, t = span[0]; t < span[1] + step / 2; k++, t += step) {\n        var v = kde(t);\n        cdi.density[k] = {\n          v: v,\n          t: t\n        };\n        maxKDE = Math.max(maxKDE, v);\n      }\n    }\n\n    maxCount = Math.max(maxCount, vals.length);\n    spanMin = Math.min(spanMin, span[0]);\n    spanMax = Math.max(spanMax, span[1]);\n  }\n\n  var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], {\n    padded: true\n  });\n  trace._extremes[valAxis._id] = extremes;\n\n  if (trace.width) {\n    cd[0].t.maxKDE = maxKDE;\n  } else {\n    var violinScaleGroupStats = fullLayout._violinScaleGroupStats;\n    var scaleGroup = trace.scalegroup;\n    var groupStats = violinScaleGroupStats[scaleGroup];\n\n    if (groupStats) {\n      groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);\n      groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);\n    } else {\n      violinScaleGroupStats[scaleGroup] = {\n        maxKDE: maxKDE,\n        maxCount: maxCount\n      };\n    }\n  }\n\n  cd[0].t.labels.kde = Lib._(gd, 'kde:');\n  return cd;\n}; // Default to Silveman's rule of thumb\n// - https://stats.stackexchange.com/a/6671\n// - https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n// - https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py\n\n\nfunction silvermanRule(len, ssd, iqr) {\n  var a = Math.min(ssd, iqr / 1.349);\n  return 1.059 * a * Math.pow(len, -0.2);\n}\n\nfunction calcBandwidth(trace, cdi, vals) {\n  var span = cdi.max - cdi.min; // If span is zero\n\n  if (!span) {\n    if (trace.bandwidth) {\n      return trace.bandwidth;\n    } else {\n      // if span is zero and no bandwidth is specified\n      // it returns zero bandwidth which is a special case\n      return 0;\n    }\n  } // Limit how small the bandwidth can be.\n  //\n  // Silverman's rule of thumb can be \"very\" small\n  // when IQR does a poor job at describing the spread\n  // of the distribution.\n  // We also want to limit custom bandwidths\n  // to not blow up kde computations.\n\n\n  if (trace.bandwidth) {\n    return Math.max(trace.bandwidth, span / 1e4);\n  } else {\n    var len = vals.length;\n    var ssd = Lib.stdev(vals, len - 1, cdi.mean);\n    return Math.max(silvermanRule(len, ssd, cdi.q3 - cdi.q1), span / 100);\n  }\n}\n\nfunction calcSpan(trace, cdi, valAxis, bandwidth) {\n  var spanmode = trace.spanmode;\n  var spanIn = trace.span || [];\n  var spanTight = [cdi.min, cdi.max];\n  var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];\n  var spanOut;\n\n  function calcSpanItem(index) {\n    var s = spanIn[index];\n    var sc = valAxis.type === 'multicategory' ? valAxis.r2c(s) : valAxis.d2c(s, 0, trace[cdi.valLetter + 'calendar']);\n    return sc === BADNUM ? spanLoose[index] : sc;\n  }\n\n  if (spanmode === 'soft') {\n    spanOut = spanLoose;\n  } else if (spanmode === 'hard') {\n    spanOut = spanTight;\n  } else {\n    spanOut = [calcSpanItem(0), calcSpanItem(1)];\n  } // to reuse the equal-range-item block\n\n\n  var dummyAx = {\n    type: 'linear',\n    range: spanOut\n  };\n  Axes.setConvert(dummyAx);\n  dummyAx.cleanRange();\n  return spanOut;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/violin/calc.js"],"names":["Lib","require","Axes","boxCalc","helpers","BADNUM","module","exports","calc","gd","trace","cd","t","empty","fullLayout","_fullLayout","valAxis","getFromId","orientation","spanMin","Infinity","spanMax","maxKDE","maxCount","i","length","cdi","vals","pts","map","extractVal","bandwidth","calcBandwidth","span","calcSpan","min","max","density","v","Math","dist","n","ceil","step","isFinite","error","kde","makeKDE","Array","k","extremes","findExtremes","padded","_extremes","_id","width","violinScaleGroupStats","_violinScaleGroupStats","scaleGroup","scalegroup","groupStats","labels","_","silvermanRule","len","ssd","iqr","a","pow","stdev","mean","q3","q1","spanmode","spanIn","spanTight","spanLoose","spanOut","calcSpanItem","index","s","sc","type","r2c","d2c","valLetter","dummyAx","range","setConvert","cleanRange"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar boxCalc = require('../box/calc');\nvar helpers = require('./helpers');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function calc(gd, trace) {\n    var cd = boxCalc(gd, trace);\n\n    if(cd[0].t.empty) return cd;\n\n    var fullLayout = gd._fullLayout;\n    var valAxis = Axes.getFromId(\n        gd,\n        trace[trace.orientation === 'h' ? 'xaxis' : 'yaxis']\n    );\n\n    var spanMin = Infinity;\n    var spanMax = -Infinity;\n    var maxKDE = 0;\n    var maxCount = 0;\n\n    for(var i = 0; i < cd.length; i++) {\n        var cdi = cd[i];\n        var vals = cdi.pts.map(helpers.extractVal);\n\n        var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);\n        var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);\n\n        if(cdi.min === cdi.max && bandwidth === 0) {\n            // if span is zero and bandwidth is zero, we want a violin with zero width\n            span = cdi.span = [cdi.min, cdi.max];\n            cdi.density = [{v: 1, t: span[0]}];\n            cdi.bandwidth = bandwidth;\n            maxKDE = Math.max(maxKDE, 1);\n        } else {\n            // step that well covers the bandwidth and is multiple of span distance\n            var dist = span[1] - span[0];\n            var n = Math.ceil(dist / (bandwidth / 3));\n            var step = dist / n;\n\n            if(!isFinite(step) || !isFinite(n)) {\n                Lib.error('Something went wrong with computing the violin span');\n                cd[0].t.empty = true;\n                return cd;\n            }\n\n            var kde = helpers.makeKDE(cdi, trace, vals);\n            cdi.density = new Array(n);\n\n            for(var k = 0, t = span[0]; t < (span[1] + step / 2); k++, t += step) {\n                var v = kde(t);\n                cdi.density[k] = {v: v, t: t};\n                maxKDE = Math.max(maxKDE, v);\n            }\n        }\n\n        maxCount = Math.max(maxCount, vals.length);\n        spanMin = Math.min(spanMin, span[0]);\n        spanMax = Math.max(spanMax, span[1]);\n    }\n\n    var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], {padded: true});\n    trace._extremes[valAxis._id] = extremes;\n\n    if(trace.width) {\n        cd[0].t.maxKDE = maxKDE;\n    } else {\n        var violinScaleGroupStats = fullLayout._violinScaleGroupStats;\n        var scaleGroup = trace.scalegroup;\n        var groupStats = violinScaleGroupStats[scaleGroup];\n\n        if(groupStats) {\n            groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);\n            groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);\n        } else {\n            violinScaleGroupStats[scaleGroup] = {\n                maxKDE: maxKDE,\n                maxCount: maxCount\n            };\n        }\n    }\n\n    cd[0].t.labels.kde = Lib._(gd, 'kde:');\n\n    return cd;\n};\n\n// Default to Silveman's rule of thumb\n// - https://stats.stackexchange.com/a/6671\n// - https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n// - https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py\nfunction silvermanRule(len, ssd, iqr) {\n    var a = Math.min(ssd, iqr / 1.349);\n    return 1.059 * a * Math.pow(len, -0.2);\n}\n\nfunction calcBandwidth(trace, cdi, vals) {\n    var span = cdi.max - cdi.min;\n\n    // If span is zero\n    if(!span) {\n        if(trace.bandwidth) {\n            return trace.bandwidth;\n        } else {\n            // if span is zero and no bandwidth is specified\n            // it returns zero bandwidth which is a special case\n            return 0;\n        }\n    }\n\n    // Limit how small the bandwidth can be.\n    //\n    // Silverman's rule of thumb can be \"very\" small\n    // when IQR does a poor job at describing the spread\n    // of the distribution.\n    // We also want to limit custom bandwidths\n    // to not blow up kde computations.\n\n    if(trace.bandwidth) {\n        return Math.max(trace.bandwidth, span / 1e4);\n    } else {\n        var len = vals.length;\n        var ssd = Lib.stdev(vals, len - 1, cdi.mean);\n        return Math.max(\n            silvermanRule(len, ssd, cdi.q3 - cdi.q1),\n            span / 100\n        );\n    }\n}\n\nfunction calcSpan(trace, cdi, valAxis, bandwidth) {\n    var spanmode = trace.spanmode;\n    var spanIn = trace.span || [];\n    var spanTight = [cdi.min, cdi.max];\n    var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];\n    var spanOut;\n\n    function calcSpanItem(index) {\n        var s = spanIn[index];\n        var sc = valAxis.type === 'multicategory' ?\n            valAxis.r2c(s) :\n            valAxis.d2c(s, 0, trace[cdi.valLetter + 'calendar']);\n        return sc === BADNUM ? spanLoose[index] : sc;\n    }\n\n    if(spanmode === 'soft') {\n        spanOut = spanLoose;\n    } else if(spanmode === 'hard') {\n        spanOut = spanTight;\n    } else {\n        spanOut = [calcSpanItem(0), calcSpanItem(1)];\n    }\n\n    // to reuse the equal-range-item block\n    var dummyAx = {\n        type: 'linear',\n        range: spanOut\n    };\n    Axes.setConvert(dummyAx);\n    dummyAx.cleanRange();\n\n    return spanOut;\n}\n"]},"metadata":{},"sourceType":"script"}