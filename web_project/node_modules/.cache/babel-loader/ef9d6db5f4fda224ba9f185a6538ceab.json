{"ast":null,"code":"\"use strict\";\n\nmodule.exports = stronglyConnectedComponents;\n\nfunction stronglyConnectedComponents(adjList) {\n  var numVertices = adjList.length;\n  var index = new Array(numVertices);\n  var lowValue = new Array(numVertices);\n  var active = new Array(numVertices);\n  var child = new Array(numVertices);\n  var scc = new Array(numVertices);\n  var sccLinks = new Array(numVertices); //Initialize tables\n\n  for (var i = 0; i < numVertices; ++i) {\n    index[i] = -1;\n    lowValue[i] = 0;\n    active[i] = false;\n    child[i] = 0;\n    scc[i] = -1;\n    sccLinks[i] = [];\n  } // The strongConnect function\n\n\n  var count = 0;\n  var components = [];\n  var sccAdjList = [];\n\n  function strongConnect(v) {\n    // To avoid running out of stack space, this emulates the recursive behaviour of the normal algorithm, effectively using T as the call stack.\n    var S = [v],\n        T = [v];\n    index[v] = lowValue[v] = count;\n    active[v] = true;\n    count += 1;\n\n    while (T.length > 0) {\n      v = T[T.length - 1];\n      var e = adjList[v];\n\n      if (child[v] < e.length) {\n        // If we're not done iterating over the children, first try finishing that.\n        for (var i = child[v]; i < e.length; ++i) {\n          // Start where we left off.\n          var u = e[i];\n\n          if (index[u] < 0) {\n            index[u] = lowValue[u] = count;\n            active[u] = true;\n            count += 1;\n            S.push(u);\n            T.push(u);\n            break; // First recurse, then continue here (with the same child!).\n            // There is a slight change to Tarjan's algorithm here.\n            // Normally, after having recursed, we set lowValue like we do for an active child (although some variants of the algorithm do it slightly differently).\n            // Here, we only do so if the child we recursed on is still active.\n            // The reasoning is that if it is no longer active, it must have had a lowValue equal to its own index, which means that it is necessarily higher than our lowValue.\n          } else if (active[u]) {\n            lowValue[v] = Math.min(lowValue[v], lowValue[u]) | 0;\n          }\n\n          if (scc[u] >= 0) {\n            // Node v is not yet assigned an scc, but once it is that scc can apparently reach scc[u].\n            sccLinks[v].push(scc[u]);\n          }\n        }\n\n        child[v] = i; // Remember where we left off.\n      } else {\n        // If we're done iterating over the children, check whether we have an scc.\n        if (lowValue[v] === index[v]) {\n          // TODO: It /might/ be true that T is always a prefix of S (at this point!!!), and if so, this could be used here.\n          var component = [];\n          var links = [],\n              linkCount = 0;\n\n          for (var i = S.length - 1; i >= 0; --i) {\n            var w = S[i];\n            active[w] = false;\n            component.push(w);\n            links.push(sccLinks[w]);\n            linkCount += sccLinks[w].length;\n            scc[w] = components.length;\n\n            if (w === v) {\n              S.length = i;\n              break;\n            }\n          }\n\n          components.push(component);\n          var allLinks = new Array(linkCount);\n\n          for (var i = 0; i < links.length; i++) {\n            for (var j = 0; j < links[i].length; j++) {\n              allLinks[--linkCount] = links[i][j];\n            }\n          }\n\n          sccAdjList.push(allLinks);\n        }\n\n        T.pop(); // Now we're finished exploring this particular node (normally corresponds to the return statement)\n      }\n    }\n  } //Run strong connect starting from each vertex\n\n\n  for (var i = 0; i < numVertices; ++i) {\n    if (index[i] < 0) {\n      strongConnect(i);\n    }\n  } // Compact sccAdjList\n\n\n  var newE;\n\n  for (var i = 0; i < sccAdjList.length; i++) {\n    var e = sccAdjList[i];\n    if (e.length === 0) continue;\n    e.sort(function (a, b) {\n      return a - b;\n    });\n    newE = [e[0]];\n\n    for (var j = 1; j < e.length; j++) {\n      if (e[j] !== e[j - 1]) {\n        newE.push(e[j]);\n      }\n    }\n\n    sccAdjList[i] = newE;\n  }\n\n  return {\n    components: components,\n    adjacencyList: sccAdjList\n  };\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/strongly-connected-components/scc.js"],"names":["module","exports","stronglyConnectedComponents","adjList","numVertices","length","index","Array","lowValue","active","child","scc","sccLinks","i","count","components","sccAdjList","strongConnect","v","S","T","e","u","push","Math","min","component","links","linkCount","w","allLinks","j","pop","newE","sort","a","b","adjacencyList"],"mappings":"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","sourcesContent":["\"use strict\"\n\nmodule.exports = stronglyConnectedComponents\n\nfunction stronglyConnectedComponents(adjList) {\n  var numVertices = adjList.length;\n  var index = new Array(numVertices)\n  var lowValue = new Array(numVertices)\n  var active = new Array(numVertices)\n  var child = new Array(numVertices)\n  var scc = new Array(numVertices)\n  var sccLinks = new Array(numVertices)\n  \n  //Initialize tables\n  for(var i=0; i<numVertices; ++i) {\n    index[i] = -1\n    lowValue[i] = 0\n    active[i] = false\n    child[i] = 0\n    scc[i] = -1\n    sccLinks[i] = []\n  }\n\n  // The strongConnect function\n  var count = 0\n  var components = []\n  var sccAdjList = []\n\n  function strongConnect(v) {\n    // To avoid running out of stack space, this emulates the recursive behaviour of the normal algorithm, effectively using T as the call stack.\n    var S = [v], T = [v]\n    index[v] = lowValue[v] = count\n    active[v] = true\n    count += 1\n    while(T.length > 0) {\n      v = T[T.length-1]\n      var e = adjList[v]\n      if (child[v] < e.length) { // If we're not done iterating over the children, first try finishing that.\n        for(var i=child[v]; i<e.length; ++i) { // Start where we left off.\n          var u = e[i]\n          if(index[u] < 0) {\n            index[u] = lowValue[u] = count\n            active[u] = true\n            count += 1\n            S.push(u)\n            T.push(u)\n            break // First recurse, then continue here (with the same child!).\n            // There is a slight change to Tarjan's algorithm here.\n            // Normally, after having recursed, we set lowValue like we do for an active child (although some variants of the algorithm do it slightly differently).\n            // Here, we only do so if the child we recursed on is still active.\n            // The reasoning is that if it is no longer active, it must have had a lowValue equal to its own index, which means that it is necessarily higher than our lowValue.\n          } else if (active[u]) {\n            lowValue[v] = Math.min(lowValue[v], lowValue[u])|0\n          }\n          if (scc[u] >= 0) {\n            // Node v is not yet assigned an scc, but once it is that scc can apparently reach scc[u].\n            sccLinks[v].push(scc[u])\n          }\n        }\n        child[v] = i // Remember where we left off.\n      } else { // If we're done iterating over the children, check whether we have an scc.\n        if(lowValue[v] === index[v]) { // TODO: It /might/ be true that T is always a prefix of S (at this point!!!), and if so, this could be used here.\n          var component = []\n          var links = [], linkCount = 0\n          for(var i=S.length-1; i>=0; --i) {\n            var w = S[i]\n            active[w] = false\n            component.push(w)\n            links.push(sccLinks[w])\n            linkCount += sccLinks[w].length\n            scc[w] = components.length\n            if(w === v) {\n              S.length = i\n              break\n            }\n          }\n          components.push(component)\n          var allLinks = new Array(linkCount)\n          for(var i=0; i<links.length; i++) {\n            for(var j=0; j<links[i].length; j++) {\n              allLinks[--linkCount] = links[i][j]\n            }\n          }\n          sccAdjList.push(allLinks)\n        }\n        T.pop() // Now we're finished exploring this particular node (normally corresponds to the return statement)\n      }\n    }\n  }\n\n  //Run strong connect starting from each vertex\n  for(var i=0; i<numVertices; ++i) {\n    if(index[i] < 0) {\n      strongConnect(i)\n    }\n  }\n  \n  // Compact sccAdjList\n  var newE\n  for(var i=0; i<sccAdjList.length; i++) {\n    var e = sccAdjList[i]\n    if (e.length === 0) continue\n    e.sort(function (a,b) { return a-b; })\n    newE = [e[0]]\n    for(var j=1; j<e.length; j++) {\n      if (e[j] !== e[j-1]) {\n        newE.push(e[j])\n      }\n    }\n    sccAdjList[i] = newE\n  }  \n\n  return {components: components, adjacencyList: sccAdjList}\n}\n"]},"metadata":{},"sourceType":"script"}