{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plots = require('../../plots/plots');\n\nvar Fx = require('../../components/fx');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar uniformText = require('../bar/uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\n\nvar helpers = require('./helpers');\n\nvar eventData = require('./event_data');\n\nvar isValidTextValue = require('../../lib').isValidTextValue;\n\nfunction plot(gd, cdModule) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  clearMinTextSize('pie', fullLayout);\n  prerenderTitles(cdModule, gd);\n  layoutAreas(cdModule, gs);\n  var plotGroups = Lib.makeTraceGroups(fullLayout._pielayer, cdModule, 'trace').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    setCoords(cd); // TODO: miter might look better but can sometimes cause problems\n    // maybe miter with a small-ish stroke-miterlimit?\n\n    plotGroup.attr('stroke-linejoin', 'round');\n    plotGroup.each(function () {\n      var slices = d3.select(this).selectAll('g.slice').data(cd);\n      slices.enter().append('g').classed('slice', true);\n      slices.exit().remove();\n      var quadrants = [[[], []], // y<0: x<0, x>=0\n      [[], []] // y>=0: x<0, x>=0\n      ];\n      var hasOutsideText = false;\n      slices.each(function (pt, i) {\n        if (pt.hidden) {\n          d3.select(this).selectAll('path,g').remove();\n          return;\n        } // to have consistent event data compared to other traces\n\n\n        pt.pointNumber = pt.i;\n        pt.curveNumber = trace.index;\n        quadrants[pt.pxmid[1] < 0 ? 0 : 1][pt.pxmid[0] < 0 ? 0 : 1].push(pt);\n        var cx = cd0.cx;\n        var cy = cd0.cy;\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.selectAll('path.surface').data([pt]);\n        slicePath.enter().append('path').classed('surface', true).style({\n          'pointer-events': 'all'\n        });\n        sliceTop.call(attachFxHandlers, gd, cd);\n\n        if (trace.pull) {\n          var pull = +helpers.castOption(trace.pull, pt.pts) || 0;\n\n          if (pull > 0) {\n            cx += pull * pt.pxmid[0];\n            cy += pull * pt.pxmid[1];\n          }\n        }\n\n        pt.cxFinal = cx;\n        pt.cyFinal = cy;\n\n        function arc(start, finish, cw, scale) {\n          var dx = scale * (finish[0] - start[0]);\n          var dy = scale * (finish[1] - start[1]);\n          return 'a' + scale * cd0.r + ',' + scale * cd0.r + ' 0 ' + pt.largeArc + (cw ? ' 1 ' : ' 0 ') + dx + ',' + dy;\n        }\n\n        var hole = trace.hole;\n\n        if (pt.v === cd0.vTotal) {\n          // 100% fails bcs arc start and end are identical\n          var outerCircle = 'M' + (cx + pt.px0[0]) + ',' + (cy + pt.px0[1]) + arc(pt.px0, pt.pxmid, true, 1) + arc(pt.pxmid, pt.px0, true, 1) + 'Z';\n\n          if (hole) {\n            slicePath.attr('d', 'M' + (cx + hole * pt.px0[0]) + ',' + (cy + hole * pt.px0[1]) + arc(pt.px0, pt.pxmid, false, hole) + arc(pt.pxmid, pt.px0, false, hole) + 'Z' + outerCircle);\n          } else slicePath.attr('d', outerCircle);\n        } else {\n          var outerArc = arc(pt.px0, pt.px1, true, 1);\n\n          if (hole) {\n            var rim = 1 - hole;\n            slicePath.attr('d', 'M' + (cx + hole * pt.px1[0]) + ',' + (cy + hole * pt.px1[1]) + arc(pt.px1, pt.px0, false, hole) + 'l' + rim * pt.px0[0] + ',' + rim * pt.px0[1] + outerArc + 'Z');\n          } else {\n            slicePath.attr('d', 'M' + cx + ',' + cy + 'l' + pt.px0[0] + ',' + pt.px0[1] + outerArc + 'Z');\n          }\n        } // add text\n\n\n        formatSliceLabel(gd, pt, cd0);\n        var textPosition = helpers.castOption(trace.textposition, pt.pts);\n        var sliceTextGroup = sliceTop.selectAll('g.slicetext').data(pt.text && textPosition !== 'none' ? [0] : []);\n        sliceTextGroup.enter().append('g').classed('slicetext', true);\n        sliceTextGroup.exit().remove();\n        sliceTextGroup.each(function () {\n          var sliceText = Lib.ensureSingle(d3.select(this), 'text', '', function (s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n          });\n          var font = Lib.ensureUniformFontSize(gd, textPosition === 'outside' ? determineOutsideTextFont(trace, pt, fullLayout.font) : determineInsideTextFont(trace, pt, fullLayout.font));\n          sliceText.text(pt.text).attr({\n            'class': 'slicetext',\n            transform: '',\n            'text-anchor': 'middle'\n          }).call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd); // position the text relative to the slice\n\n          var textBB = Drawing.bBox(sliceText.node());\n          var transform;\n\n          if (textPosition === 'outside') {\n            transform = transformOutsideText(textBB, pt);\n          } else {\n            transform = transformInsideText(textBB, pt, cd0);\n\n            if (textPosition === 'auto' && transform.scale < 1) {\n              var newFont = Lib.ensureUniformFontSize(gd, trace.outsidetextfont);\n              sliceText.call(Drawing.font, newFont);\n              textBB = Drawing.bBox(sliceText.node());\n              transform = transformOutsideText(textBB, pt);\n            }\n          }\n\n          var textPosAngle = transform.textPosAngle;\n          var textXY = textPosAngle === undefined ? pt.pxmid : getCoords(cd0.r, textPosAngle);\n          transform.targetX = cx + textXY[0] * transform.rCenter + (transform.x || 0);\n          transform.targetY = cy + textXY[1] * transform.rCenter + (transform.y || 0);\n          computeTransform(transform, textBB); // save some stuff to use later ensure no labels overlap\n\n          if (transform.outside) {\n            var targetY = transform.targetY;\n            pt.yLabelMin = targetY - textBB.height / 2;\n            pt.yLabelMid = targetY;\n            pt.yLabelMax = targetY + textBB.height / 2;\n            pt.labelExtraX = 0;\n            pt.labelExtraY = 0;\n            hasOutsideText = true;\n          }\n\n          transform.fontSize = font.size;\n          recordMinTextSize(trace.type, transform, fullLayout);\n          cd[i].transform = transform;\n          sliceText.attr('transform', Lib.getTextTransform(transform));\n        });\n      }); // add the title\n\n      var titleTextGroup = d3.select(this).selectAll('g.titletext').data(trace.title.text ? [0] : []);\n      titleTextGroup.enter().append('g').classed('titletext', true);\n      titleTextGroup.exit().remove();\n      titleTextGroup.each(function () {\n        var titleText = Lib.ensureSingle(d3.select(this), 'text', '', function (s) {\n          // prohibit tex interpretation as above\n          s.attr('data-notex', 1);\n        });\n        var txt = trace.title.text;\n\n        if (trace._meta) {\n          txt = Lib.templateString(txt, trace._meta);\n        }\n\n        titleText.text(txt).attr({\n          'class': 'titletext',\n          transform: '',\n          'text-anchor': 'middle'\n        }).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);\n        var transform;\n\n        if (trace.title.position === 'middle center') {\n          transform = positionTitleInside(cd0);\n        } else {\n          transform = positionTitleOutside(cd0, gs);\n        }\n\n        titleText.attr('transform', 'translate(' + transform.x + ',' + transform.y + ')' + (transform.scale < 1 ? 'scale(' + transform.scale + ')' : '') + 'translate(' + transform.tx + ',' + transform.ty + ')');\n      }); // now make sure no labels overlap (at least within one pie)\n\n      if (hasOutsideText) scootLabels(quadrants, trace);\n      plotTextLines(slices, trace);\n\n      if (hasOutsideText && trace.automargin) {\n        // TODO if we ever want to improve perf,\n        // we could reuse the textBB computed above together\n        // with the sliceText transform info\n        var traceBbox = Drawing.bBox(plotGroup.node());\n        var domain = trace.domain;\n        var vpw = gs.w * (domain.x[1] - domain.x[0]);\n        var vph = gs.h * (domain.y[1] - domain.y[0]);\n        var xgap = (0.5 * vpw - cd0.r) / gs.w;\n        var ygap = (0.5 * vph - cd0.r) / gs.h;\n        Plots.autoMargin(gd, 'pie.' + trace.uid + '.automargin', {\n          xl: domain.x[0] - xgap,\n          xr: domain.x[1] + xgap,\n          yb: domain.y[0] - ygap,\n          yt: domain.y[1] + ygap,\n          l: Math.max(cd0.cx - cd0.r - traceBbox.left, 0),\n          r: Math.max(traceBbox.right - (cd0.cx + cd0.r), 0),\n          b: Math.max(traceBbox.bottom - (cd0.cy + cd0.r), 0),\n          t: Math.max(cd0.cy - cd0.r - traceBbox.top, 0),\n          pad: 5\n        });\n      }\n    });\n  }); // This is for a bug in Chrome (as of 2015-07-22, and does not affect FF)\n  // if insidetextfont and outsidetextfont are different sizes, sometimes the size\n  // of an \"em\" gets taken from the wrong element at first so lines are\n  // spaced wrong. You just have to tell it to try again later and it gets fixed.\n  // I have no idea why we haven't seen this in other contexts. Also, sometimes\n  // it gets the initial draw correct but on redraw it gets confused.\n\n  setTimeout(function () {\n    plotGroups.selectAll('tspan').each(function () {\n      var s = d3.select(this);\n      if (s.attr('dy')) s.attr('dy', s.attr('dy'));\n    });\n  }, 0);\n} // TODO add support for transition\n\n\nfunction plotTextLines(slices, trace) {\n  slices.each(function (pt) {\n    var sliceTop = d3.select(this);\n\n    if (!pt.labelExtraX && !pt.labelExtraY) {\n      sliceTop.select('path.textline').remove();\n      return;\n    } // first move the text to its new location\n\n\n    var sliceText = sliceTop.select('g.slicetext text');\n    pt.transform.targetX += pt.labelExtraX;\n    pt.transform.targetY += pt.labelExtraY;\n    sliceText.attr('transform', Lib.getTextTransform(pt.transform)); // then add a line to the new location\n\n    var lineStartX = pt.cxFinal + pt.pxmid[0];\n    var lineStartY = pt.cyFinal + pt.pxmid[1];\n    var textLinePath = 'M' + lineStartX + ',' + lineStartY;\n    var finalX = (pt.yLabelMax - pt.yLabelMin) * (pt.pxmid[0] < 0 ? -1 : 1) / 4;\n\n    if (pt.labelExtraX) {\n      var yFromX = pt.labelExtraX * pt.pxmid[1] / pt.pxmid[0];\n      var yNet = pt.yLabelMid + pt.labelExtraY - (pt.cyFinal + pt.pxmid[1]);\n\n      if (Math.abs(yFromX) > Math.abs(yNet)) {\n        textLinePath += 'l' + yNet * pt.pxmid[0] / pt.pxmid[1] + ',' + yNet + 'H' + (lineStartX + pt.labelExtraX + finalX);\n      } else {\n        textLinePath += 'l' + pt.labelExtraX + ',' + yFromX + 'v' + (yNet - yFromX) + 'h' + finalX;\n      }\n    } else {\n      textLinePath += 'V' + (pt.yLabelMid + pt.labelExtraY) + 'h' + finalX;\n    }\n\n    Lib.ensureSingle(sliceTop, 'path', 'textline').call(Color.stroke, trace.outsidetextfont.color).attr({\n      'stroke-width': Math.min(2, trace.outsidetextfont.size / 8),\n      d: textLinePath,\n      fill: 'none'\n    });\n  });\n}\n\nfunction attachFxHandlers(sliceTop, gd, cd) {\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var cx = cd0.cx;\n  var cy = cd0.cy; // hover state vars\n  // have we drawn a hover label, so it should be cleared later\n\n  if (!('_hasHoverLabel' in trace)) trace._hasHoverLabel = false; // have we emitted a hover event, so later an unhover event should be emitted\n  // note that click events do not depend on this - you can still get them\n  // with hovermode: false or if you were earlier dragging, then clicked\n  // in the same slice that you moused up in\n\n  if (!('_hasHoverEvent' in trace)) trace._hasHoverEvent = false;\n  sliceTop.on('mouseover', function (pt) {\n    // in case fullLayout or fullData has changed without a replot\n    var fullLayout2 = gd._fullLayout;\n    var trace2 = gd._fullData[trace.index];\n    if (gd._dragging || fullLayout2.hovermode === false) return;\n    var hoverinfo = trace2.hoverinfo;\n\n    if (Array.isArray(hoverinfo)) {\n      // super hacky: we need to pull out the *first* hoverinfo from\n      // pt.pts, then put it back into an array in a dummy trace\n      // and call castHoverinfo on that.\n      // TODO: do we want to have Fx.castHoverinfo somehow handle this?\n      // it already takes an array for index, for 2D, so this seems tricky.\n      hoverinfo = Fx.castHoverinfo({\n        hoverinfo: [helpers.castOption(hoverinfo, pt.pts)],\n        _module: trace._module\n      }, fullLayout2, 0);\n    }\n\n    if (hoverinfo === 'all') hoverinfo = 'label+text+value+percent+name'; // in case we dragged over the pie from another subplot,\n    // or if hover is turned off\n\n    if (trace2.hovertemplate || hoverinfo !== 'none' && hoverinfo !== 'skip' && hoverinfo) {\n      var rInscribed = pt.rInscribed || 0;\n      var hoverCenterX = cx + pt.pxmid[0] * (1 - rInscribed);\n      var hoverCenterY = cy + pt.pxmid[1] * (1 - rInscribed);\n      var separators = fullLayout2.separators;\n      var text = [];\n      if (hoverinfo && hoverinfo.indexOf('label') !== -1) text.push(pt.label);\n      pt.text = helpers.castOption(trace2.hovertext || trace2.text, pt.pts);\n\n      if (hoverinfo && hoverinfo.indexOf('text') !== -1) {\n        var tx = pt.text;\n        if (Lib.isValidTextValue(tx)) text.push(tx);\n      }\n\n      pt.value = pt.v;\n      pt.valueLabel = helpers.formatPieValue(pt.v, separators);\n      if (hoverinfo && hoverinfo.indexOf('value') !== -1) text.push(pt.valueLabel);\n      pt.percent = pt.v / cd0.vTotal;\n      pt.percentLabel = helpers.formatPiePercent(pt.percent, separators);\n      if (hoverinfo && hoverinfo.indexOf('percent') !== -1) text.push(pt.percentLabel);\n      var hoverLabel = trace2.hoverlabel;\n      var hoverFont = hoverLabel.font;\n      Fx.loneHover({\n        trace: trace,\n        x0: hoverCenterX - rInscribed * cd0.r,\n        x1: hoverCenterX + rInscribed * cd0.r,\n        y: hoverCenterY,\n        text: text.join('<br>'),\n        name: trace2.hovertemplate || hoverinfo.indexOf('name') !== -1 ? trace2.name : undefined,\n        idealAlign: pt.pxmid[0] < 0 ? 'left' : 'right',\n        color: helpers.castOption(hoverLabel.bgcolor, pt.pts) || pt.color,\n        borderColor: helpers.castOption(hoverLabel.bordercolor, pt.pts),\n        fontFamily: helpers.castOption(hoverFont.family, pt.pts),\n        fontSize: helpers.castOption(hoverFont.size, pt.pts),\n        fontColor: helpers.castOption(hoverFont.color, pt.pts),\n        nameLength: helpers.castOption(hoverLabel.namelength, pt.pts),\n        textAlign: helpers.castOption(hoverLabel.align, pt.pts),\n        hovertemplate: helpers.castOption(trace2.hovertemplate, pt.pts),\n        hovertemplateLabels: pt,\n        eventData: [eventData(pt, trace2)]\n      }, {\n        container: fullLayout2._hoverlayer.node(),\n        outerContainer: fullLayout2._paper.node(),\n        gd: gd\n      });\n      trace._hasHoverLabel = true;\n    }\n\n    trace._hasHoverEvent = true;\n    gd.emit('plotly_hover', {\n      points: [eventData(pt, trace2)],\n      event: d3.event\n    });\n  });\n  sliceTop.on('mouseout', function (evt) {\n    var fullLayout2 = gd._fullLayout;\n    var trace2 = gd._fullData[trace.index];\n    var pt = d3.select(this).datum();\n\n    if (trace._hasHoverEvent) {\n      evt.originalEvent = d3.event;\n      gd.emit('plotly_unhover', {\n        points: [eventData(pt, trace2)],\n        event: d3.event\n      });\n      trace._hasHoverEvent = false;\n    }\n\n    if (trace._hasHoverLabel) {\n      Fx.loneUnhover(fullLayout2._hoverlayer.node());\n      trace._hasHoverLabel = false;\n    }\n  });\n  sliceTop.on('click', function (pt) {\n    // TODO: this does not support right-click. If we want to support it, we\n    // would likely need to change pie to use dragElement instead of straight\n    // mapbox event binding. Or perhaps better, make a simple wrapper with the\n    // right mousedown, mousemove, and mouseup handlers just for a left/right click\n    // mapbox would use this too.\n    var fullLayout2 = gd._fullLayout;\n    var trace2 = gd._fullData[trace.index];\n    if (gd._dragging || fullLayout2.hovermode === false) return;\n    gd._hoverdata = [eventData(pt, trace2)];\n    Fx.click(gd, d3.event);\n  });\n}\n\nfunction determineOutsideTextFont(trace, pt, layoutFont) {\n  var color = helpers.castOption(trace.outsidetextfont.color, pt.pts) || helpers.castOption(trace.textfont.color, pt.pts) || layoutFont.color;\n  var family = helpers.castOption(trace.outsidetextfont.family, pt.pts) || helpers.castOption(trace.textfont.family, pt.pts) || layoutFont.family;\n  var size = helpers.castOption(trace.outsidetextfont.size, pt.pts) || helpers.castOption(trace.textfont.size, pt.pts) || layoutFont.size;\n  return {\n    color: color,\n    family: family,\n    size: size\n  };\n}\n\nfunction determineInsideTextFont(trace, pt, layoutFont) {\n  var customColor = helpers.castOption(trace.insidetextfont.color, pt.pts);\n\n  if (!customColor && trace._input.textfont) {\n    // Why not simply using trace.textfont? Because if not set, it\n    // defaults to layout.font which has a default color. But if\n    // textfont.color and insidetextfont.color don't supply a value,\n    // a contrasting color shall be used.\n    customColor = helpers.castOption(trace._input.textfont.color, pt.pts);\n  }\n\n  var family = helpers.castOption(trace.insidetextfont.family, pt.pts) || helpers.castOption(trace.textfont.family, pt.pts) || layoutFont.family;\n  var size = helpers.castOption(trace.insidetextfont.size, pt.pts) || helpers.castOption(trace.textfont.size, pt.pts) || layoutFont.size;\n  return {\n    color: customColor || Color.contrast(pt.color),\n    family: family,\n    size: size\n  };\n}\n\nfunction prerenderTitles(cdModule, gd) {\n  var cd0, trace; // Determine the width and height of the title for each pie.\n\n  for (var i = 0; i < cdModule.length; i++) {\n    cd0 = cdModule[i][0];\n    trace = cd0.trace;\n\n    if (trace.title.text) {\n      var txt = trace.title.text;\n\n      if (trace._meta) {\n        txt = Lib.templateString(txt, trace._meta);\n      }\n\n      var dummyTitle = Drawing.tester.append('text').attr('data-notex', 1).text(txt).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);\n      var bBox = Drawing.bBox(dummyTitle.node(), true);\n      cd0.titleBox = {\n        width: bBox.width,\n        height: bBox.height\n      };\n      dummyTitle.remove();\n    }\n  }\n}\n\nfunction transformInsideText(textBB, pt, cd0) {\n  var r = cd0.r || pt.rpx1;\n  var rInscribed = pt.rInscribed;\n  var isEmpty = pt.startangle === pt.stopangle;\n\n  if (isEmpty) {\n    return {\n      rCenter: 1 - rInscribed,\n      scale: 0,\n      rotate: 0,\n      textPosAngle: 0\n    };\n  }\n\n  var ring = pt.ring;\n  var isCircle = ring === 1 && Math.abs(pt.startangle - pt.stopangle) === Math.PI * 2;\n  var halfAngle = pt.halfangle;\n  var midAngle = pt.midangle;\n  var orientation = cd0.trace.insidetextorientation;\n  var isHorizontal = orientation === 'horizontal';\n  var isTangential = orientation === 'tangential';\n  var isRadial = orientation === 'radial';\n  var isAuto = orientation === 'auto';\n  var allTransforms = [];\n  var newT;\n\n  if (!isAuto) {\n    // max size if text is placed (horizontally) at the top or bottom of the arc\n    var considerCrossing = function (angle, key) {\n      if (isCrossing(pt, angle)) {\n        var dStart = Math.abs(angle - pt.startangle);\n        var dStop = Math.abs(angle - pt.stopangle);\n        var closestEdge = dStart < dStop ? dStart : dStop;\n\n        if (key === 'tan') {\n          newT = calcTanTransform(textBB, r, ring, closestEdge, 0);\n        } else {\n          // case of 'rad'\n          newT = calcRadTransform(textBB, r, ring, closestEdge, Math.PI / 2);\n        }\n\n        newT.textPosAngle = angle;\n        allTransforms.push(newT);\n      }\n    }; // to cover all cases with trace.rotation added\n\n\n    var i;\n\n    if (isHorizontal || isTangential) {\n      // top\n      for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * i, 'tan'); // bottom\n\n\n      for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 1), 'tan');\n    }\n\n    if (isHorizontal || isRadial) {\n      // left\n      for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 1.5), 'rad'); // right\n\n\n      for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 0.5), 'rad');\n    }\n  }\n\n  if (isCircle || isAuto || isHorizontal) {\n    // max size text can be inserted inside without rotating it\n    // this inscribes the text rectangle in a circle, which is then inscribed\n    // in the slice, so it will be an underestimate, which some day we may want\n    // to improve so this case can get more use\n    var textDiameter = Math.sqrt(textBB.width * textBB.width + textBB.height * textBB.height);\n    newT = {\n      scale: rInscribed * r * 2 / textDiameter,\n      // and the center position and rotation in this case\n      rCenter: 1 - rInscribed,\n      rotate: 0\n    };\n    newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;\n    if (newT.scale >= 1) return newT;\n    allTransforms.push(newT);\n  }\n\n  if (isAuto || isRadial) {\n    newT = calcRadTransform(textBB, r, ring, halfAngle, midAngle);\n    newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;\n    allTransforms.push(newT);\n  }\n\n  if (isAuto || isTangential) {\n    newT = calcTanTransform(textBB, r, ring, halfAngle, midAngle);\n    newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;\n    allTransforms.push(newT);\n  }\n\n  var id = 0;\n  var maxScale = 0;\n\n  for (var k = 0; k < allTransforms.length; k++) {\n    var s = allTransforms[k].scale;\n\n    if (maxScale < s) {\n      maxScale = s;\n      id = k;\n    }\n\n    if (!isAuto && maxScale >= 1) {\n      // respect test order for non-auto options\n      break;\n    }\n  }\n\n  return allTransforms[id];\n}\n\nfunction isCrossing(pt, angle) {\n  var start = pt.startangle;\n  var stop = pt.stopangle;\n  return start > angle && angle > stop || start < angle && angle < stop;\n}\n\nfunction calcRadTransform(textBB, r, ring, halfAngle, midAngle) {\n  r = Math.max(0, r - 2 * TEXTPAD); // max size if text is rotated radially\n\n  var a = textBB.width / textBB.height;\n  var s = calcMaxHalfSize(a, halfAngle, r, ring);\n  return {\n    scale: s * 2 / textBB.height,\n    rCenter: calcRCenter(a, s / r),\n    rotate: calcRotate(midAngle)\n  };\n}\n\nfunction calcTanTransform(textBB, r, ring, halfAngle, midAngle) {\n  r = Math.max(0, r - 2 * TEXTPAD); // max size if text is rotated tangentially\n\n  var a = textBB.height / textBB.width;\n  var s = calcMaxHalfSize(a, halfAngle, r, ring);\n  return {\n    scale: s * 2 / textBB.width,\n    rCenter: calcRCenter(a, s / r),\n    rotate: calcRotate(midAngle + Math.PI / 2)\n  };\n}\n\nfunction calcRCenter(a, b) {\n  return Math.cos(b) - a * b;\n}\n\nfunction calcRotate(t) {\n  return (180 / Math.PI * t + 720) % 180 - 90;\n}\n\nfunction calcMaxHalfSize(a, halfAngle, r, ring) {\n  var q = a + 1 / (2 * Math.tan(halfAngle));\n  return r * Math.min(1 / (Math.sqrt(q * q + 0.5) + q), ring / (Math.sqrt(a * a + ring / 2) + a));\n}\n\nfunction getInscribedRadiusFraction(pt, cd0) {\n  if (pt.v === cd0.vTotal && !cd0.trace.hole) return 1; // special case of 100% with no hole\n\n  return Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2);\n}\n\nfunction transformOutsideText(textBB, pt) {\n  var x = pt.pxmid[0];\n  var y = pt.pxmid[1];\n  var dx = textBB.width / 2;\n  var dy = textBB.height / 2;\n  if (x < 0) dx *= -1;\n  if (y < 0) dy *= -1;\n  return {\n    scale: 1,\n    rCenter: 1,\n    rotate: 0,\n    x: dx + Math.abs(dy) * (dx > 0 ? 1 : -1) / 2,\n    y: dy / (1 + x * x / (y * y)),\n    outside: true\n  };\n}\n\nfunction positionTitleInside(cd0) {\n  var textDiameter = Math.sqrt(cd0.titleBox.width * cd0.titleBox.width + cd0.titleBox.height * cd0.titleBox.height);\n  return {\n    x: cd0.cx,\n    y: cd0.cy,\n    scale: cd0.trace.hole * cd0.r * 2 / textDiameter,\n    tx: 0,\n    ty: -cd0.titleBox.height / 2 + cd0.trace.title.font.size\n  };\n}\n\nfunction positionTitleOutside(cd0, plotSize) {\n  var scaleX = 1;\n  var scaleY = 1;\n  var maxPull;\n  var trace = cd0.trace; // position of the baseline point of the text box in the plot, before scaling.\n  // we anchored the text in the middle, so the baseline is on the bottom middle\n  // of the first line of text.\n\n  var topMiddle = {\n    x: cd0.cx,\n    y: cd0.cy\n  }; // relative translation of the text box after scaling\n\n  var translate = {\n    tx: 0,\n    ty: 0\n  }; // we reason below as if the baseline is the top middle point of the text box.\n  // so we must add the font size to approximate the y-coord. of the top.\n  // note that this correction must happen after scaling.\n\n  translate.ty += trace.title.font.size;\n  maxPull = getMaxPull(trace);\n\n  if (trace.title.position.indexOf('top') !== -1) {\n    topMiddle.y -= (1 + maxPull) * cd0.r;\n    translate.ty -= cd0.titleBox.height;\n  } else if (trace.title.position.indexOf('bottom') !== -1) {\n    topMiddle.y += (1 + maxPull) * cd0.r;\n  }\n\n  var rx = applyAspectRatio(cd0.r, cd0.trace.aspectratio);\n  var maxWidth = plotSize.w * (trace.domain.x[1] - trace.domain.x[0]) / 2;\n\n  if (trace.title.position.indexOf('left') !== -1) {\n    // we start the text at the left edge of the pie\n    maxWidth = maxWidth + rx;\n    topMiddle.x -= (1 + maxPull) * rx;\n    translate.tx += cd0.titleBox.width / 2;\n  } else if (trace.title.position.indexOf('center') !== -1) {\n    maxWidth *= 2;\n  } else if (trace.title.position.indexOf('right') !== -1) {\n    maxWidth = maxWidth + rx;\n    topMiddle.x += (1 + maxPull) * rx;\n    translate.tx -= cd0.titleBox.width / 2;\n  }\n\n  scaleX = maxWidth / cd0.titleBox.width;\n  scaleY = getTitleSpace(cd0, plotSize) / cd0.titleBox.height;\n  return {\n    x: topMiddle.x,\n    y: topMiddle.y,\n    scale: Math.min(scaleX, scaleY),\n    tx: translate.tx,\n    ty: translate.ty\n  };\n}\n\nfunction applyAspectRatio(x, aspectratio) {\n  return x / (aspectratio === undefined ? 1 : aspectratio);\n}\n\nfunction getTitleSpace(cd0, plotSize) {\n  var trace = cd0.trace;\n  var pieBoxHeight = plotSize.h * (trace.domain.y[1] - trace.domain.y[0]); // use at most half of the plot for the title\n\n  return Math.min(cd0.titleBox.height, pieBoxHeight / 2);\n}\n\nfunction getMaxPull(trace) {\n  var maxPull = trace.pull;\n  if (!maxPull) return 0;\n  var j;\n\n  if (Array.isArray(maxPull)) {\n    maxPull = 0;\n\n    for (j = 0; j < trace.pull.length; j++) {\n      if (trace.pull[j] > maxPull) maxPull = trace.pull[j];\n    }\n  }\n\n  return maxPull;\n}\n\nfunction scootLabels(quadrants, trace) {\n  var xHalf, yHalf, equatorFirst, farthestX, farthestY, xDiffSign, yDiffSign, thisQuad, oppositeQuad, wholeSide, i, thisQuadOutside, firstOppositeOutsidePt;\n\n  function topFirst(a, b) {\n    return a.pxmid[1] - b.pxmid[1];\n  }\n\n  function bottomFirst(a, b) {\n    return b.pxmid[1] - a.pxmid[1];\n  }\n\n  function scootOneLabel(thisPt, prevPt) {\n    if (!prevPt) prevPt = {};\n    var prevOuterY = prevPt.labelExtraY + (yHalf ? prevPt.yLabelMax : prevPt.yLabelMin);\n    var thisInnerY = yHalf ? thisPt.yLabelMin : thisPt.yLabelMax;\n    var thisOuterY = yHalf ? thisPt.yLabelMax : thisPt.yLabelMin;\n    var thisSliceOuterY = thisPt.cyFinal + farthestY(thisPt.px0[1], thisPt.px1[1]);\n    var newExtraY = prevOuterY - thisInnerY;\n    var xBuffer, i, otherPt, otherOuterY, otherOuterX, newExtraX; // make sure this label doesn't overlap other labels\n    // this *only* has us move these labels vertically\n\n    if (newExtraY * yDiffSign > 0) thisPt.labelExtraY = newExtraY; // make sure this label doesn't overlap any slices\n\n    if (!Array.isArray(trace.pull)) return; // this can only happen with array pulls\n\n    for (i = 0; i < wholeSide.length; i++) {\n      otherPt = wholeSide[i]; // overlap can only happen if the other point is pulled more than this one\n\n      if (otherPt === thisPt || (helpers.castOption(trace.pull, thisPt.pts) || 0) >= (helpers.castOption(trace.pull, otherPt.pts) || 0)) {\n        continue;\n      }\n\n      if ((thisPt.pxmid[1] - otherPt.pxmid[1]) * yDiffSign > 0) {\n        // closer to the equator - by construction all of these happen first\n        // move the text vertically to get away from these slices\n        otherOuterY = otherPt.cyFinal + farthestY(otherPt.px0[1], otherPt.px1[1]);\n        newExtraY = otherOuterY - thisInnerY - thisPt.labelExtraY;\n        if (newExtraY * yDiffSign > 0) thisPt.labelExtraY += newExtraY;\n      } else if ((thisOuterY + thisPt.labelExtraY - thisSliceOuterY) * yDiffSign > 0) {\n        // farther from the equator - happens after we've done all the\n        // vertical moving we're going to do\n        // move horizontally to get away from these more polar slices\n        // if we're moving horz. based on a slice that's several slices away from this one\n        // then we need some extra space for the lines to labels between them\n        xBuffer = 3 * xDiffSign * Math.abs(i - wholeSide.indexOf(thisPt));\n        otherOuterX = otherPt.cxFinal + farthestX(otherPt.px0[0], otherPt.px1[0]);\n        newExtraX = otherOuterX + xBuffer - (thisPt.cxFinal + thisPt.pxmid[0]) - thisPt.labelExtraX;\n        if (newExtraX * xDiffSign > 0) thisPt.labelExtraX += newExtraX;\n      }\n    }\n  }\n\n  for (yHalf = 0; yHalf < 2; yHalf++) {\n    equatorFirst = yHalf ? topFirst : bottomFirst;\n    farthestY = yHalf ? Math.max : Math.min;\n    yDiffSign = yHalf ? 1 : -1;\n\n    for (xHalf = 0; xHalf < 2; xHalf++) {\n      farthestX = xHalf ? Math.max : Math.min;\n      xDiffSign = xHalf ? 1 : -1; // first sort the array\n      // note this is a copy of cd, so cd itself doesn't get sorted\n      // but we can still modify points in place.\n\n      thisQuad = quadrants[yHalf][xHalf];\n      thisQuad.sort(equatorFirst);\n      oppositeQuad = quadrants[1 - yHalf][xHalf];\n      wholeSide = oppositeQuad.concat(thisQuad);\n      thisQuadOutside = [];\n\n      for (i = 0; i < thisQuad.length; i++) {\n        if (thisQuad[i].yLabelMid !== undefined) thisQuadOutside.push(thisQuad[i]);\n      }\n\n      firstOppositeOutsidePt = false;\n\n      for (i = 0; yHalf && i < oppositeQuad.length; i++) {\n        if (oppositeQuad[i].yLabelMid !== undefined) {\n          firstOppositeOutsidePt = oppositeQuad[i];\n          break;\n        }\n      } // each needs to avoid the previous\n\n\n      for (i = 0; i < thisQuadOutside.length; i++) {\n        var prevPt = i && thisQuadOutside[i - 1]; // bottom half needs to avoid the first label of the top half\n        // top half we still need to call scootOneLabel on the first slice\n        // so we can avoid other slices, but we don't pass a prevPt\n\n        if (firstOppositeOutsidePt && !i) prevPt = firstOppositeOutsidePt;\n        scootOneLabel(thisQuadOutside[i], prevPt);\n      }\n    }\n  }\n}\n\nfunction layoutAreas(cdModule, plotSize) {\n  var scaleGroups = []; // figure out the center and maximum radius\n\n  for (var i = 0; i < cdModule.length; i++) {\n    var cd0 = cdModule[i][0];\n    var trace = cd0.trace;\n    var domain = trace.domain;\n    var width = plotSize.w * (domain.x[1] - domain.x[0]);\n    var height = plotSize.h * (domain.y[1] - domain.y[0]); // leave some space for the title, if it will be displayed outside\n\n    if (trace.title.text && trace.title.position !== 'middle center') {\n      height -= getTitleSpace(cd0, plotSize);\n    }\n\n    var rx = width / 2;\n    var ry = height / 2;\n\n    if (trace.type === 'funnelarea' && !trace.scalegroup) {\n      ry /= trace.aspectratio;\n    }\n\n    cd0.r = Math.min(rx, ry) / (1 + getMaxPull(trace));\n    cd0.cx = plotSize.l + plotSize.w * (trace.domain.x[1] + trace.domain.x[0]) / 2;\n    cd0.cy = plotSize.t + plotSize.h * (1 - trace.domain.y[0]) - height / 2;\n\n    if (trace.title.text && trace.title.position.indexOf('bottom') !== -1) {\n      cd0.cy -= getTitleSpace(cd0, plotSize);\n    }\n\n    if (trace.scalegroup && scaleGroups.indexOf(trace.scalegroup) === -1) {\n      scaleGroups.push(trace.scalegroup);\n    }\n  }\n\n  groupScale(cdModule, scaleGroups);\n}\n\nfunction groupScale(cdModule, scaleGroups) {\n  var cd0, i, trace; // scale those that are grouped\n\n  for (var k = 0; k < scaleGroups.length; k++) {\n    var min = Infinity;\n    var g = scaleGroups[k];\n\n    for (i = 0; i < cdModule.length; i++) {\n      cd0 = cdModule[i][0];\n      trace = cd0.trace;\n\n      if (trace.scalegroup === g) {\n        var area;\n\n        if (trace.type === 'pie') {\n          area = cd0.r * cd0.r;\n        } else if (trace.type === 'funnelarea') {\n          var rx, ry;\n\n          if (trace.aspectratio > 1) {\n            rx = cd0.r;\n            ry = rx / trace.aspectratio;\n          } else {\n            ry = cd0.r;\n            rx = ry * trace.aspectratio;\n          }\n\n          rx *= (1 + trace.baseratio) / 2;\n          area = rx * ry;\n        }\n\n        min = Math.min(min, area / cd0.vTotal);\n      }\n    }\n\n    for (i = 0; i < cdModule.length; i++) {\n      cd0 = cdModule[i][0];\n      trace = cd0.trace;\n\n      if (trace.scalegroup === g) {\n        var v = min * cd0.vTotal;\n\n        if (trace.type === 'funnelarea') {\n          v /= (1 + trace.baseratio) / 2;\n          v /= trace.aspectratio;\n        }\n\n        cd0.r = Math.sqrt(v);\n      }\n    }\n  }\n}\n\nfunction setCoords(cd) {\n  var cd0 = cd[0];\n  var r = cd0.r;\n  var trace = cd0.trace;\n  var currentAngle = trace.rotation * Math.PI / 180;\n  var angleFactor = 2 * Math.PI / cd0.vTotal;\n  var firstPt = 'px0';\n  var lastPt = 'px1';\n  var i, cdi, currentCoords;\n\n  if (trace.direction === 'counterclockwise') {\n    for (i = 0; i < cd.length; i++) {\n      if (!cd[i].hidden) break; // find the first non-hidden slice\n    }\n\n    if (i === cd.length) return; // all slices hidden\n\n    currentAngle += angleFactor * cd[i].v;\n    angleFactor *= -1;\n    firstPt = 'px1';\n    lastPt = 'px0';\n  }\n\n  currentCoords = getCoords(r, currentAngle);\n\n  for (i = 0; i < cd.length; i++) {\n    cdi = cd[i];\n    if (cdi.hidden) continue;\n    cdi[firstPt] = currentCoords;\n    cdi.startangle = currentAngle;\n    currentAngle += angleFactor * cdi.v / 2;\n    cdi.pxmid = getCoords(r, currentAngle);\n    cdi.midangle = currentAngle;\n    currentAngle += angleFactor * cdi.v / 2;\n    currentCoords = getCoords(r, currentAngle);\n    cdi.stopangle = currentAngle;\n    cdi[lastPt] = currentCoords;\n    cdi.largeArc = cdi.v > cd0.vTotal / 2 ? 1 : 0;\n    cdi.halfangle = Math.PI * Math.min(cdi.v / cd0.vTotal, 0.5);\n    cdi.ring = 1 - trace.hole;\n    cdi.rInscribed = getInscribedRadiusFraction(cdi, cd0);\n  }\n}\n\nfunction getCoords(r, angle) {\n  return [r * Math.sin(angle), -r * Math.cos(angle)];\n}\n\nfunction formatSliceLabel(gd, pt, cd0) {\n  var fullLayout = gd._fullLayout;\n  var trace = cd0.trace; // look for textemplate\n\n  var texttemplate = trace.texttemplate; // now insert text\n\n  var textinfo = trace.textinfo;\n\n  if (!texttemplate && textinfo && textinfo !== 'none') {\n    var parts = textinfo.split('+');\n\n    var hasFlag = function (flag) {\n      return parts.indexOf(flag) !== -1;\n    };\n\n    var hasLabel = hasFlag('label');\n    var hasText = hasFlag('text');\n    var hasValue = hasFlag('value');\n    var hasPercent = hasFlag('percent');\n    var separators = fullLayout.separators;\n    var text;\n    text = hasLabel ? [pt.label] : [];\n\n    if (hasText) {\n      var tx = helpers.getFirstFilled(trace.text, pt.pts);\n      if (isValidTextValue(tx)) text.push(tx);\n    }\n\n    if (hasValue) text.push(helpers.formatPieValue(pt.v, separators));\n    if (hasPercent) text.push(helpers.formatPiePercent(pt.v / cd0.vTotal, separators));\n    pt.text = text.join('<br>');\n  }\n\n  function makeTemplateVariables(pt) {\n    return {\n      label: pt.label,\n      value: pt.v,\n      valueLabel: helpers.formatPieValue(pt.v, fullLayout.separators),\n      percent: pt.v / cd0.vTotal,\n      percentLabel: helpers.formatPiePercent(pt.v / cd0.vTotal, fullLayout.separators),\n      color: pt.color,\n      text: pt.text,\n      customdata: Lib.castOption(trace, pt.i, 'customdata')\n    };\n  }\n\n  if (texttemplate) {\n    var txt = Lib.castOption(trace, pt.i, 'texttemplate');\n\n    if (!txt) {\n      pt.text = '';\n    } else {\n      var obj = makeTemplateVariables(pt);\n      var ptTx = helpers.getFirstFilled(trace.text, pt.pts);\n      if (isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n      pt.text = Lib.texttemplateString(txt, obj, gd._fullLayout._d3locale, obj, trace._meta || {});\n    }\n  }\n}\n\nfunction computeTransform(transform, // inout\ntextBB // in\n) {\n  var a = transform.rotate * Math.PI / 180;\n  var cosA = Math.cos(a);\n  var sinA = Math.sin(a);\n  var midX = (textBB.left + textBB.right) / 2;\n  var midY = (textBB.top + textBB.bottom) / 2;\n  transform.textX = midX * cosA - midY * sinA;\n  transform.textY = midX * sinA + midY * cosA;\n  transform.noCenter = true;\n}\n\nmodule.exports = {\n  plot: plot,\n  formatSliceLabel: formatSliceLabel,\n  transformInsideText: transformInsideText,\n  determineInsideTextFont: determineInsideTextFont,\n  positionTitleOutside: positionTitleOutside,\n  prerenderTitles: prerenderTitles,\n  layoutAreas: layoutAreas,\n  attachFxHandlers: attachFxHandlers,\n  computeTransform: computeTransform\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/pie/plot.js"],"names":["d3","require","Plots","Fx","Color","Drawing","Lib","svgTextUtils","uniformText","recordMinTextSize","clearMinTextSize","TEXTPAD","helpers","eventData","isValidTextValue","plot","gd","cdModule","fullLayout","_fullLayout","gs","_size","prerenderTitles","layoutAreas","plotGroups","makeTraceGroups","_pielayer","each","cd","plotGroup","select","cd0","trace","setCoords","attr","slices","selectAll","data","enter","append","classed","exit","remove","quadrants","hasOutsideText","pt","i","hidden","pointNumber","curveNumber","index","pxmid","push","cx","cy","sliceTop","slicePath","style","call","attachFxHandlers","pull","castOption","pts","cxFinal","cyFinal","arc","start","finish","cw","scale","dx","dy","r","largeArc","hole","v","vTotal","outerCircle","px0","outerArc","px1","rim","formatSliceLabel","textPosition","textposition","sliceTextGroup","text","sliceText","ensureSingle","s","font","ensureUniformFontSize","determineOutsideTextFont","determineInsideTextFont","transform","convertToTspans","textBB","bBox","node","transformOutsideText","transformInsideText","newFont","outsidetextfont","textPosAngle","textXY","undefined","getCoords","targetX","rCenter","x","targetY","y","computeTransform","outside","yLabelMin","height","yLabelMid","yLabelMax","labelExtraX","labelExtraY","fontSize","size","type","getTextTransform","titleTextGroup","title","titleText","txt","_meta","templateString","position","positionTitleInside","positionTitleOutside","tx","ty","scootLabels","plotTextLines","automargin","traceBbox","domain","vpw","w","vph","h","xgap","ygap","autoMargin","uid","xl","xr","yb","yt","l","Math","max","left","right","b","bottom","t","top","pad","setTimeout","lineStartX","lineStartY","textLinePath","finalX","yFromX","yNet","abs","stroke","color","min","d","fill","_hasHoverLabel","_hasHoverEvent","on","fullLayout2","trace2","_fullData","_dragging","hovermode","hoverinfo","Array","isArray","castHoverinfo","_module","hovertemplate","rInscribed","hoverCenterX","hoverCenterY","separators","indexOf","label","hovertext","value","valueLabel","formatPieValue","percent","percentLabel","formatPiePercent","hoverLabel","hoverlabel","hoverFont","loneHover","x0","x1","join","name","idealAlign","bgcolor","borderColor","bordercolor","fontFamily","family","fontColor","nameLength","namelength","textAlign","align","hovertemplateLabels","container","_hoverlayer","outerContainer","_paper","emit","points","event","evt","datum","originalEvent","loneUnhover","_hoverdata","click","layoutFont","textfont","customColor","insidetextfont","_input","contrast","length","dummyTitle","tester","titleBox","width","rpx1","isEmpty","startangle","stopangle","rotate","ring","isCircle","PI","halfAngle","halfangle","midAngle","midangle","orientation","insidetextorientation","isHorizontal","isTangential","isRadial","isAuto","allTransforms","newT","considerCrossing","angle","key","isCrossing","dStart","dStop","closestEdge","calcTanTransform","calcRadTransform","textDiameter","sqrt","id","maxScale","k","stop","a","calcMaxHalfSize","calcRCenter","calcRotate","cos","q","tan","getInscribedRadiusFraction","sin","plotSize","scaleX","scaleY","maxPull","topMiddle","translate","getMaxPull","rx","applyAspectRatio","aspectratio","maxWidth","getTitleSpace","pieBoxHeight","j","xHalf","yHalf","equatorFirst","farthestX","farthestY","xDiffSign","yDiffSign","thisQuad","oppositeQuad","wholeSide","thisQuadOutside","firstOppositeOutsidePt","topFirst","bottomFirst","scootOneLabel","thisPt","prevPt","prevOuterY","thisInnerY","thisOuterY","thisSliceOuterY","newExtraY","xBuffer","otherPt","otherOuterY","otherOuterX","newExtraX","sort","concat","scaleGroups","ry","scalegroup","groupScale","Infinity","g","area","baseratio","currentAngle","rotation","angleFactor","firstPt","lastPt","cdi","currentCoords","direction","texttemplate","textinfo","parts","split","hasFlag","flag","hasLabel","hasText","hasValue","hasPercent","getFirstFilled","makeTemplateVariables","customdata","obj","ptTx","texttemplateString","_d3locale","cosA","sinA","midX","midY","textX","textY","noCenter","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plots = require('../../plots/plots');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\n\nvar helpers = require('./helpers');\nvar eventData = require('./event_data');\nvar isValidTextValue = require('../../lib').isValidTextValue;\n\nfunction plot(gd, cdModule) {\n    var fullLayout = gd._fullLayout;\n    var gs = fullLayout._size;\n\n    clearMinTextSize('pie', fullLayout);\n\n    prerenderTitles(cdModule, gd);\n    layoutAreas(cdModule, gs);\n\n    var plotGroups = Lib.makeTraceGroups(fullLayout._pielayer, cdModule, 'trace').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n\n        setCoords(cd);\n\n        // TODO: miter might look better but can sometimes cause problems\n        // maybe miter with a small-ish stroke-miterlimit?\n        plotGroup.attr('stroke-linejoin', 'round');\n\n        plotGroup.each(function() {\n            var slices = d3.select(this).selectAll('g.slice').data(cd);\n\n            slices.enter().append('g')\n                .classed('slice', true);\n            slices.exit().remove();\n\n            var quadrants = [\n                [[], []], // y<0: x<0, x>=0\n                [[], []] // y>=0: x<0, x>=0\n            ];\n            var hasOutsideText = false;\n\n            slices.each(function(pt, i) {\n                if(pt.hidden) {\n                    d3.select(this).selectAll('path,g').remove();\n                    return;\n                }\n\n                // to have consistent event data compared to other traces\n                pt.pointNumber = pt.i;\n                pt.curveNumber = trace.index;\n\n                quadrants[pt.pxmid[1] < 0 ? 0 : 1][pt.pxmid[0] < 0 ? 0 : 1].push(pt);\n\n                var cx = cd0.cx;\n                var cy = cd0.cy;\n                var sliceTop = d3.select(this);\n                var slicePath = sliceTop.selectAll('path.surface').data([pt]);\n\n                slicePath.enter().append('path')\n                    .classed('surface', true)\n                    .style({'pointer-events': 'all'});\n\n                sliceTop.call(attachFxHandlers, gd, cd);\n\n                if(trace.pull) {\n                    var pull = +helpers.castOption(trace.pull, pt.pts) || 0;\n                    if(pull > 0) {\n                        cx += pull * pt.pxmid[0];\n                        cy += pull * pt.pxmid[1];\n                    }\n                }\n\n                pt.cxFinal = cx;\n                pt.cyFinal = cy;\n\n                function arc(start, finish, cw, scale) {\n                    var dx = scale * (finish[0] - start[0]);\n                    var dy = scale * (finish[1] - start[1]);\n\n                    return 'a' +\n                        (scale * cd0.r) + ',' + (scale * cd0.r) + ' 0 ' +\n                        pt.largeArc + (cw ? ' 1 ' : ' 0 ') + dx + ',' + dy;\n                }\n\n                var hole = trace.hole;\n                if(pt.v === cd0.vTotal) { // 100% fails bcs arc start and end are identical\n                    var outerCircle = 'M' + (cx + pt.px0[0]) + ',' + (cy + pt.px0[1]) +\n                        arc(pt.px0, pt.pxmid, true, 1) +\n                        arc(pt.pxmid, pt.px0, true, 1) + 'Z';\n                    if(hole) {\n                        slicePath.attr('d',\n                            'M' + (cx + hole * pt.px0[0]) + ',' + (cy + hole * pt.px0[1]) +\n                            arc(pt.px0, pt.pxmid, false, hole) +\n                            arc(pt.pxmid, pt.px0, false, hole) +\n                            'Z' + outerCircle);\n                    } else slicePath.attr('d', outerCircle);\n                } else {\n                    var outerArc = arc(pt.px0, pt.px1, true, 1);\n\n                    if(hole) {\n                        var rim = 1 - hole;\n                        slicePath.attr('d',\n                            'M' + (cx + hole * pt.px1[0]) + ',' + (cy + hole * pt.px1[1]) +\n                            arc(pt.px1, pt.px0, false, hole) +\n                            'l' + (rim * pt.px0[0]) + ',' + (rim * pt.px0[1]) +\n                            outerArc +\n                            'Z');\n                    } else {\n                        slicePath.attr('d',\n                            'M' + cx + ',' + cy +\n                            'l' + pt.px0[0] + ',' + pt.px0[1] +\n                            outerArc +\n                            'Z');\n                    }\n                }\n\n                // add text\n                formatSliceLabel(gd, pt, cd0);\n                var textPosition = helpers.castOption(trace.textposition, pt.pts);\n                var sliceTextGroup = sliceTop.selectAll('g.slicetext')\n                    .data(pt.text && (textPosition !== 'none') ? [0] : []);\n\n                sliceTextGroup.enter().append('g')\n                    .classed('slicetext', true);\n                sliceTextGroup.exit().remove();\n\n                sliceTextGroup.each(function() {\n                    var sliceText = Lib.ensureSingle(d3.select(this), 'text', '', function(s) {\n                        // prohibit tex interpretation until we can handle\n                        // tex and regular text together\n                        s.attr('data-notex', 1);\n                    });\n\n                    var font = Lib.ensureUniformFontSize(gd, textPosition === 'outside' ?\n                        determineOutsideTextFont(trace, pt, fullLayout.font) :\n                        determineInsideTextFont(trace, pt, fullLayout.font)\n                    );\n\n                    sliceText.text(pt.text)\n                        .attr({\n                            'class': 'slicetext',\n                            transform: '',\n                            'text-anchor': 'middle'\n                        })\n                        .call(Drawing.font, font)\n                        .call(svgTextUtils.convertToTspans, gd);\n\n                    // position the text relative to the slice\n                    var textBB = Drawing.bBox(sliceText.node());\n                    var transform;\n\n                    if(textPosition === 'outside') {\n                        transform = transformOutsideText(textBB, pt);\n                    } else {\n                        transform = transformInsideText(textBB, pt, cd0);\n                        if(textPosition === 'auto' && transform.scale < 1) {\n                            var newFont = Lib.ensureUniformFontSize(gd, trace.outsidetextfont);\n\n                            sliceText.call(Drawing.font, newFont);\n                            textBB = Drawing.bBox(sliceText.node());\n\n                            transform = transformOutsideText(textBB, pt);\n                        }\n                    }\n\n                    var textPosAngle = transform.textPosAngle;\n                    var textXY = textPosAngle === undefined ? pt.pxmid : getCoords(cd0.r, textPosAngle);\n                    transform.targetX = cx + textXY[0] * transform.rCenter + (transform.x || 0);\n                    transform.targetY = cy + textXY[1] * transform.rCenter + (transform.y || 0);\n                    computeTransform(transform, textBB);\n\n                    // save some stuff to use later ensure no labels overlap\n                    if(transform.outside) {\n                        var targetY = transform.targetY;\n                        pt.yLabelMin = targetY - textBB.height / 2;\n                        pt.yLabelMid = targetY;\n                        pt.yLabelMax = targetY + textBB.height / 2;\n                        pt.labelExtraX = 0;\n                        pt.labelExtraY = 0;\n                        hasOutsideText = true;\n                    }\n\n                    transform.fontSize = font.size;\n                    recordMinTextSize(trace.type, transform, fullLayout);\n                    cd[i].transform = transform;\n\n                    sliceText.attr('transform', Lib.getTextTransform(transform));\n                });\n            });\n\n            // add the title\n            var titleTextGroup = d3.select(this).selectAll('g.titletext')\n                .data(trace.title.text ? [0] : []);\n\n            titleTextGroup.enter().append('g')\n                .classed('titletext', true);\n            titleTextGroup.exit().remove();\n\n            titleTextGroup.each(function() {\n                var titleText = Lib.ensureSingle(d3.select(this), 'text', '', function(s) {\n                    // prohibit tex interpretation as above\n                    s.attr('data-notex', 1);\n                });\n\n                var txt = trace.title.text;\n                if(trace._meta) {\n                    txt = Lib.templateString(txt, trace._meta);\n                }\n\n                titleText.text(txt)\n                    .attr({\n                        'class': 'titletext',\n                        transform: '',\n                        'text-anchor': 'middle',\n                    })\n                .call(Drawing.font, trace.title.font)\n                .call(svgTextUtils.convertToTspans, gd);\n\n                var transform;\n\n                if(trace.title.position === 'middle center') {\n                    transform = positionTitleInside(cd0);\n                } else {\n                    transform = positionTitleOutside(cd0, gs);\n                }\n\n                titleText.attr('transform',\n                    'translate(' + transform.x + ',' + transform.y + ')' +\n                    (transform.scale < 1 ? ('scale(' + transform.scale + ')') : '') +\n                    'translate(' + transform.tx + ',' + transform.ty + ')');\n            });\n\n            // now make sure no labels overlap (at least within one pie)\n            if(hasOutsideText) scootLabels(quadrants, trace);\n\n            plotTextLines(slices, trace);\n\n            if(hasOutsideText && trace.automargin) {\n                // TODO if we ever want to improve perf,\n                // we could reuse the textBB computed above together\n                // with the sliceText transform info\n                var traceBbox = Drawing.bBox(plotGroup.node());\n\n                var domain = trace.domain;\n                var vpw = gs.w * (domain.x[1] - domain.x[0]);\n                var vph = gs.h * (domain.y[1] - domain.y[0]);\n                var xgap = (0.5 * vpw - cd0.r) / gs.w;\n                var ygap = (0.5 * vph - cd0.r) / gs.h;\n\n                Plots.autoMargin(gd, 'pie.' + trace.uid + '.automargin', {\n                    xl: domain.x[0] - xgap,\n                    xr: domain.x[1] + xgap,\n                    yb: domain.y[0] - ygap,\n                    yt: domain.y[1] + ygap,\n                    l: Math.max(cd0.cx - cd0.r - traceBbox.left, 0),\n                    r: Math.max(traceBbox.right - (cd0.cx + cd0.r), 0),\n                    b: Math.max(traceBbox.bottom - (cd0.cy + cd0.r), 0),\n                    t: Math.max(cd0.cy - cd0.r - traceBbox.top, 0),\n                    pad: 5\n                });\n            }\n        });\n    });\n\n    // This is for a bug in Chrome (as of 2015-07-22, and does not affect FF)\n    // if insidetextfont and outsidetextfont are different sizes, sometimes the size\n    // of an \"em\" gets taken from the wrong element at first so lines are\n    // spaced wrong. You just have to tell it to try again later and it gets fixed.\n    // I have no idea why we haven't seen this in other contexts. Also, sometimes\n    // it gets the initial draw correct but on redraw it gets confused.\n    setTimeout(function() {\n        plotGroups.selectAll('tspan').each(function() {\n            var s = d3.select(this);\n            if(s.attr('dy')) s.attr('dy', s.attr('dy'));\n        });\n    }, 0);\n}\n\n// TODO add support for transition\nfunction plotTextLines(slices, trace) {\n    slices.each(function(pt) {\n        var sliceTop = d3.select(this);\n\n        if(!pt.labelExtraX && !pt.labelExtraY) {\n            sliceTop.select('path.textline').remove();\n            return;\n        }\n\n        // first move the text to its new location\n        var sliceText = sliceTop.select('g.slicetext text');\n\n        pt.transform.targetX += pt.labelExtraX;\n        pt.transform.targetY += pt.labelExtraY;\n\n        sliceText.attr('transform', Lib.getTextTransform(pt.transform));\n\n        // then add a line to the new location\n        var lineStartX = pt.cxFinal + pt.pxmid[0];\n        var lineStartY = pt.cyFinal + pt.pxmid[1];\n        var textLinePath = 'M' + lineStartX + ',' + lineStartY;\n        var finalX = (pt.yLabelMax - pt.yLabelMin) * (pt.pxmid[0] < 0 ? -1 : 1) / 4;\n\n        if(pt.labelExtraX) {\n            var yFromX = pt.labelExtraX * pt.pxmid[1] / pt.pxmid[0];\n            var yNet = pt.yLabelMid + pt.labelExtraY - (pt.cyFinal + pt.pxmid[1]);\n\n            if(Math.abs(yFromX) > Math.abs(yNet)) {\n                textLinePath +=\n                    'l' + (yNet * pt.pxmid[0] / pt.pxmid[1]) + ',' + yNet +\n                    'H' + (lineStartX + pt.labelExtraX + finalX);\n            } else {\n                textLinePath += 'l' + pt.labelExtraX + ',' + yFromX +\n                    'v' + (yNet - yFromX) +\n                    'h' + finalX;\n            }\n        } else {\n            textLinePath +=\n                'V' + (pt.yLabelMid + pt.labelExtraY) +\n                'h' + finalX;\n        }\n\n        Lib.ensureSingle(sliceTop, 'path', 'textline')\n            .call(Color.stroke, trace.outsidetextfont.color)\n            .attr({\n                'stroke-width': Math.min(2, trace.outsidetextfont.size / 8),\n                d: textLinePath,\n                fill: 'none'\n            });\n    });\n}\n\nfunction attachFxHandlers(sliceTop, gd, cd) {\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var cx = cd0.cx;\n    var cy = cd0.cy;\n\n    // hover state vars\n    // have we drawn a hover label, so it should be cleared later\n    if(!('_hasHoverLabel' in trace)) trace._hasHoverLabel = false;\n    // have we emitted a hover event, so later an unhover event should be emitted\n    // note that click events do not depend on this - you can still get them\n    // with hovermode: false or if you were earlier dragging, then clicked\n    // in the same slice that you moused up in\n    if(!('_hasHoverEvent' in trace)) trace._hasHoverEvent = false;\n\n    sliceTop.on('mouseover', function(pt) {\n        // in case fullLayout or fullData has changed without a replot\n        var fullLayout2 = gd._fullLayout;\n        var trace2 = gd._fullData[trace.index];\n\n        if(gd._dragging || fullLayout2.hovermode === false) return;\n\n        var hoverinfo = trace2.hoverinfo;\n        if(Array.isArray(hoverinfo)) {\n            // super hacky: we need to pull out the *first* hoverinfo from\n            // pt.pts, then put it back into an array in a dummy trace\n            // and call castHoverinfo on that.\n            // TODO: do we want to have Fx.castHoverinfo somehow handle this?\n            // it already takes an array for index, for 2D, so this seems tricky.\n            hoverinfo = Fx.castHoverinfo({\n                hoverinfo: [helpers.castOption(hoverinfo, pt.pts)],\n                _module: trace._module\n            }, fullLayout2, 0);\n        }\n\n        if(hoverinfo === 'all') hoverinfo = 'label+text+value+percent+name';\n\n        // in case we dragged over the pie from another subplot,\n        // or if hover is turned off\n        if(trace2.hovertemplate || (hoverinfo !== 'none' && hoverinfo !== 'skip' && hoverinfo)) {\n            var rInscribed = pt.rInscribed || 0;\n            var hoverCenterX = cx + pt.pxmid[0] * (1 - rInscribed);\n            var hoverCenterY = cy + pt.pxmid[1] * (1 - rInscribed);\n            var separators = fullLayout2.separators;\n            var text = [];\n\n            if(hoverinfo && hoverinfo.indexOf('label') !== -1) text.push(pt.label);\n            pt.text = helpers.castOption(trace2.hovertext || trace2.text, pt.pts);\n            if(hoverinfo && hoverinfo.indexOf('text') !== -1) {\n                var tx = pt.text;\n                if(Lib.isValidTextValue(tx)) text.push(tx);\n            }\n            pt.value = pt.v;\n            pt.valueLabel = helpers.formatPieValue(pt.v, separators);\n            if(hoverinfo && hoverinfo.indexOf('value') !== -1) text.push(pt.valueLabel);\n            pt.percent = pt.v / cd0.vTotal;\n            pt.percentLabel = helpers.formatPiePercent(pt.percent, separators);\n            if(hoverinfo && hoverinfo.indexOf('percent') !== -1) text.push(pt.percentLabel);\n\n            var hoverLabel = trace2.hoverlabel;\n            var hoverFont = hoverLabel.font;\n\n            Fx.loneHover({\n                trace: trace,\n                x0: hoverCenterX - rInscribed * cd0.r,\n                x1: hoverCenterX + rInscribed * cd0.r,\n                y: hoverCenterY,\n                text: text.join('<br>'),\n                name: (trace2.hovertemplate || hoverinfo.indexOf('name') !== -1) ? trace2.name : undefined,\n                idealAlign: pt.pxmid[0] < 0 ? 'left' : 'right',\n                color: helpers.castOption(hoverLabel.bgcolor, pt.pts) || pt.color,\n                borderColor: helpers.castOption(hoverLabel.bordercolor, pt.pts),\n                fontFamily: helpers.castOption(hoverFont.family, pt.pts),\n                fontSize: helpers.castOption(hoverFont.size, pt.pts),\n                fontColor: helpers.castOption(hoverFont.color, pt.pts),\n                nameLength: helpers.castOption(hoverLabel.namelength, pt.pts),\n                textAlign: helpers.castOption(hoverLabel.align, pt.pts),\n                hovertemplate: helpers.castOption(trace2.hovertemplate, pt.pts),\n                hovertemplateLabels: pt,\n                eventData: [eventData(pt, trace2)]\n            }, {\n                container: fullLayout2._hoverlayer.node(),\n                outerContainer: fullLayout2._paper.node(),\n                gd: gd\n            });\n\n            trace._hasHoverLabel = true;\n        }\n\n        trace._hasHoverEvent = true;\n        gd.emit('plotly_hover', {\n            points: [eventData(pt, trace2)],\n            event: d3.event\n        });\n    });\n\n    sliceTop.on('mouseout', function(evt) {\n        var fullLayout2 = gd._fullLayout;\n        var trace2 = gd._fullData[trace.index];\n        var pt = d3.select(this).datum();\n\n        if(trace._hasHoverEvent) {\n            evt.originalEvent = d3.event;\n            gd.emit('plotly_unhover', {\n                points: [eventData(pt, trace2)],\n                event: d3.event\n            });\n            trace._hasHoverEvent = false;\n        }\n\n        if(trace._hasHoverLabel) {\n            Fx.loneUnhover(fullLayout2._hoverlayer.node());\n            trace._hasHoverLabel = false;\n        }\n    });\n\n    sliceTop.on('click', function(pt) {\n        // TODO: this does not support right-click. If we want to support it, we\n        // would likely need to change pie to use dragElement instead of straight\n        // mapbox event binding. Or perhaps better, make a simple wrapper with the\n        // right mousedown, mousemove, and mouseup handlers just for a left/right click\n        // mapbox would use this too.\n        var fullLayout2 = gd._fullLayout;\n        var trace2 = gd._fullData[trace.index];\n\n        if(gd._dragging || fullLayout2.hovermode === false) return;\n\n        gd._hoverdata = [eventData(pt, trace2)];\n        Fx.click(gd, d3.event);\n    });\n}\n\nfunction determineOutsideTextFont(trace, pt, layoutFont) {\n    var color =\n        helpers.castOption(trace.outsidetextfont.color, pt.pts) ||\n        helpers.castOption(trace.textfont.color, pt.pts) ||\n        layoutFont.color;\n\n    var family =\n        helpers.castOption(trace.outsidetextfont.family, pt.pts) ||\n        helpers.castOption(trace.textfont.family, pt.pts) ||\n        layoutFont.family;\n\n    var size =\n        helpers.castOption(trace.outsidetextfont.size, pt.pts) ||\n        helpers.castOption(trace.textfont.size, pt.pts) ||\n        layoutFont.size;\n\n    return {\n        color: color,\n        family: family,\n        size: size\n    };\n}\n\nfunction determineInsideTextFont(trace, pt, layoutFont) {\n    var customColor = helpers.castOption(trace.insidetextfont.color, pt.pts);\n    if(!customColor && trace._input.textfont) {\n        // Why not simply using trace.textfont? Because if not set, it\n        // defaults to layout.font which has a default color. But if\n        // textfont.color and insidetextfont.color don't supply a value,\n        // a contrasting color shall be used.\n        customColor = helpers.castOption(trace._input.textfont.color, pt.pts);\n    }\n\n    var family =\n        helpers.castOption(trace.insidetextfont.family, pt.pts) ||\n        helpers.castOption(trace.textfont.family, pt.pts) ||\n        layoutFont.family;\n\n    var size =\n        helpers.castOption(trace.insidetextfont.size, pt.pts) ||\n        helpers.castOption(trace.textfont.size, pt.pts) ||\n        layoutFont.size;\n\n    return {\n        color: customColor || Color.contrast(pt.color),\n        family: family,\n        size: size\n    };\n}\n\nfunction prerenderTitles(cdModule, gd) {\n    var cd0, trace;\n\n    // Determine the width and height of the title for each pie.\n    for(var i = 0; i < cdModule.length; i++) {\n        cd0 = cdModule[i][0];\n        trace = cd0.trace;\n\n        if(trace.title.text) {\n            var txt = trace.title.text;\n            if(trace._meta) {\n                txt = Lib.templateString(txt, trace._meta);\n            }\n\n            var dummyTitle = Drawing.tester.append('text')\n              .attr('data-notex', 1)\n              .text(txt)\n              .call(Drawing.font, trace.title.font)\n              .call(svgTextUtils.convertToTspans, gd);\n            var bBox = Drawing.bBox(dummyTitle.node(), true);\n            cd0.titleBox = {\n                width: bBox.width,\n                height: bBox.height,\n            };\n            dummyTitle.remove();\n        }\n    }\n}\n\nfunction transformInsideText(textBB, pt, cd0) {\n    var r = cd0.r || pt.rpx1;\n    var rInscribed = pt.rInscribed;\n\n    var isEmpty = pt.startangle === pt.stopangle;\n    if(isEmpty) {\n        return {\n            rCenter: 1 - rInscribed,\n            scale: 0,\n            rotate: 0,\n            textPosAngle: 0\n        };\n    }\n\n    var ring = pt.ring;\n    var isCircle = (ring === 1) && (Math.abs(pt.startangle - pt.stopangle) === Math.PI * 2);\n\n    var halfAngle = pt.halfangle;\n    var midAngle = pt.midangle;\n\n    var orientation = cd0.trace.insidetextorientation;\n    var isHorizontal = orientation === 'horizontal';\n    var isTangential = orientation === 'tangential';\n    var isRadial = orientation === 'radial';\n    var isAuto = orientation === 'auto';\n\n    var allTransforms = [];\n    var newT;\n\n    if(!isAuto) {\n        // max size if text is placed (horizontally) at the top or bottom of the arc\n\n        var considerCrossing = function(angle, key) {\n            if(isCrossing(pt, angle)) {\n                var dStart = Math.abs(angle - pt.startangle);\n                var dStop = Math.abs(angle - pt.stopangle);\n\n                var closestEdge = dStart < dStop ? dStart : dStop;\n\n                if(key === 'tan') {\n                    newT = calcTanTransform(textBB, r, ring, closestEdge, 0);\n                } else { // case of 'rad'\n                    newT = calcRadTransform(textBB, r, ring, closestEdge, Math.PI / 2);\n                }\n                newT.textPosAngle = angle;\n\n                allTransforms.push(newT);\n            }\n        };\n\n        // to cover all cases with trace.rotation added\n        var i;\n        if(isHorizontal || isTangential) {\n            // top\n            for(i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * i, 'tan');\n            // bottom\n            for(i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 1), 'tan');\n        }\n        if(isHorizontal || isRadial) {\n            // left\n            for(i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 1.5), 'rad');\n            // right\n            for(i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 0.5), 'rad');\n        }\n    }\n\n    if(isCircle || isAuto || isHorizontal) {\n        // max size text can be inserted inside without rotating it\n        // this inscribes the text rectangle in a circle, which is then inscribed\n        // in the slice, so it will be an underestimate, which some day we may want\n        // to improve so this case can get more use\n        var textDiameter = Math.sqrt(textBB.width * textBB.width + textBB.height * textBB.height);\n\n        newT = {\n            scale: rInscribed * r * 2 / textDiameter,\n\n            // and the center position and rotation in this case\n            rCenter: 1 - rInscribed,\n            rotate: 0\n        };\n\n        newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;\n        if(newT.scale >= 1) return newT;\n\n        allTransforms.push(newT);\n    }\n\n    if(isAuto || isRadial) {\n        newT = calcRadTransform(textBB, r, ring, halfAngle, midAngle);\n        newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;\n        allTransforms.push(newT);\n    }\n\n    if(isAuto || isTangential) {\n        newT = calcTanTransform(textBB, r, ring, halfAngle, midAngle);\n        newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;\n        allTransforms.push(newT);\n    }\n\n    var id = 0;\n    var maxScale = 0;\n    for(var k = 0; k < allTransforms.length; k++) {\n        var s = allTransforms[k].scale;\n        if(maxScale < s) {\n            maxScale = s;\n            id = k;\n        }\n\n        if(!isAuto && maxScale >= 1) {\n            // respect test order for non-auto options\n            break;\n        }\n    }\n    return allTransforms[id];\n}\n\nfunction isCrossing(pt, angle) {\n    var start = pt.startangle;\n    var stop = pt.stopangle;\n    return (\n        (start > angle && angle > stop) ||\n        (start < angle && angle < stop)\n    );\n}\n\nfunction calcRadTransform(textBB, r, ring, halfAngle, midAngle) {\n    r = Math.max(0, r - 2 * TEXTPAD);\n\n    // max size if text is rotated radially\n    var a = textBB.width / textBB.height;\n    var s = calcMaxHalfSize(a, halfAngle, r, ring);\n    return {\n        scale: s * 2 / textBB.height,\n        rCenter: calcRCenter(a, s / r),\n        rotate: calcRotate(midAngle)\n    };\n}\n\nfunction calcTanTransform(textBB, r, ring, halfAngle, midAngle) {\n    r = Math.max(0, r - 2 * TEXTPAD);\n\n    // max size if text is rotated tangentially\n    var a = textBB.height / textBB.width;\n    var s = calcMaxHalfSize(a, halfAngle, r, ring);\n    return {\n        scale: s * 2 / textBB.width,\n        rCenter: calcRCenter(a, s / r),\n        rotate: calcRotate(midAngle + Math.PI / 2)\n    };\n}\n\nfunction calcRCenter(a, b) {\n    return Math.cos(b) - a * b;\n}\n\nfunction calcRotate(t) {\n    return (180 / Math.PI * t + 720) % 180 - 90;\n}\n\nfunction calcMaxHalfSize(a, halfAngle, r, ring) {\n    var q = a + 1 / (2 * Math.tan(halfAngle));\n    return r * Math.min(\n        1 / (Math.sqrt(q * q + 0.5) + q),\n        ring / (Math.sqrt(a * a + ring / 2) + a)\n    );\n}\n\nfunction getInscribedRadiusFraction(pt, cd0) {\n    if(pt.v === cd0.vTotal && !cd0.trace.hole) return 1;// special case of 100% with no hole\n\n    return Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2);\n}\n\nfunction transformOutsideText(textBB, pt) {\n    var x = pt.pxmid[0];\n    var y = pt.pxmid[1];\n    var dx = textBB.width / 2;\n    var dy = textBB.height / 2;\n\n    if(x < 0) dx *= -1;\n    if(y < 0) dy *= -1;\n\n    return {\n        scale: 1,\n        rCenter: 1,\n        rotate: 0,\n        x: dx + Math.abs(dy) * (dx > 0 ? 1 : -1) / 2,\n        y: dy / (1 + x * x / (y * y)),\n        outside: true\n    };\n}\n\nfunction positionTitleInside(cd0) {\n    var textDiameter =\n        Math.sqrt(cd0.titleBox.width * cd0.titleBox.width + cd0.titleBox.height * cd0.titleBox.height);\n    return {\n        x: cd0.cx,\n        y: cd0.cy,\n        scale: cd0.trace.hole * cd0.r * 2 / textDiameter,\n        tx: 0,\n        ty: - cd0.titleBox.height / 2 + cd0.trace.title.font.size\n    };\n}\n\nfunction positionTitleOutside(cd0, plotSize) {\n    var scaleX = 1;\n    var scaleY = 1;\n    var maxPull;\n\n    var trace = cd0.trace;\n    // position of the baseline point of the text box in the plot, before scaling.\n    // we anchored the text in the middle, so the baseline is on the bottom middle\n    // of the first line of text.\n    var topMiddle = {\n        x: cd0.cx,\n        y: cd0.cy\n    };\n    // relative translation of the text box after scaling\n    var translate = {\n        tx: 0,\n        ty: 0\n    };\n\n    // we reason below as if the baseline is the top middle point of the text box.\n    // so we must add the font size to approximate the y-coord. of the top.\n    // note that this correction must happen after scaling.\n    translate.ty += trace.title.font.size;\n    maxPull = getMaxPull(trace);\n\n    if(trace.title.position.indexOf('top') !== -1) {\n        topMiddle.y -= (1 + maxPull) * cd0.r;\n        translate.ty -= cd0.titleBox.height;\n    } else if(trace.title.position.indexOf('bottom') !== -1) {\n        topMiddle.y += (1 + maxPull) * cd0.r;\n    }\n\n    var rx = applyAspectRatio(cd0.r, cd0.trace.aspectratio);\n\n    var maxWidth = plotSize.w * (trace.domain.x[1] - trace.domain.x[0]) / 2;\n    if(trace.title.position.indexOf('left') !== -1) {\n        // we start the text at the left edge of the pie\n        maxWidth = maxWidth + rx;\n        topMiddle.x -= (1 + maxPull) * rx;\n        translate.tx += cd0.titleBox.width / 2;\n    } else if(trace.title.position.indexOf('center') !== -1) {\n        maxWidth *= 2;\n    } else if(trace.title.position.indexOf('right') !== -1) {\n        maxWidth = maxWidth + rx;\n        topMiddle.x += (1 + maxPull) * rx;\n        translate.tx -= cd0.titleBox.width / 2;\n    }\n    scaleX = maxWidth / cd0.titleBox.width;\n    scaleY = getTitleSpace(cd0, plotSize) / cd0.titleBox.height;\n    return {\n        x: topMiddle.x,\n        y: topMiddle.y,\n        scale: Math.min(scaleX, scaleY),\n        tx: translate.tx,\n        ty: translate.ty\n    };\n}\n\nfunction applyAspectRatio(x, aspectratio) {\n    return x / ((aspectratio === undefined) ? 1 : aspectratio);\n}\n\nfunction getTitleSpace(cd0, plotSize) {\n    var trace = cd0.trace;\n    var pieBoxHeight = plotSize.h * (trace.domain.y[1] - trace.domain.y[0]);\n    // use at most half of the plot for the title\n    return Math.min(cd0.titleBox.height, pieBoxHeight / 2);\n}\n\nfunction getMaxPull(trace) {\n    var maxPull = trace.pull;\n    if(!maxPull) return 0;\n\n    var j;\n    if(Array.isArray(maxPull)) {\n        maxPull = 0;\n        for(j = 0; j < trace.pull.length; j++) {\n            if(trace.pull[j] > maxPull) maxPull = trace.pull[j];\n        }\n    }\n    return maxPull;\n}\n\nfunction scootLabels(quadrants, trace) {\n    var xHalf, yHalf, equatorFirst, farthestX, farthestY,\n        xDiffSign, yDiffSign, thisQuad, oppositeQuad,\n        wholeSide, i, thisQuadOutside, firstOppositeOutsidePt;\n\n    function topFirst(a, b) { return a.pxmid[1] - b.pxmid[1]; }\n    function bottomFirst(a, b) { return b.pxmid[1] - a.pxmid[1]; }\n\n    function scootOneLabel(thisPt, prevPt) {\n        if(!prevPt) prevPt = {};\n\n        var prevOuterY = prevPt.labelExtraY + (yHalf ? prevPt.yLabelMax : prevPt.yLabelMin);\n        var thisInnerY = yHalf ? thisPt.yLabelMin : thisPt.yLabelMax;\n        var thisOuterY = yHalf ? thisPt.yLabelMax : thisPt.yLabelMin;\n        var thisSliceOuterY = thisPt.cyFinal + farthestY(thisPt.px0[1], thisPt.px1[1]);\n        var newExtraY = prevOuterY - thisInnerY;\n\n        var xBuffer, i, otherPt, otherOuterY, otherOuterX, newExtraX;\n\n        // make sure this label doesn't overlap other labels\n        // this *only* has us move these labels vertically\n        if(newExtraY * yDiffSign > 0) thisPt.labelExtraY = newExtraY;\n\n        // make sure this label doesn't overlap any slices\n        if(!Array.isArray(trace.pull)) return; // this can only happen with array pulls\n\n        for(i = 0; i < wholeSide.length; i++) {\n            otherPt = wholeSide[i];\n\n            // overlap can only happen if the other point is pulled more than this one\n            if(otherPt === thisPt || (\n                (helpers.castOption(trace.pull, thisPt.pts) || 0) >=\n                (helpers.castOption(trace.pull, otherPt.pts) || 0))\n            ) {\n                continue;\n            }\n\n            if((thisPt.pxmid[1] - otherPt.pxmid[1]) * yDiffSign > 0) {\n                // closer to the equator - by construction all of these happen first\n                // move the text vertically to get away from these slices\n                otherOuterY = otherPt.cyFinal + farthestY(otherPt.px0[1], otherPt.px1[1]);\n                newExtraY = otherOuterY - thisInnerY - thisPt.labelExtraY;\n\n                if(newExtraY * yDiffSign > 0) thisPt.labelExtraY += newExtraY;\n            } else if((thisOuterY + thisPt.labelExtraY - thisSliceOuterY) * yDiffSign > 0) {\n                // farther from the equator - happens after we've done all the\n                // vertical moving we're going to do\n                // move horizontally to get away from these more polar slices\n\n                // if we're moving horz. based on a slice that's several slices away from this one\n                // then we need some extra space for the lines to labels between them\n                xBuffer = 3 * xDiffSign * Math.abs(i - wholeSide.indexOf(thisPt));\n\n                otherOuterX = otherPt.cxFinal + farthestX(otherPt.px0[0], otherPt.px1[0]);\n                newExtraX = otherOuterX + xBuffer - (thisPt.cxFinal + thisPt.pxmid[0]) - thisPt.labelExtraX;\n\n                if(newExtraX * xDiffSign > 0) thisPt.labelExtraX += newExtraX;\n            }\n        }\n    }\n\n    for(yHalf = 0; yHalf < 2; yHalf++) {\n        equatorFirst = yHalf ? topFirst : bottomFirst;\n        farthestY = yHalf ? Math.max : Math.min;\n        yDiffSign = yHalf ? 1 : -1;\n\n        for(xHalf = 0; xHalf < 2; xHalf++) {\n            farthestX = xHalf ? Math.max : Math.min;\n            xDiffSign = xHalf ? 1 : -1;\n\n            // first sort the array\n            // note this is a copy of cd, so cd itself doesn't get sorted\n            // but we can still modify points in place.\n            thisQuad = quadrants[yHalf][xHalf];\n            thisQuad.sort(equatorFirst);\n\n            oppositeQuad = quadrants[1 - yHalf][xHalf];\n            wholeSide = oppositeQuad.concat(thisQuad);\n\n            thisQuadOutside = [];\n            for(i = 0; i < thisQuad.length; i++) {\n                if(thisQuad[i].yLabelMid !== undefined) thisQuadOutside.push(thisQuad[i]);\n            }\n\n            firstOppositeOutsidePt = false;\n            for(i = 0; yHalf && i < oppositeQuad.length; i++) {\n                if(oppositeQuad[i].yLabelMid !== undefined) {\n                    firstOppositeOutsidePt = oppositeQuad[i];\n                    break;\n                }\n            }\n\n            // each needs to avoid the previous\n            for(i = 0; i < thisQuadOutside.length; i++) {\n                var prevPt = i && thisQuadOutside[i - 1];\n                // bottom half needs to avoid the first label of the top half\n                // top half we still need to call scootOneLabel on the first slice\n                // so we can avoid other slices, but we don't pass a prevPt\n                if(firstOppositeOutsidePt && !i) prevPt = firstOppositeOutsidePt;\n                scootOneLabel(thisQuadOutside[i], prevPt);\n            }\n        }\n    }\n}\n\nfunction layoutAreas(cdModule, plotSize) {\n    var scaleGroups = [];\n\n    // figure out the center and maximum radius\n    for(var i = 0; i < cdModule.length; i++) {\n        var cd0 = cdModule[i][0];\n        var trace = cd0.trace;\n\n        var domain = trace.domain;\n        var width = plotSize.w * (domain.x[1] - domain.x[0]);\n        var height = plotSize.h * (domain.y[1] - domain.y[0]);\n        // leave some space for the title, if it will be displayed outside\n        if(trace.title.text && trace.title.position !== 'middle center') {\n            height -= getTitleSpace(cd0, plotSize);\n        }\n\n        var rx = width / 2;\n        var ry = height / 2;\n        if(trace.type === 'funnelarea' && !trace.scalegroup) {\n            ry /= trace.aspectratio;\n        }\n\n        cd0.r = Math.min(rx, ry) / (1 + getMaxPull(trace));\n\n        cd0.cx = plotSize.l + plotSize.w * (trace.domain.x[1] + trace.domain.x[0]) / 2;\n        cd0.cy = plotSize.t + plotSize.h * (1 - trace.domain.y[0]) - height / 2;\n        if(trace.title.text && trace.title.position.indexOf('bottom') !== -1) {\n            cd0.cy -= getTitleSpace(cd0, plotSize);\n        }\n\n        if(trace.scalegroup && scaleGroups.indexOf(trace.scalegroup) === -1) {\n            scaleGroups.push(trace.scalegroup);\n        }\n    }\n\n    groupScale(cdModule, scaleGroups);\n}\n\nfunction groupScale(cdModule, scaleGroups) {\n    var cd0, i, trace;\n\n    // scale those that are grouped\n    for(var k = 0; k < scaleGroups.length; k++) {\n        var min = Infinity;\n        var g = scaleGroups[k];\n\n        for(i = 0; i < cdModule.length; i++) {\n            cd0 = cdModule[i][0];\n            trace = cd0.trace;\n\n            if(trace.scalegroup === g) {\n                var area;\n                if(trace.type === 'pie') {\n                    area = cd0.r * cd0.r;\n                } else if(trace.type === 'funnelarea') {\n                    var rx, ry;\n\n                    if(trace.aspectratio > 1) {\n                        rx = cd0.r;\n                        ry = rx / trace.aspectratio;\n                    } else {\n                        ry = cd0.r;\n                        rx = ry * trace.aspectratio;\n                    }\n\n                    rx *= (1 + trace.baseratio) / 2;\n\n                    area = rx * ry;\n                }\n\n                min = Math.min(min, area / cd0.vTotal);\n            }\n        }\n\n        for(i = 0; i < cdModule.length; i++) {\n            cd0 = cdModule[i][0];\n            trace = cd0.trace;\n            if(trace.scalegroup === g) {\n                var v = min * cd0.vTotal;\n                if(trace.type === 'funnelarea') {\n                    v /= (1 + trace.baseratio) / 2;\n                    v /= trace.aspectratio;\n                }\n\n                cd0.r = Math.sqrt(v);\n            }\n        }\n    }\n}\n\nfunction setCoords(cd) {\n    var cd0 = cd[0];\n    var r = cd0.r;\n    var trace = cd0.trace;\n    var currentAngle = trace.rotation * Math.PI / 180;\n    var angleFactor = 2 * Math.PI / cd0.vTotal;\n    var firstPt = 'px0';\n    var lastPt = 'px1';\n\n    var i, cdi, currentCoords;\n\n    if(trace.direction === 'counterclockwise') {\n        for(i = 0; i < cd.length; i++) {\n            if(!cd[i].hidden) break; // find the first non-hidden slice\n        }\n        if(i === cd.length) return; // all slices hidden\n\n        currentAngle += angleFactor * cd[i].v;\n        angleFactor *= -1;\n        firstPt = 'px1';\n        lastPt = 'px0';\n    }\n\n    currentCoords = getCoords(r, currentAngle);\n\n    for(i = 0; i < cd.length; i++) {\n        cdi = cd[i];\n        if(cdi.hidden) continue;\n\n        cdi[firstPt] = currentCoords;\n\n        cdi.startangle = currentAngle;\n        currentAngle += angleFactor * cdi.v / 2;\n        cdi.pxmid = getCoords(r, currentAngle);\n        cdi.midangle = currentAngle;\n        currentAngle += angleFactor * cdi.v / 2;\n        currentCoords = getCoords(r, currentAngle);\n        cdi.stopangle = currentAngle;\n\n        cdi[lastPt] = currentCoords;\n\n        cdi.largeArc = (cdi.v > cd0.vTotal / 2) ? 1 : 0;\n\n        cdi.halfangle = Math.PI * Math.min(cdi.v / cd0.vTotal, 0.5);\n        cdi.ring = 1 - trace.hole;\n        cdi.rInscribed = getInscribedRadiusFraction(cdi, cd0);\n    }\n}\n\nfunction getCoords(r, angle) {\n    return [r * Math.sin(angle), -r * Math.cos(angle)];\n}\n\nfunction formatSliceLabel(gd, pt, cd0) {\n    var fullLayout = gd._fullLayout;\n    var trace = cd0.trace;\n    // look for textemplate\n    var texttemplate = trace.texttemplate;\n\n    // now insert text\n    var textinfo = trace.textinfo;\n    if(!texttemplate && textinfo && textinfo !== 'none') {\n        var parts = textinfo.split('+');\n        var hasFlag = function(flag) { return parts.indexOf(flag) !== -1; };\n        var hasLabel = hasFlag('label');\n        var hasText = hasFlag('text');\n        var hasValue = hasFlag('value');\n        var hasPercent = hasFlag('percent');\n\n        var separators = fullLayout.separators;\n        var text;\n\n        text = hasLabel ? [pt.label] : [];\n        if(hasText) {\n            var tx = helpers.getFirstFilled(trace.text, pt.pts);\n            if(isValidTextValue(tx)) text.push(tx);\n        }\n        if(hasValue) text.push(helpers.formatPieValue(pt.v, separators));\n        if(hasPercent) text.push(helpers.formatPiePercent(pt.v / cd0.vTotal, separators));\n        pt.text = text.join('<br>');\n    }\n\n    function makeTemplateVariables(pt) {\n        return {\n            label: pt.label,\n            value: pt.v,\n            valueLabel: helpers.formatPieValue(pt.v, fullLayout.separators),\n            percent: pt.v / cd0.vTotal,\n            percentLabel: helpers.formatPiePercent(pt.v / cd0.vTotal, fullLayout.separators),\n            color: pt.color,\n            text: pt.text,\n            customdata: Lib.castOption(trace, pt.i, 'customdata')\n        };\n    }\n\n    if(texttemplate) {\n        var txt = Lib.castOption(trace, pt.i, 'texttemplate');\n        if(!txt) {\n            pt.text = '';\n        } else {\n            var obj = makeTemplateVariables(pt);\n            var ptTx = helpers.getFirstFilled(trace.text, pt.pts);\n            if(isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n            pt.text = Lib.texttemplateString(txt, obj, gd._fullLayout._d3locale, obj, trace._meta || {});\n        }\n    }\n}\n\nfunction computeTransform(\n    transform,  // inout\n    textBB      // in\n) {\n    var a = transform.rotate * Math.PI / 180;\n    var cosA = Math.cos(a);\n    var sinA = Math.sin(a);\n    var midX = (textBB.left + textBB.right) / 2;\n    var midY = (textBB.top + textBB.bottom) / 2;\n    transform.textX = midX * cosA - midY * sinA;\n    transform.textY = midX * sinA + midY * cosA;\n    transform.noCenter = true;\n}\n\nmodule.exports = {\n    plot: plot,\n    formatSliceLabel: formatSliceLabel,\n    transformInsideText: transformInsideText,\n    determineInsideTextFont: determineInsideTextFont,\n    positionTitleOutside: positionTitleOutside,\n    prerenderTitles: prerenderTitles,\n    layoutAreas: layoutAreas,\n    attachFxHandlers: attachFxHandlers,\n    computeTransform: computeTransform\n};\n"]},"metadata":{},"sourceType":"script"}