{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar setConvertCartesian = require('../cartesian/set_convert');\n\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n/**\n * setConvert for polar axes!\n *\n * @param {object} ax\n *   axis in question (works for both radial and angular axes)\n * @param {object} polarLayout\n *   full polar layout of the subplot associated with 'ax'\n * @param {object} fullLayout\n *   full layout\n *\n * Here, reuse some of the Cartesian setConvert logic,\n * but we must extend some of it, as both radial and angular axes\n * don't have domains and angular axes don't have _true_ ranges.\n *\n * Moreover, we introduce two new coordinate systems:\n * - 'g' for geometric coordinates and\n * - 't' for angular ticks\n *\n * Radial axis coordinate systems:\n * - d, c and l: same as for cartesian axes\n * - g: like calcdata but translated about `radialaxis.range[0]` & `polar.hole`\n *\n * Angular axis coordinate systems:\n * - d: data, in whatever form it's provided\n * - c: calcdata, turned into radians (for linear axes)\n *      or category indices (category axes)\n * - t: tick calcdata, just like 'c' but in degrees for linear axes\n * - g: geometric calcdata, radians coordinates that take into account\n *      axis rotation and direction\n *\n * Then, 'g'eometric data is ready to be converted to (x,y).\n */\n\nmodule.exports = function setConvert(ax, polarLayout, fullLayout) {\n  setConvertCartesian(ax, fullLayout);\n\n  switch (ax._id) {\n    case 'x':\n    case 'radialaxis':\n      setConvertRadial(ax, polarLayout);\n      break;\n\n    case 'angularaxis':\n      setConvertAngular(ax, polarLayout);\n      break;\n  }\n};\n\nfunction setConvertRadial(ax, polarLayout) {\n  var subplot = polarLayout._subplot;\n\n  ax.setGeometry = function () {\n    var rl0 = ax._rl[0];\n    var rl1 = ax._rl[1];\n    var b = subplot.innerRadius;\n    var m = (subplot.radius - b) / (rl1 - rl0);\n    var b2 = b / m;\n    var rFilter = rl0 > rl1 ? function (v) {\n      return v <= 0;\n    } : function (v) {\n      return v >= 0;\n    };\n\n    ax.c2g = function (v) {\n      var r = ax.c2l(v) - rl0;\n      return (rFilter(r) ? r : 0) + b2;\n    };\n\n    ax.g2c = function (v) {\n      return ax.l2c(v + rl0 - b2);\n    };\n\n    ax.g2p = function (v) {\n      return v * m;\n    };\n\n    ax.c2p = function (v) {\n      return ax.g2p(ax.c2g(v));\n    };\n  };\n}\n\nfunction toRadians(v, unit) {\n  return unit === 'degrees' ? deg2rad(v) : v;\n}\n\nfunction fromRadians(v, unit) {\n  return unit === 'degrees' ? rad2deg(v) : v;\n}\n\nfunction setConvertAngular(ax, polarLayout) {\n  var axType = ax.type;\n\n  if (axType === 'linear') {\n    var _d2c = ax.d2c;\n    var _c2d = ax.c2d;\n\n    ax.d2c = function (v, unit) {\n      return toRadians(_d2c(v), unit);\n    };\n\n    ax.c2d = function (v, unit) {\n      return _c2d(fromRadians(v, unit));\n    };\n  } // override makeCalcdata to handle thetaunit and special theta0/dtheta logic\n\n\n  ax.makeCalcdata = function (trace, coord) {\n    var arrayIn = trace[coord];\n    var len = trace._length;\n    var arrayOut, i;\n\n    var _d2c = function (v) {\n      return ax.d2c(v, trace.thetaunit);\n    };\n\n    if (arrayIn) {\n      if (Lib.isTypedArray(arrayIn) && axType === 'linear') {\n        if (len === arrayIn.length) {\n          return arrayIn;\n        } else if (arrayIn.subarray) {\n          return arrayIn.subarray(0, len);\n        }\n      }\n\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = _d2c(arrayIn[i]);\n      }\n    } else {\n      var coord0 = coord + '0';\n      var dcoord = 'd' + coord;\n      var v0 = coord0 in trace ? _d2c(trace[coord0]) : 0;\n      var dv = trace[dcoord] ? _d2c(trace[dcoord]) : (ax.period || 2 * Math.PI) / len;\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = v0 + i * dv;\n      }\n    }\n\n    return arrayOut;\n  }; // N.B. we mock the axis 'range' here\n\n\n  ax.setGeometry = function () {\n    var sector = polarLayout.sector;\n    var sectorInRad = sector.map(deg2rad);\n    var dir = {\n      clockwise: -1,\n      counterclockwise: 1\n    }[ax.direction];\n    var rot = deg2rad(ax.rotation);\n\n    var rad2g = function (v) {\n      return dir * v + rot;\n    };\n\n    var g2rad = function (v) {\n      return (v - rot) / dir;\n    };\n\n    var rad2c, c2rad;\n    var rad2t, t2rad;\n\n    switch (axType) {\n      case 'linear':\n        c2rad = rad2c = Lib.identity;\n        t2rad = deg2rad;\n        rad2t = rad2deg; // Set the angular range in degrees to make auto-tick computation cleaner,\n        // changing rotation/direction should not affect the angular tick value.\n\n        ax.range = Lib.isFullCircle(sectorInRad) ? [sector[0], sector[0] + 360] : sectorInRad.map(g2rad).map(rad2deg);\n        break;\n\n      case 'category':\n        var catLen = ax._categories.length;\n\n        var _period = ax.period ? Math.max(ax.period, catLen) : catLen; // fallback in case all categories have been filtered out\n\n\n        if (_period === 0) _period = 1;\n\n        c2rad = t2rad = function (v) {\n          return v * 2 * Math.PI / _period;\n        };\n\n        rad2c = rad2t = function (v) {\n          return v * _period / Math.PI / 2;\n        };\n\n        ax.range = [0, _period];\n        break;\n    }\n\n    ax.c2g = function (v) {\n      return rad2g(c2rad(v));\n    };\n\n    ax.g2c = function (v) {\n      return rad2c(g2rad(v));\n    };\n\n    ax.t2g = function (v) {\n      return rad2g(t2rad(v));\n    };\n\n    ax.g2t = function (v) {\n      return rad2t(g2rad(v));\n    };\n  };\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/plots/polar/set_convert.js"],"names":["Lib","require","setConvertCartesian","deg2rad","rad2deg","module","exports","setConvert","ax","polarLayout","fullLayout","_id","setConvertRadial","setConvertAngular","subplot","_subplot","setGeometry","rl0","_rl","rl1","b","innerRadius","m","radius","b2","rFilter","v","c2g","r","c2l","g2c","l2c","g2p","c2p","toRadians","unit","fromRadians","axType","type","_d2c","d2c","_c2d","c2d","makeCalcdata","trace","coord","arrayIn","len","_length","arrayOut","i","thetaunit","isTypedArray","length","subarray","Array","coord0","dcoord","v0","dv","period","Math","PI","sector","sectorInRad","map","dir","clockwise","counterclockwise","direction","rot","rotation","rad2g","g2rad","rad2c","c2rad","rad2t","t2rad","identity","range","isFullCircle","catLen","_categories","_period","max","t2g","g2t"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar setConvertCartesian = require('../cartesian/set_convert');\n\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\n/**\n * setConvert for polar axes!\n *\n * @param {object} ax\n *   axis in question (works for both radial and angular axes)\n * @param {object} polarLayout\n *   full polar layout of the subplot associated with 'ax'\n * @param {object} fullLayout\n *   full layout\n *\n * Here, reuse some of the Cartesian setConvert logic,\n * but we must extend some of it, as both radial and angular axes\n * don't have domains and angular axes don't have _true_ ranges.\n *\n * Moreover, we introduce two new coordinate systems:\n * - 'g' for geometric coordinates and\n * - 't' for angular ticks\n *\n * Radial axis coordinate systems:\n * - d, c and l: same as for cartesian axes\n * - g: like calcdata but translated about `radialaxis.range[0]` & `polar.hole`\n *\n * Angular axis coordinate systems:\n * - d: data, in whatever form it's provided\n * - c: calcdata, turned into radians (for linear axes)\n *      or category indices (category axes)\n * - t: tick calcdata, just like 'c' but in degrees for linear axes\n * - g: geometric calcdata, radians coordinates that take into account\n *      axis rotation and direction\n *\n * Then, 'g'eometric data is ready to be converted to (x,y).\n */\nmodule.exports = function setConvert(ax, polarLayout, fullLayout) {\n    setConvertCartesian(ax, fullLayout);\n\n    switch(ax._id) {\n        case 'x':\n        case 'radialaxis':\n            setConvertRadial(ax, polarLayout);\n            break;\n        case 'angularaxis':\n            setConvertAngular(ax, polarLayout);\n            break;\n    }\n};\n\nfunction setConvertRadial(ax, polarLayout) {\n    var subplot = polarLayout._subplot;\n\n    ax.setGeometry = function() {\n        var rl0 = ax._rl[0];\n        var rl1 = ax._rl[1];\n\n        var b = subplot.innerRadius;\n        var m = (subplot.radius - b) / (rl1 - rl0);\n        var b2 = b / m;\n\n        var rFilter = rl0 > rl1 ?\n            function(v) { return v <= 0; } :\n            function(v) { return v >= 0; };\n\n        ax.c2g = function(v) {\n            var r = ax.c2l(v) - rl0;\n            return (rFilter(r) ? r : 0) + b2;\n        };\n\n        ax.g2c = function(v) {\n            return ax.l2c(v + rl0 - b2);\n        };\n\n        ax.g2p = function(v) { return v * m; };\n        ax.c2p = function(v) { return ax.g2p(ax.c2g(v)); };\n    };\n}\n\nfunction toRadians(v, unit) {\n    return unit === 'degrees' ? deg2rad(v) : v;\n}\n\nfunction fromRadians(v, unit) {\n    return unit === 'degrees' ? rad2deg(v) : v;\n}\n\nfunction setConvertAngular(ax, polarLayout) {\n    var axType = ax.type;\n\n    if(axType === 'linear') {\n        var _d2c = ax.d2c;\n        var _c2d = ax.c2d;\n\n        ax.d2c = function(v, unit) { return toRadians(_d2c(v), unit); };\n        ax.c2d = function(v, unit) { return _c2d(fromRadians(v, unit)); };\n    }\n\n    // override makeCalcdata to handle thetaunit and special theta0/dtheta logic\n    ax.makeCalcdata = function(trace, coord) {\n        var arrayIn = trace[coord];\n        var len = trace._length;\n        var arrayOut, i;\n\n        var _d2c = function(v) { return ax.d2c(v, trace.thetaunit); };\n\n        if(arrayIn) {\n            if(Lib.isTypedArray(arrayIn) && axType === 'linear') {\n                if(len === arrayIn.length) {\n                    return arrayIn;\n                } else if(arrayIn.subarray) {\n                    return arrayIn.subarray(0, len);\n                }\n            }\n\n            arrayOut = new Array(len);\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = _d2c(arrayIn[i]);\n            }\n        } else {\n            var coord0 = coord + '0';\n            var dcoord = 'd' + coord;\n            var v0 = (coord0 in trace) ? _d2c(trace[coord0]) : 0;\n            var dv = (trace[dcoord]) ? _d2c(trace[dcoord]) : (ax.period || 2 * Math.PI) / len;\n\n            arrayOut = new Array(len);\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = v0 + i * dv;\n            }\n        }\n\n        return arrayOut;\n    };\n\n    // N.B. we mock the axis 'range' here\n    ax.setGeometry = function() {\n        var sector = polarLayout.sector;\n        var sectorInRad = sector.map(deg2rad);\n        var dir = {clockwise: -1, counterclockwise: 1}[ax.direction];\n        var rot = deg2rad(ax.rotation);\n\n        var rad2g = function(v) { return dir * v + rot; };\n        var g2rad = function(v) { return (v - rot) / dir; };\n\n        var rad2c, c2rad;\n        var rad2t, t2rad;\n\n        switch(axType) {\n            case 'linear':\n                c2rad = rad2c = Lib.identity;\n                t2rad = deg2rad;\n                rad2t = rad2deg;\n\n                // Set the angular range in degrees to make auto-tick computation cleaner,\n                // changing rotation/direction should not affect the angular tick value.\n                ax.range = Lib.isFullCircle(sectorInRad) ?\n                    [sector[0], sector[0] + 360] :\n                    sectorInRad.map(g2rad).map(rad2deg);\n                break;\n\n            case 'category':\n                var catLen = ax._categories.length;\n                var _period = ax.period ? Math.max(ax.period, catLen) : catLen;\n\n                // fallback in case all categories have been filtered out\n                if(_period === 0) _period = 1;\n\n                c2rad = t2rad = function(v) { return v * 2 * Math.PI / _period; };\n                rad2c = rad2t = function(v) { return v * _period / Math.PI / 2; };\n\n                ax.range = [0, _period];\n                break;\n        }\n\n        ax.c2g = function(v) { return rad2g(c2rad(v)); };\n        ax.g2c = function(v) { return rad2c(g2rad(v)); };\n\n        ax.t2g = function(v) { return rad2g(t2rad(v)); };\n        ax.g2t = function(v) { return rad2t(g2rad(v)); };\n    };\n}\n"]},"metadata":{},"sourceType":"script"}