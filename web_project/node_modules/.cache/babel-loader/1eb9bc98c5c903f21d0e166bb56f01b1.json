{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar modModule = require('./mod');\n\nvar mod = modModule.mod;\nvar modHalf = modModule.modHalf;\nvar PI = Math.PI;\nvar twoPI = 2 * PI;\n\nfunction deg2rad(deg) {\n  return deg / 180 * PI;\n}\n\nfunction rad2deg(rad) {\n  return rad / PI * 180;\n}\n/**\n * is sector a full circle?\n * ... this comes up a lot in SVG path-drawing routines\n *\n * N.B. we consider all sectors that span more that 2pi 'full' circles\n *\n * @param {2-item array} aBnds : angular bounds in *radians*\n * @return {boolean}\n */\n\n\nfunction isFullCircle(aBnds) {\n  return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-14;\n}\n/**\n * angular delta between angle 'a' and 'b'\n * solution taken from: https://stackoverflow.com/a/2007279\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular delta in *radians*\n */\n\n\nfunction angleDelta(a, b) {\n  return modHalf(b - a, twoPI);\n}\n/**\n * angular distance between angle 'a' and 'b'\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular distance in *radians*\n */\n\n\nfunction angleDist(a, b) {\n  return Math.abs(angleDelta(a, b));\n}\n/**\n * is angle inside sector?\n *\n * @param {number} a : angle to test in *radians*\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @param {boolean}\n */\n\n\nfunction isAngleInsideSector(a, aBnds) {\n  if (isFullCircle(aBnds)) return true;\n  var s0, s1;\n\n  if (aBnds[0] < aBnds[1]) {\n    s0 = aBnds[0];\n    s1 = aBnds[1];\n  } else {\n    s0 = aBnds[1];\n    s1 = aBnds[0];\n  }\n\n  s0 = mod(s0, twoPI);\n  s1 = mod(s1, twoPI);\n  if (s0 > s1) s1 += twoPI;\n  var a0 = mod(a, twoPI);\n  var a1 = a0 + twoPI;\n  return a0 >= s0 && a0 <= s1 || a1 >= s0 && a1 <= s1;\n}\n/**\n * is pt (r,a) inside sector?\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @return {boolean}\n */\n\n\nfunction isPtInsideSector(r, a, rBnds, aBnds) {\n  if (!isAngleInsideSector(a, aBnds)) return false;\n  var r0, r1;\n\n  if (rBnds[0] < rBnds[1]) {\n    r0 = rBnds[0];\n    r1 = rBnds[1];\n  } else {\n    r0 = rBnds[1];\n    r1 = rBnds[0];\n  }\n\n  return r >= r0 && r <= r1;\n} // common to pathArc, pathSector and pathAnnulus\n\n\nfunction _path(r0, r1, a0, a1, cx, cy, isClosed) {\n  cx = cx || 0;\n  cy = cy || 0;\n  var isCircle = isFullCircle([a0, a1]);\n  var aStart, aMid, aEnd;\n  var rStart, rEnd;\n\n  if (isCircle) {\n    aStart = 0;\n    aMid = PI;\n    aEnd = twoPI;\n  } else {\n    if (a0 < a1) {\n      aStart = a0;\n      aEnd = a1;\n    } else {\n      aStart = a1;\n      aEnd = a0;\n    }\n  }\n\n  if (r0 < r1) {\n    rStart = r0;\n    rEnd = r1;\n  } else {\n    rStart = r1;\n    rEnd = r0;\n  } // N.B. svg coordinates here, where y increases downward\n\n\n  function pt(r, a) {\n    return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];\n  }\n\n  var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;\n\n  function arc(r, a, cw) {\n    return 'A' + [r, r] + ' ' + [0, largeArc, cw] + ' ' + pt(r, a);\n  }\n\n  var p;\n\n  if (isCircle) {\n    if (rStart === null) {\n      p = 'M' + pt(rEnd, aStart) + arc(rEnd, aMid, 0) + arc(rEnd, aEnd, 0) + 'Z';\n    } else {\n      p = 'M' + pt(rStart, aStart) + arc(rStart, aMid, 0) + arc(rStart, aEnd, 0) + 'Z' + 'M' + pt(rEnd, aStart) + arc(rEnd, aMid, 1) + arc(rEnd, aEnd, 1) + 'Z';\n    }\n  } else {\n    if (rStart === null) {\n      p = 'M' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);\n      if (isClosed) p += 'L0,0Z';\n    } else {\n      p = 'M' + pt(rStart, aStart) + 'L' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0) + 'L' + pt(rStart, aEnd) + arc(rStart, aStart, 1) + 'Z';\n    }\n  }\n\n  return p;\n}\n/**\n * path an arc\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\n\n\nfunction pathArc(r, a0, a1, cx, cy) {\n  return _path(null, r, a0, a1, cx, cy, 0);\n}\n/**\n * path a sector\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\n\n\nfunction pathSector(r, a0, a1, cx, cy) {\n  return _path(null, r, a0, a1, cx, cy, 1);\n}\n/**\n * path an annulus\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\n\n\nfunction pathAnnulus(r0, r1, a0, a1, cx, cy) {\n  return _path(r0, r1, a0, a1, cx, cy, 1);\n}\n\nmodule.exports = {\n  deg2rad: deg2rad,\n  rad2deg: rad2deg,\n  angleDelta: angleDelta,\n  angleDist: angleDist,\n  isFullCircle: isFullCircle,\n  isAngleInsideSector: isAngleInsideSector,\n  isPtInsideSector: isPtInsideSector,\n  pathArc: pathArc,\n  pathSector: pathSector,\n  pathAnnulus: pathAnnulus\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/lib/angles.js"],"names":["modModule","require","mod","modHalf","PI","Math","twoPI","deg2rad","deg","rad2deg","rad","isFullCircle","aBnds","abs","angleDelta","a","b","angleDist","isAngleInsideSector","s0","s1","a0","a1","isPtInsideSector","r","rBnds","r0","r1","_path","cx","cy","isClosed","isCircle","aStart","aMid","aEnd","rStart","rEnd","pt","cos","sin","largeArc","arc","cw","p","pathArc","pathSector","pathAnnulus","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar modModule = require('./mod');\nvar mod = modModule.mod;\nvar modHalf = modModule.modHalf;\n\nvar PI = Math.PI;\nvar twoPI = 2 * PI;\n\nfunction deg2rad(deg) { return deg / 180 * PI; }\n\nfunction rad2deg(rad) { return rad / PI * 180; }\n\n/**\n * is sector a full circle?\n * ... this comes up a lot in SVG path-drawing routines\n *\n * N.B. we consider all sectors that span more that 2pi 'full' circles\n *\n * @param {2-item array} aBnds : angular bounds in *radians*\n * @return {boolean}\n */\nfunction isFullCircle(aBnds) {\n    return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-14;\n}\n\n/**\n * angular delta between angle 'a' and 'b'\n * solution taken from: https://stackoverflow.com/a/2007279\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular delta in *radians*\n */\nfunction angleDelta(a, b) {\n    return modHalf(b - a, twoPI);\n}\n\n/**\n * angular distance between angle 'a' and 'b'\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular distance in *radians*\n */\nfunction angleDist(a, b) {\n    return Math.abs(angleDelta(a, b));\n}\n\n/**\n * is angle inside sector?\n *\n * @param {number} a : angle to test in *radians*\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @param {boolean}\n */\nfunction isAngleInsideSector(a, aBnds) {\n    if(isFullCircle(aBnds)) return true;\n\n    var s0, s1;\n\n    if(aBnds[0] < aBnds[1]) {\n        s0 = aBnds[0];\n        s1 = aBnds[1];\n    } else {\n        s0 = aBnds[1];\n        s1 = aBnds[0];\n    }\n\n    s0 = mod(s0, twoPI);\n    s1 = mod(s1, twoPI);\n    if(s0 > s1) s1 += twoPI;\n\n    var a0 = mod(a, twoPI);\n    var a1 = a0 + twoPI;\n\n    return (a0 >= s0 && a0 <= s1) || (a1 >= s0 && a1 <= s1);\n}\n\n/**\n * is pt (r,a) inside sector?\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @return {boolean}\n */\nfunction isPtInsideSector(r, a, rBnds, aBnds) {\n    if(!isAngleInsideSector(a, aBnds)) return false;\n\n    var r0, r1;\n\n    if(rBnds[0] < rBnds[1]) {\n        r0 = rBnds[0];\n        r1 = rBnds[1];\n    } else {\n        r0 = rBnds[1];\n        r1 = rBnds[0];\n    }\n\n    return r >= r0 && r <= r1;\n}\n\n// common to pathArc, pathSector and pathAnnulus\nfunction _path(r0, r1, a0, a1, cx, cy, isClosed) {\n    cx = cx || 0;\n    cy = cy || 0;\n\n    var isCircle = isFullCircle([a0, a1]);\n    var aStart, aMid, aEnd;\n    var rStart, rEnd;\n\n    if(isCircle) {\n        aStart = 0;\n        aMid = PI;\n        aEnd = twoPI;\n    } else {\n        if(a0 < a1) {\n            aStart = a0;\n            aEnd = a1;\n        } else {\n            aStart = a1;\n            aEnd = a0;\n        }\n    }\n\n    if(r0 < r1) {\n        rStart = r0;\n        rEnd = r1;\n    } else {\n        rStart = r1;\n        rEnd = r0;\n    }\n\n    // N.B. svg coordinates here, where y increases downward\n    function pt(r, a) {\n        return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];\n    }\n\n    var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;\n    function arc(r, a, cw) {\n        return 'A' + [r, r] + ' ' + [0, largeArc, cw] + ' ' + pt(r, a);\n    }\n\n    var p;\n\n    if(isCircle) {\n        if(rStart === null) {\n            p = 'M' + pt(rEnd, aStart) +\n                arc(rEnd, aMid, 0) +\n                arc(rEnd, aEnd, 0) + 'Z';\n        } else {\n            p = 'M' + pt(rStart, aStart) +\n                arc(rStart, aMid, 0) +\n                arc(rStart, aEnd, 0) + 'Z' +\n                'M' + pt(rEnd, aStart) +\n                arc(rEnd, aMid, 1) +\n                arc(rEnd, aEnd, 1) + 'Z';\n        }\n    } else {\n        if(rStart === null) {\n            p = 'M' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);\n            if(isClosed) p += 'L0,0Z';\n        } else {\n            p = 'M' + pt(rStart, aStart) +\n                'L' + pt(rEnd, aStart) +\n                arc(rEnd, aEnd, 0) +\n                'L' + pt(rStart, aEnd) +\n                arc(rStart, aStart, 1) + 'Z';\n        }\n    }\n\n    return p;\n}\n\n/**\n * path an arc\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathArc(r, a0, a1, cx, cy) {\n    return _path(null, r, a0, a1, cx, cy, 0);\n}\n\n/**\n * path a sector\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathSector(r, a0, a1, cx, cy) {\n    return _path(null, r, a0, a1, cx, cy, 1);\n}\n\n/**\n * path an annulus\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathAnnulus(r0, r1, a0, a1, cx, cy) {\n    return _path(r0, r1, a0, a1, cx, cy, 1);\n}\n\nmodule.exports = {\n    deg2rad: deg2rad,\n    rad2deg: rad2deg,\n    angleDelta: angleDelta,\n    angleDist: angleDist,\n    isFullCircle: isFullCircle,\n    isAngleInsideSector: isAngleInsideSector,\n    isPtInsideSector: isPtInsideSector,\n    pathArc: pathArc,\n    pathSector: pathSector,\n    pathAnnulus: pathAnnulus\n};\n"]},"metadata":{},"sourceType":"script"}