{"ast":null,"code":"'use strict';\n\nvar inCircle = require('robust-in-sphere')[4];\n\nvar bsearch = require('binary-search-bounds');\n\nmodule.exports = delaunayRefine;\n\nfunction testFlip(points, triangulation, stack, a, b, x) {\n  var y = triangulation.opposite(a, b); //Test boundary edge\n\n  if (y < 0) {\n    return;\n  } //Swap edge if order flipped\n\n\n  if (b < a) {\n    var tmp = a;\n    a = b;\n    b = tmp;\n    tmp = x;\n    x = y;\n    y = tmp;\n  } //Test if edge is constrained\n\n\n  if (triangulation.isConstraint(a, b)) {\n    return;\n  } //Test if edge is delaunay\n\n\n  if (inCircle(points[a], points[b], points[x], points[y]) < 0) {\n    stack.push(a, b);\n  }\n} //Assume edges are sorted lexicographically\n\n\nfunction delaunayRefine(points, triangulation) {\n  var stack = [];\n  var numPoints = points.length;\n  var stars = triangulation.stars;\n\n  for (var a = 0; a < numPoints; ++a) {\n    var star = stars[a];\n\n    for (var j = 1; j < star.length; j += 2) {\n      var b = star[j]; //If order is not consistent, then skip edge\n\n      if (b < a) {\n        continue;\n      } //Check if edge is constrained\n\n\n      if (triangulation.isConstraint(a, b)) {\n        continue;\n      } //Find opposite edge\n\n\n      var x = star[j - 1],\n          y = -1;\n\n      for (var k = 1; k < star.length; k += 2) {\n        if (star[k - 1] === b) {\n          y = star[k];\n          break;\n        }\n      } //If this is a boundary edge, don't flip it\n\n\n      if (y < 0) {\n        continue;\n      } //If edge is in circle, flip it\n\n\n      if (inCircle(points[a], points[b], points[x], points[y]) < 0) {\n        stack.push(a, b);\n      }\n    }\n  }\n\n  while (stack.length > 0) {\n    var b = stack.pop();\n    var a = stack.pop(); //Find opposite pairs\n\n    var x = -1,\n        y = -1;\n    var star = stars[a];\n\n    for (var i = 1; i < star.length; i += 2) {\n      var s = star[i - 1];\n      var t = star[i];\n\n      if (s === b) {\n        y = t;\n      } else if (t === b) {\n        x = s;\n      }\n    } //If x/y are both valid then skip edge\n\n\n    if (x < 0 || y < 0) {\n      continue;\n    } //If edge is now delaunay, then don't flip it\n\n\n    if (inCircle(points[a], points[b], points[x], points[y]) >= 0) {\n      continue;\n    } //Flip the edge\n\n\n    triangulation.flip(a, b); //Test flipping neighboring edges\n\n    testFlip(points, triangulation, stack, x, a, y);\n    testFlip(points, triangulation, stack, a, y, x);\n    testFlip(points, triangulation, stack, y, b, x);\n    testFlip(points, triangulation, stack, b, x, y);\n  }\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/cdt2d/lib/delaunay.js"],"names":["inCircle","require","bsearch","module","exports","delaunayRefine","testFlip","points","triangulation","stack","a","b","x","y","opposite","tmp","isConstraint","push","numPoints","length","stars","star","j","k","pop","i","s","t","flip"],"mappings":"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","sourcesContent":["'use strict'\n\nvar inCircle = require('robust-in-sphere')[4]\nvar bsearch = require('binary-search-bounds')\n\nmodule.exports = delaunayRefine\n\nfunction testFlip(points, triangulation, stack, a, b, x) {\n  var y = triangulation.opposite(a, b)\n\n  //Test boundary edge\n  if(y < 0) {\n    return\n  }\n\n  //Swap edge if order flipped\n  if(b < a) {\n    var tmp = a\n    a = b\n    b = tmp\n    tmp = x\n    x = y\n    y = tmp\n  }\n\n  //Test if edge is constrained\n  if(triangulation.isConstraint(a, b)) {\n    return\n  }\n\n  //Test if edge is delaunay\n  if(inCircle(points[a], points[b], points[x], points[y]) < 0) {\n    stack.push(a, b)\n  }\n}\n\n//Assume edges are sorted lexicographically\nfunction delaunayRefine(points, triangulation) {\n  var stack = []\n\n  var numPoints = points.length\n  var stars = triangulation.stars\n  for(var a=0; a<numPoints; ++a) {\n    var star = stars[a]\n    for(var j=1; j<star.length; j+=2) {\n      var b = star[j]\n\n      //If order is not consistent, then skip edge\n      if(b < a) {\n        continue\n      }\n\n      //Check if edge is constrained\n      if(triangulation.isConstraint(a, b)) {\n        continue\n      }\n\n      //Find opposite edge\n      var x = star[j-1], y = -1\n      for(var k=1; k<star.length; k+=2) {\n        if(star[k-1] === b) {\n          y = star[k]\n          break\n        }\n      }\n\n      //If this is a boundary edge, don't flip it\n      if(y < 0) {\n        continue\n      }\n\n      //If edge is in circle, flip it\n      if(inCircle(points[a], points[b], points[x], points[y]) < 0) {\n        stack.push(a, b)\n      }\n    }\n  }\n\n  while(stack.length > 0) {\n    var b = stack.pop()\n    var a = stack.pop()\n\n    //Find opposite pairs\n    var x = -1, y = -1\n    var star = stars[a]\n    for(var i=1; i<star.length; i+=2) {\n      var s = star[i-1]\n      var t = star[i]\n      if(s === b) {\n        y = t\n      } else if(t === b) {\n        x = s\n      }\n    }\n\n    //If x/y are both valid then skip edge\n    if(x < 0 || y < 0) {\n      continue\n    }\n\n    //If edge is now delaunay, then don't flip it\n    if(inCircle(points[a], points[b], points[x], points[y]) >= 0) {\n      continue\n    }\n\n    //Flip the edge\n    triangulation.flip(a, b)\n\n    //Test flipping neighboring edges\n    testFlip(points, triangulation, stack, x, a, y)\n    testFlip(points, triangulation, stack, a, y, x)\n    testFlip(points, triangulation, stack, y, b, x)\n    testFlip(points, triangulation, stack, b, x, y)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}