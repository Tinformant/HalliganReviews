{"ast":null,"code":"'use strict';\n\nmodule.exports = convexHullnD;\n\nvar ich = require('incremental-convex-hull');\n\nvar aff = require('affine-hull');\n\nfunction permute(points, front) {\n  var n = points.length;\n  var npoints = new Array(n);\n\n  for (var i = 0; i < front.length; ++i) {\n    npoints[i] = points[front[i]];\n  }\n\n  var ptr = front.length;\n\n  for (var i = 0; i < n; ++i) {\n    if (front.indexOf(i) < 0) {\n      npoints[ptr++] = points[i];\n    }\n  }\n\n  return npoints;\n}\n\nfunction invPermute(cells, front) {\n  var nc = cells.length;\n  var nf = front.length;\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      var x = c[j];\n\n      if (x < nf) {\n        c[j] = front[x];\n      } else {\n        x = x - nf;\n\n        for (var k = 0; k < nf; ++k) {\n          if (x >= front[k]) {\n            x += 1;\n          }\n        }\n\n        c[j] = x;\n      }\n    }\n  }\n\n  return cells;\n}\n\nfunction convexHullnD(points, d) {\n  try {\n    return ich(points, true);\n  } catch (e) {\n    //If point set is degenerate, try to find a basis and rerun it\n    var ah = aff(points);\n\n    if (ah.length <= d) {\n      //No basis, no try\n      return [];\n    }\n\n    var npoints = permute(points, ah);\n    var nhull = ich(npoints, true);\n    return invPermute(nhull, ah);\n  }\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/convex-hull/lib/chnd.js"],"names":["module","exports","convexHullnD","ich","require","aff","permute","points","front","n","length","npoints","Array","i","ptr","indexOf","invPermute","cells","nc","nf","c","j","x","k","d","e","ah","nhull"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,YAAjB;;AAEA,IAAIC,GAAG,GAAGC,OAAO,CAAC,yBAAD,CAAjB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,aAAD,CAAjB;;AAEA,SAASE,OAAT,CAAiBC,MAAjB,EAAyBC,KAAzB,EAAgC;AAC9B,MAAIC,CAAC,GAAGF,MAAM,CAACG,MAAf;AACA,MAAIC,OAAO,GAAG,IAAIC,KAAJ,CAAUH,CAAV,CAAd;;AACA,OAAI,IAAII,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACL,KAAK,CAACE,MAArB,EAA6B,EAAEG,CAA/B,EAAkC;AAChCF,IAAAA,OAAO,CAACE,CAAD,CAAP,GAAaN,MAAM,CAACC,KAAK,CAACK,CAAD,CAAN,CAAnB;AACD;;AACD,MAAIC,GAAG,GAAGN,KAAK,CAACE,MAAhB;;AACA,OAAI,IAAIG,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACJ,CAAf,EAAkB,EAAEI,CAApB,EAAuB;AACrB,QAAGL,KAAK,CAACO,OAAN,CAAcF,CAAd,IAAmB,CAAtB,EAAyB;AACvBF,MAAAA,OAAO,CAACG,GAAG,EAAJ,CAAP,GAAiBP,MAAM,CAACM,CAAD,CAAvB;AACD;AACF;;AACD,SAAOF,OAAP;AACD;;AAED,SAASK,UAAT,CAAoBC,KAApB,EAA2BT,KAA3B,EAAkC;AAChC,MAAIU,EAAE,GAAGD,KAAK,CAACP,MAAf;AACA,MAAIS,EAAE,GAAGX,KAAK,CAACE,MAAf;;AACA,OAAI,IAAIG,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACK,EAAf,EAAmB,EAAEL,CAArB,EAAwB;AACtB,QAAIO,CAAC,GAAGH,KAAK,CAACJ,CAAD,CAAb;;AACA,SAAI,IAAIQ,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACD,CAAC,CAACV,MAAjB,EAAyB,EAAEW,CAA3B,EAA8B;AAC5B,UAAIC,CAAC,GAAGF,CAAC,CAACC,CAAD,CAAT;;AACA,UAAGC,CAAC,GAAGH,EAAP,EAAW;AACTC,QAAAA,CAAC,CAACC,CAAD,CAAD,GAAOb,KAAK,CAACc,CAAD,CAAZ;AACD,OAFD,MAEO;AACLA,QAAAA,CAAC,GAAGA,CAAC,GAAGH,EAAR;;AACA,aAAI,IAAII,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACJ,EAAf,EAAmB,EAAEI,CAArB,EAAwB;AACtB,cAAGD,CAAC,IAAId,KAAK,CAACe,CAAD,CAAb,EAAkB;AAChBD,YAAAA,CAAC,IAAI,CAAL;AACD;AACF;;AACDF,QAAAA,CAAC,CAACC,CAAD,CAAD,GAAOC,CAAP;AACD;AACF;AACF;;AACD,SAAOL,KAAP;AACD;;AAED,SAASf,YAAT,CAAsBK,MAAtB,EAA8BiB,CAA9B,EAAiC;AAC/B,MAAI;AACF,WAAOrB,GAAG,CAACI,MAAD,EAAS,IAAT,CAAV;AACD,GAFD,CAEE,OAAMkB,CAAN,EAAS;AACT;AACA,QAAIC,EAAE,GAAGrB,GAAG,CAACE,MAAD,CAAZ;;AACA,QAAGmB,EAAE,CAAChB,MAAH,IAAac,CAAhB,EAAmB;AACjB;AACA,aAAO,EAAP;AACD;;AACD,QAAIb,OAAO,GAAGL,OAAO,CAACC,MAAD,EAASmB,EAAT,CAArB;AACA,QAAIC,KAAK,GAAKxB,GAAG,CAACQ,OAAD,EAAU,IAAV,CAAjB;AACA,WAAOK,UAAU,CAACW,KAAD,EAAQD,EAAR,CAAjB;AACD;AACF","sourcesContent":["'use strict'\n\nmodule.exports = convexHullnD\n\nvar ich = require('incremental-convex-hull')\nvar aff = require('affine-hull')\n\nfunction permute(points, front) {\n  var n = points.length\n  var npoints = new Array(n)\n  for(var i=0; i<front.length; ++i) {\n    npoints[i] = points[front[i]]\n  }\n  var ptr = front.length\n  for(var i=0; i<n; ++i) {\n    if(front.indexOf(i) < 0) {\n      npoints[ptr++] = points[i]\n    }\n  }\n  return npoints\n}\n\nfunction invPermute(cells, front) {\n  var nc = cells.length\n  var nf = front.length\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    for(var j=0; j<c.length; ++j) {\n      var x = c[j]\n      if(x < nf) {\n        c[j] = front[x]\n      } else {\n        x = x - nf\n        for(var k=0; k<nf; ++k) {\n          if(x >= front[k]) {\n            x += 1\n          }\n        }\n        c[j] = x\n      }\n    }\n  }\n  return cells\n}\n\nfunction convexHullnD(points, d) {\n  try {\n    return ich(points, true)\n  } catch(e) {\n    //If point set is degenerate, try to find a basis and rerun it\n    var ah = aff(points)\n    if(ah.length <= d) {\n      //No basis, no try\n      return []\n    }\n    var npoints = permute(points, ah)\n    var nhull   = ich(npoints, true)\n    return invPermute(nhull, ah)\n  }\n}"]},"metadata":{},"sourceType":"script"}