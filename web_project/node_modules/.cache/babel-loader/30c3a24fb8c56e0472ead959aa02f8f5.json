{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar _ = Lib._;\n\nmodule.exports = function calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n  var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n  var cd = []; // N.B. violin reuses same Box.calc\n\n  var numKey = trace.type === 'violin' ? '_numViolins' : '_numBoxes';\n  var i, j;\n  var valAxis, valLetter;\n  var posAxis, posLetter;\n\n  if (trace.orientation === 'h') {\n    valAxis = xa;\n    valLetter = 'x';\n    posAxis = ya;\n    posLetter = 'y';\n  } else {\n    valAxis = ya;\n    valLetter = 'y';\n    posAxis = xa;\n    posLetter = 'x';\n  }\n\n  var posArray = getPos(trace, posLetter, posAxis, fullLayout[numKey]);\n  var dv = Lib.distinctVals(posArray);\n  var posDistinct = dv.vals;\n  var dPos = dv.minDiff / 2; // item in trace calcdata\n\n  var cdi; // array of {v: v, i, i} sample pts\n\n  var pts; // values of the `pts` array of objects\n\n  var boxVals; // length of sample\n\n  var N; // single sample point\n\n  var pt; // single sample value\n\n  var v; // filter function for outlier pts\n  // outlier definition based on http://www.physics.csbsju.edu/stats/box2.html\n\n  var ptFilterFn = (trace.boxpoints || trace.points) === 'all' ? Lib.identity : function (pt) {\n    return pt.v < cdi.lf || pt.v > cdi.uf;\n  };\n\n  if (trace._hasPreCompStats) {\n    var valArrayRaw = trace[valLetter];\n\n    var d2c = function (k) {\n      return valAxis.d2c((trace[k] || [])[i]);\n    };\n\n    var minVal = Infinity;\n    var maxVal = -Infinity;\n\n    for (i = 0; i < trace._length; i++) {\n      var posi = posArray[i];\n      if (!isNumeric(posi)) continue;\n      cdi = {};\n      cdi.pos = cdi[posLetter] = posi;\n      cdi.q1 = d2c('q1');\n      cdi.med = d2c('median');\n      cdi.q3 = d2c('q3');\n      pts = [];\n\n      if (valArrayRaw && Lib.isArrayOrTypedArray(valArrayRaw[i])) {\n        for (j = 0; j < valArrayRaw[i].length; j++) {\n          v = valAxis.d2c(valArrayRaw[i][j]);\n\n          if (v !== BADNUM) {\n            pt = {\n              v: v,\n              i: [i, j]\n            };\n            arraysToCalcdata(pt, trace, [i, j]);\n            pts.push(pt);\n          }\n        }\n      }\n\n      cdi.pts = pts.sort(sortByVal);\n      boxVals = cdi[valLetter] = pts.map(extractVal);\n      N = boxVals.length;\n\n      if (cdi.med !== BADNUM && cdi.q1 !== BADNUM && cdi.q3 !== BADNUM && cdi.med >= cdi.q1 && cdi.q3 >= cdi.med) {\n        var lf = d2c('lowerfence');\n        cdi.lf = lf !== BADNUM && lf <= cdi.q1 ? lf : computeLowerFence(cdi, boxVals, N);\n        var uf = d2c('upperfence');\n        cdi.uf = uf !== BADNUM && uf >= cdi.q3 ? uf : computeUpperFence(cdi, boxVals, N);\n        var mean = d2c('mean');\n        cdi.mean = mean !== BADNUM ? mean : N ? Lib.mean(boxVals, N) : (cdi.q1 + cdi.q3) / 2;\n        var sd = d2c('sd');\n        cdi.sd = mean !== BADNUM && sd >= 0 ? sd : N ? Lib.stdev(boxVals, N, cdi.mean) : cdi.q3 - cdi.q1;\n        cdi.lo = computeLowerOutlierBound(cdi);\n        cdi.uo = computeUpperOutlierBound(cdi);\n        var ns = d2c('notchspan');\n        ns = ns !== BADNUM && ns > 0 ? ns : computeNotchSpan(cdi, N);\n        cdi.ln = cdi.med - ns;\n        cdi.un = cdi.med + ns;\n        var imin = cdi.lf;\n        var imax = cdi.uf;\n\n        if (trace.boxpoints && boxVals.length) {\n          imin = Math.min(imin, boxVals[0]);\n          imax = Math.max(imax, boxVals[N - 1]);\n        }\n\n        if (trace.notched) {\n          imin = Math.min(imin, cdi.ln);\n          imax = Math.max(imax, cdi.un);\n        }\n\n        cdi.min = imin;\n        cdi.max = imax;\n      } else {\n        Lib.warn(['Invalid input - make sure that q1 <= median <= q3', 'q1 = ' + cdi.q1, 'median = ' + cdi.med, 'q3 = ' + cdi.q3].join('\\n'));\n        var v0;\n\n        if (cdi.med !== BADNUM) {\n          v0 = cdi.med;\n        } else if (cdi.q1 !== BADNUM) {\n          if (cdi.q3 !== BADNUM) v0 = (cdi.q1 + cdi.q3) / 2;else v0 = cdi.q1;\n        } else if (cdi.q3 !== BADNUM) {\n          v0 = cdi.q3;\n        } else {\n          v0 = 0;\n        } // draw box as line segment\n\n\n        cdi.med = v0;\n        cdi.q1 = cdi.q3 = v0;\n        cdi.lf = cdi.uf = v0;\n        cdi.mean = cdi.sd = v0;\n        cdi.ln = cdi.un = v0;\n        cdi.min = cdi.max = v0;\n      }\n\n      minVal = Math.min(minVal, cdi.min);\n      maxVal = Math.max(maxVal, cdi.max);\n      cdi.pts2 = pts.filter(ptFilterFn);\n      cd.push(cdi);\n    }\n\n    trace._extremes[valAxis._id] = Axes.findExtremes(valAxis, [minVal, maxVal], {\n      padded: true\n    });\n  } else {\n    var valArray = valAxis.makeCalcdata(trace, valLetter);\n    var posBins = makeBins(posDistinct, dPos);\n    var pLen = posDistinct.length;\n    var ptsPerBin = initNestedArray(pLen); // bin pts info per position bins\n\n    for (i = 0; i < trace._length; i++) {\n      v = valArray[i];\n      if (!isNumeric(v)) continue;\n      var n = Lib.findBin(posArray[i], posBins);\n\n      if (n >= 0 && n < pLen) {\n        pt = {\n          v: v,\n          i: i\n        };\n        arraysToCalcdata(pt, trace, i);\n        ptsPerBin[n].push(pt);\n      }\n    }\n\n    var minLowerNotch = Infinity;\n    var maxUpperNotch = -Infinity;\n    var quartilemethod = trace.quartilemethod;\n    var usesExclusive = quartilemethod === 'exclusive';\n    var usesInclusive = quartilemethod === 'inclusive'; // build calcdata trace items, one item per distinct position\n\n    for (i = 0; i < pLen; i++) {\n      if (ptsPerBin[i].length > 0) {\n        cdi = {};\n        cdi.pos = cdi[posLetter] = posDistinct[i];\n        pts = cdi.pts = ptsPerBin[i].sort(sortByVal);\n        boxVals = cdi[valLetter] = pts.map(extractVal);\n        N = boxVals.length;\n        cdi.min = boxVals[0];\n        cdi.max = boxVals[N - 1];\n        cdi.mean = Lib.mean(boxVals, N);\n        cdi.sd = Lib.stdev(boxVals, N, cdi.mean);\n        cdi.med = Lib.interp(boxVals, 0.5);\n\n        if (N % 2 && (usesExclusive || usesInclusive)) {\n          var lower;\n          var upper;\n\n          if (usesExclusive) {\n            // do NOT include the median in either half\n            lower = boxVals.slice(0, N / 2);\n            upper = boxVals.slice(N / 2 + 1);\n          } else if (usesInclusive) {\n            // include the median in either half\n            lower = boxVals.slice(0, N / 2 + 1);\n            upper = boxVals.slice(N / 2);\n          }\n\n          cdi.q1 = Lib.interp(lower, 0.5);\n          cdi.q3 = Lib.interp(upper, 0.5);\n        } else {\n          cdi.q1 = Lib.interp(boxVals, 0.25);\n          cdi.q3 = Lib.interp(boxVals, 0.75);\n        } // lower and upper fences\n\n\n        cdi.lf = computeLowerFence(cdi, boxVals, N);\n        cdi.uf = computeUpperFence(cdi, boxVals, N); // lower and upper outliers bounds\n\n        cdi.lo = computeLowerOutlierBound(cdi);\n        cdi.uo = computeUpperOutlierBound(cdi); // lower and upper notches\n\n        var mci = computeNotchSpan(cdi, N);\n        cdi.ln = cdi.med - mci;\n        cdi.un = cdi.med + mci;\n        minLowerNotch = Math.min(minLowerNotch, cdi.ln);\n        maxUpperNotch = Math.max(maxUpperNotch, cdi.un);\n        cdi.pts2 = pts.filter(ptFilterFn);\n        cd.push(cdi);\n      }\n    }\n\n    trace._extremes[valAxis._id] = Axes.findExtremes(valAxis, trace.notched ? valArray.concat([minLowerNotch, maxUpperNotch]) : valArray, {\n      padded: true\n    });\n  }\n\n  calcSelection(cd, trace);\n\n  if (cd.length > 0) {\n    cd[0].t = {\n      num: fullLayout[numKey],\n      dPos: dPos,\n      posLetter: posLetter,\n      valLetter: valLetter,\n      labels: {\n        med: _(gd, 'median:'),\n        min: _(gd, 'min:'),\n        q1: _(gd, 'q1:'),\n        q3: _(gd, 'q3:'),\n        max: _(gd, 'max:'),\n        mean: trace.boxmean === 'sd' ? _(gd, 'mean ± σ:') : _(gd, 'mean:'),\n        lf: _(gd, 'lower fence:'),\n        uf: _(gd, 'upper fence:')\n      }\n    };\n    fullLayout[numKey]++;\n    return cd;\n  } else {\n    return [{\n      t: {\n        empty: true\n      }\n    }];\n  }\n}; // In vertical (horizontal) box plots:\n// if no x (y) data, use x0 (y0), or name\n// so if you want one box\n// per trace, set x0 (y0) to the x (y) value or category for this trace\n// (or set x (y) to a constant array matching y (x))\n\n\nfunction getPos(trace, posLetter, posAxis, num) {\n  var hasPosArray = (posLetter in trace);\n  var hasPos0 = (posLetter + '0' in trace);\n  var hasPosStep = ('d' + posLetter in trace);\n\n  if (hasPosArray || hasPos0 && hasPosStep) {\n    return posAxis.makeCalcdata(trace, posLetter);\n  }\n\n  var pos0;\n\n  if (hasPos0) {\n    pos0 = trace[posLetter + '0'];\n  } else if ('name' in trace && (posAxis.type === 'category' || isNumeric(trace.name) && ['linear', 'log'].indexOf(posAxis.type) !== -1 || Lib.isDateTime(trace.name) && posAxis.type === 'date')) {\n    pos0 = trace.name;\n  } else {\n    pos0 = num;\n  }\n\n  var pos0c = posAxis.type === 'multicategory' ? posAxis.r2c_just_indices(pos0) : posAxis.d2c(pos0, 0, trace[posLetter + 'calendar']);\n  var len = trace._length;\n  var out = new Array(len);\n\n  for (var i = 0; i < len; i++) out[i] = pos0c;\n\n  return out;\n}\n\nfunction makeBins(x, dx) {\n  var len = x.length;\n  var bins = new Array(len + 1);\n\n  for (var i = 0; i < len; i++) {\n    bins[i] = x[i] - dx;\n  }\n\n  bins[len] = x[len - 1] + dx;\n  return bins;\n}\n\nfunction initNestedArray(len) {\n  var arr = new Array(len);\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = [];\n  }\n\n  return arr;\n}\n\nvar TRACE_TO_CALC = {\n  text: 'tx',\n  hovertext: 'htx'\n};\n\nfunction arraysToCalcdata(pt, trace, ptNumber) {\n  for (var k in TRACE_TO_CALC) {\n    if (Lib.isArrayOrTypedArray(trace[k])) {\n      if (Array.isArray(ptNumber)) {\n        if (Lib.isArrayOrTypedArray(trace[k][ptNumber[0]])) {\n          pt[TRACE_TO_CALC[k]] = trace[k][ptNumber[0]][ptNumber[1]];\n        }\n      } else {\n        pt[TRACE_TO_CALC[k]] = trace[k][ptNumber];\n      }\n    }\n  }\n}\n\nfunction calcSelection(cd, trace) {\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    for (var i = 0; i < cd.length; i++) {\n      var pts = cd[i].pts || [];\n      var ptNumber2cdIndex = {};\n\n      for (var j = 0; j < pts.length; j++) {\n        ptNumber2cdIndex[pts[j].i] = j;\n      }\n\n      Lib.tagSelected(pts, trace, ptNumber2cdIndex);\n    }\n  }\n}\n\nfunction sortByVal(a, b) {\n  return a.v - b.v;\n}\n\nfunction extractVal(o) {\n  return o.v;\n} // last point below 1.5 * IQR\n\n\nfunction computeLowerFence(cdi, boxVals, N) {\n  if (N === 0) return cdi.q1;\n  return Math.min(cdi.q1, boxVals[Math.min(Lib.findBin(2.5 * cdi.q1 - 1.5 * cdi.q3, boxVals, true) + 1, N - 1)]);\n} // last point above 1.5 * IQR\n\n\nfunction computeUpperFence(cdi, boxVals, N) {\n  if (N === 0) return cdi.q3;\n  return Math.max(cdi.q3, boxVals[Math.max(Lib.findBin(2.5 * cdi.q3 - 1.5 * cdi.q1, boxVals), 0)]);\n} // 3 IQR below (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\n\n\nfunction computeLowerOutlierBound(cdi) {\n  return 4 * cdi.q1 - 3 * cdi.q3;\n} // 3 IQR above (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\n\n\nfunction computeUpperOutlierBound(cdi) {\n  return 4 * cdi.q3 - 3 * cdi.q1;\n} // 95% confidence intervals for median\n\n\nfunction computeNotchSpan(cdi, N) {\n  if (N === 0) return 0;\n  return 1.57 * (cdi.q3 - cdi.q1) / Math.sqrt(N);\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/box/calc.js"],"names":["isNumeric","require","Axes","Lib","BADNUM","_","module","exports","calc","gd","trace","fullLayout","_fullLayout","xa","getFromId","xaxis","ya","yaxis","cd","numKey","type","i","j","valAxis","valLetter","posAxis","posLetter","orientation","posArray","getPos","dv","distinctVals","posDistinct","vals","dPos","minDiff","cdi","pts","boxVals","N","pt","v","ptFilterFn","boxpoints","points","identity","lf","uf","_hasPreCompStats","valArrayRaw","d2c","k","minVal","Infinity","maxVal","_length","posi","pos","q1","med","q3","isArrayOrTypedArray","length","arraysToCalcdata","push","sort","sortByVal","map","extractVal","computeLowerFence","computeUpperFence","mean","sd","stdev","lo","computeLowerOutlierBound","uo","computeUpperOutlierBound","ns","computeNotchSpan","ln","un","imin","imax","Math","min","max","notched","warn","join","v0","pts2","filter","_extremes","_id","findExtremes","padded","valArray","makeCalcdata","posBins","makeBins","pLen","ptsPerBin","initNestedArray","n","findBin","minLowerNotch","maxUpperNotch","quartilemethod","usesExclusive","usesInclusive","interp","lower","upper","slice","mci","concat","calcSelection","t","num","labels","boxmean","empty","hasPosArray","hasPos0","hasPosStep","pos0","name","indexOf","isDateTime","pos0c","r2c_just_indices","len","out","Array","x","dx","bins","arr","TRACE_TO_CALC","text","hovertext","ptNumber","isArray","selectedpoints","ptNumber2cdIndex","tagSelected","a","b","o","sqrt"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar _ = Lib._;\n\nmodule.exports = function calc(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n    var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n    var cd = [];\n\n    // N.B. violin reuses same Box.calc\n    var numKey = trace.type === 'violin' ? '_numViolins' : '_numBoxes';\n\n    var i, j;\n    var valAxis, valLetter;\n    var posAxis, posLetter;\n\n    if(trace.orientation === 'h') {\n        valAxis = xa;\n        valLetter = 'x';\n        posAxis = ya;\n        posLetter = 'y';\n    } else {\n        valAxis = ya;\n        valLetter = 'y';\n        posAxis = xa;\n        posLetter = 'x';\n    }\n\n    var posArray = getPos(trace, posLetter, posAxis, fullLayout[numKey]);\n    var dv = Lib.distinctVals(posArray);\n    var posDistinct = dv.vals;\n    var dPos = dv.minDiff / 2;\n\n    // item in trace calcdata\n    var cdi;\n    // array of {v: v, i, i} sample pts\n    var pts;\n    // values of the `pts` array of objects\n    var boxVals;\n    // length of sample\n    var N;\n    // single sample point\n    var pt;\n    // single sample value\n    var v;\n\n    // filter function for outlier pts\n    // outlier definition based on http://www.physics.csbsju.edu/stats/box2.html\n    var ptFilterFn = (trace.boxpoints || trace.points) === 'all' ?\n        Lib.identity :\n        function(pt) { return (pt.v < cdi.lf || pt.v > cdi.uf); };\n\n    if(trace._hasPreCompStats) {\n        var valArrayRaw = trace[valLetter];\n        var d2c = function(k) { return valAxis.d2c((trace[k] || [])[i]); };\n        var minVal = Infinity;\n        var maxVal = -Infinity;\n\n        for(i = 0; i < trace._length; i++) {\n            var posi = posArray[i];\n            if(!isNumeric(posi)) continue;\n\n            cdi = {};\n            cdi.pos = cdi[posLetter] = posi;\n\n            cdi.q1 = d2c('q1');\n            cdi.med = d2c('median');\n            cdi.q3 = d2c('q3');\n\n            pts = [];\n            if(valArrayRaw && Lib.isArrayOrTypedArray(valArrayRaw[i])) {\n                for(j = 0; j < valArrayRaw[i].length; j++) {\n                    v = valAxis.d2c(valArrayRaw[i][j]);\n                    if(v !== BADNUM) {\n                        pt = {v: v, i: [i, j]};\n                        arraysToCalcdata(pt, trace, [i, j]);\n                        pts.push(pt);\n                    }\n                }\n            }\n            cdi.pts = pts.sort(sortByVal);\n            boxVals = cdi[valLetter] = pts.map(extractVal);\n            N = boxVals.length;\n\n            if(cdi.med !== BADNUM && cdi.q1 !== BADNUM && cdi.q3 !== BADNUM &&\n                cdi.med >= cdi.q1 && cdi.q3 >= cdi.med\n            ) {\n                var lf = d2c('lowerfence');\n                cdi.lf = (lf !== BADNUM && lf <= cdi.q1) ?\n                    lf :\n                    computeLowerFence(cdi, boxVals, N);\n\n                var uf = d2c('upperfence');\n                cdi.uf = (uf !== BADNUM && uf >= cdi.q3) ?\n                    uf :\n                    computeUpperFence(cdi, boxVals, N);\n\n                var mean = d2c('mean');\n                cdi.mean = (mean !== BADNUM) ?\n                    mean :\n                    (N ? Lib.mean(boxVals, N) : (cdi.q1 + cdi.q3) / 2);\n\n                var sd = d2c('sd');\n                cdi.sd = (mean !== BADNUM && sd >= 0) ?\n                    sd :\n                    (N ? Lib.stdev(boxVals, N, cdi.mean) : (cdi.q3 - cdi.q1));\n\n                cdi.lo = computeLowerOutlierBound(cdi);\n                cdi.uo = computeUpperOutlierBound(cdi);\n\n                var ns = d2c('notchspan');\n                ns = (ns !== BADNUM && ns > 0) ? ns : computeNotchSpan(cdi, N);\n                cdi.ln = cdi.med - ns;\n                cdi.un = cdi.med + ns;\n\n                var imin = cdi.lf;\n                var imax = cdi.uf;\n                if(trace.boxpoints && boxVals.length) {\n                    imin = Math.min(imin, boxVals[0]);\n                    imax = Math.max(imax, boxVals[N - 1]);\n                }\n                if(trace.notched) {\n                    imin = Math.min(imin, cdi.ln);\n                    imax = Math.max(imax, cdi.un);\n                }\n                cdi.min = imin;\n                cdi.max = imax;\n            } else {\n                Lib.warn([\n                    'Invalid input - make sure that q1 <= median <= q3',\n                    'q1 = ' + cdi.q1,\n                    'median = ' + cdi.med,\n                    'q3 = ' + cdi.q3\n                ].join('\\n'));\n\n                var v0;\n                if(cdi.med !== BADNUM) {\n                    v0 = cdi.med;\n                } else if(cdi.q1 !== BADNUM) {\n                    if(cdi.q3 !== BADNUM) v0 = (cdi.q1 + cdi.q3) / 2;\n                    else v0 = cdi.q1;\n                } else if(cdi.q3 !== BADNUM) {\n                    v0 = cdi.q3;\n                } else {\n                    v0 = 0;\n                }\n\n                // draw box as line segment\n                cdi.med = v0;\n                cdi.q1 = cdi.q3 = v0;\n                cdi.lf = cdi.uf = v0;\n                cdi.mean = cdi.sd = v0;\n                cdi.ln = cdi.un = v0;\n                cdi.min = cdi.max = v0;\n            }\n\n            minVal = Math.min(minVal, cdi.min);\n            maxVal = Math.max(maxVal, cdi.max);\n\n            cdi.pts2 = pts.filter(ptFilterFn);\n\n            cd.push(cdi);\n        }\n\n        trace._extremes[valAxis._id] = Axes.findExtremes(valAxis,\n            [minVal, maxVal],\n            {padded: true}\n        );\n    } else {\n        var valArray = valAxis.makeCalcdata(trace, valLetter);\n        var posBins = makeBins(posDistinct, dPos);\n        var pLen = posDistinct.length;\n        var ptsPerBin = initNestedArray(pLen);\n\n        // bin pts info per position bins\n        for(i = 0; i < trace._length; i++) {\n            v = valArray[i];\n            if(!isNumeric(v)) continue;\n\n            var n = Lib.findBin(posArray[i], posBins);\n            if(n >= 0 && n < pLen) {\n                pt = {v: v, i: i};\n                arraysToCalcdata(pt, trace, i);\n                ptsPerBin[n].push(pt);\n            }\n        }\n\n        var minLowerNotch = Infinity;\n        var maxUpperNotch = -Infinity;\n\n        var quartilemethod = trace.quartilemethod;\n        var usesExclusive = quartilemethod === 'exclusive';\n        var usesInclusive = quartilemethod === 'inclusive';\n\n        // build calcdata trace items, one item per distinct position\n        for(i = 0; i < pLen; i++) {\n            if(ptsPerBin[i].length > 0) {\n                cdi = {};\n                cdi.pos = cdi[posLetter] = posDistinct[i];\n\n                pts = cdi.pts = ptsPerBin[i].sort(sortByVal);\n                boxVals = cdi[valLetter] = pts.map(extractVal);\n                N = boxVals.length;\n\n                cdi.min = boxVals[0];\n                cdi.max = boxVals[N - 1];\n                cdi.mean = Lib.mean(boxVals, N);\n                cdi.sd = Lib.stdev(boxVals, N, cdi.mean);\n                cdi.med = Lib.interp(boxVals, 0.5);\n\n                if((N % 2) && (usesExclusive || usesInclusive)) {\n                    var lower;\n                    var upper;\n\n                    if(usesExclusive) {\n                        // do NOT include the median in either half\n                        lower = boxVals.slice(0, N / 2);\n                        upper = boxVals.slice(N / 2 + 1);\n                    } else if(usesInclusive) {\n                        // include the median in either half\n                        lower = boxVals.slice(0, N / 2 + 1);\n                        upper = boxVals.slice(N / 2);\n                    }\n\n                    cdi.q1 = Lib.interp(lower, 0.5);\n                    cdi.q3 = Lib.interp(upper, 0.5);\n                } else {\n                    cdi.q1 = Lib.interp(boxVals, 0.25);\n                    cdi.q3 = Lib.interp(boxVals, 0.75);\n                }\n\n                // lower and upper fences\n                cdi.lf = computeLowerFence(cdi, boxVals, N);\n                cdi.uf = computeUpperFence(cdi, boxVals, N);\n\n                // lower and upper outliers bounds\n                cdi.lo = computeLowerOutlierBound(cdi);\n                cdi.uo = computeUpperOutlierBound(cdi);\n\n                // lower and upper notches\n                var mci = computeNotchSpan(cdi, N);\n                cdi.ln = cdi.med - mci;\n                cdi.un = cdi.med + mci;\n                minLowerNotch = Math.min(minLowerNotch, cdi.ln);\n                maxUpperNotch = Math.max(maxUpperNotch, cdi.un);\n\n                cdi.pts2 = pts.filter(ptFilterFn);\n\n                cd.push(cdi);\n            }\n        }\n\n        trace._extremes[valAxis._id] = Axes.findExtremes(valAxis,\n            trace.notched ? valArray.concat([minLowerNotch, maxUpperNotch]) : valArray,\n            {padded: true}\n        );\n    }\n\n    calcSelection(cd, trace);\n\n    if(cd.length > 0) {\n        cd[0].t = {\n            num: fullLayout[numKey],\n            dPos: dPos,\n            posLetter: posLetter,\n            valLetter: valLetter,\n            labels: {\n                med: _(gd, 'median:'),\n                min: _(gd, 'min:'),\n                q1: _(gd, 'q1:'),\n                q3: _(gd, 'q3:'),\n                max: _(gd, 'max:'),\n                mean: trace.boxmean === 'sd' ? _(gd, 'mean ± σ:') : _(gd, 'mean:'),\n                lf: _(gd, 'lower fence:'),\n                uf: _(gd, 'upper fence:')\n            }\n        };\n\n        fullLayout[numKey]++;\n        return cd;\n    } else {\n        return [{t: {empty: true}}];\n    }\n};\n\n// In vertical (horizontal) box plots:\n// if no x (y) data, use x0 (y0), or name\n// so if you want one box\n// per trace, set x0 (y0) to the x (y) value or category for this trace\n// (or set x (y) to a constant array matching y (x))\nfunction getPos(trace, posLetter, posAxis, num) {\n    var hasPosArray = posLetter in trace;\n    var hasPos0 = posLetter + '0' in trace;\n    var hasPosStep = 'd' + posLetter in trace;\n\n    if(hasPosArray || (hasPos0 && hasPosStep)) {\n        return posAxis.makeCalcdata(trace, posLetter);\n    }\n\n    var pos0;\n    if(hasPos0) {\n        pos0 = trace[posLetter + '0'];\n    } else if('name' in trace && (\n        posAxis.type === 'category' || (\n            isNumeric(trace.name) &&\n            ['linear', 'log'].indexOf(posAxis.type) !== -1\n        ) || (\n            Lib.isDateTime(trace.name) &&\n            posAxis.type === 'date'\n        )\n    )) {\n        pos0 = trace.name;\n    } else {\n        pos0 = num;\n    }\n\n    var pos0c = posAxis.type === 'multicategory' ?\n        posAxis.r2c_just_indices(pos0) :\n        posAxis.d2c(pos0, 0, trace[posLetter + 'calendar']);\n\n    var len = trace._length;\n    var out = new Array(len);\n    for(var i = 0; i < len; i++) out[i] = pos0c;\n\n    return out;\n}\n\nfunction makeBins(x, dx) {\n    var len = x.length;\n    var bins = new Array(len + 1);\n\n    for(var i = 0; i < len; i++) {\n        bins[i] = x[i] - dx;\n    }\n    bins[len] = x[len - 1] + dx;\n\n    return bins;\n}\n\nfunction initNestedArray(len) {\n    var arr = new Array(len);\n    for(var i = 0; i < len; i++) {\n        arr[i] = [];\n    }\n    return arr;\n}\n\nvar TRACE_TO_CALC = {\n    text: 'tx',\n    hovertext: 'htx'\n};\n\nfunction arraysToCalcdata(pt, trace, ptNumber) {\n    for(var k in TRACE_TO_CALC) {\n        if(Lib.isArrayOrTypedArray(trace[k])) {\n            if(Array.isArray(ptNumber)) {\n                if(Lib.isArrayOrTypedArray(trace[k][ptNumber[0]])) {\n                    pt[TRACE_TO_CALC[k]] = trace[k][ptNumber[0]][ptNumber[1]];\n                }\n            } else {\n                pt[TRACE_TO_CALC[k]] = trace[k][ptNumber];\n            }\n        }\n    }\n}\n\nfunction calcSelection(cd, trace) {\n    if(Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n        for(var i = 0; i < cd.length; i++) {\n            var pts = cd[i].pts || [];\n            var ptNumber2cdIndex = {};\n\n            for(var j = 0; j < pts.length; j++) {\n                ptNumber2cdIndex[pts[j].i] = j;\n            }\n\n            Lib.tagSelected(pts, trace, ptNumber2cdIndex);\n        }\n    }\n}\n\nfunction sortByVal(a, b) { return a.v - b.v; }\n\nfunction extractVal(o) { return o.v; }\n\n// last point below 1.5 * IQR\nfunction computeLowerFence(cdi, boxVals, N) {\n    if(N === 0) return cdi.q1;\n    return Math.min(\n        cdi.q1,\n        boxVals[Math.min(\n            Lib.findBin(2.5 * cdi.q1 - 1.5 * cdi.q3, boxVals, true) + 1,\n            N - 1\n        )]\n    );\n}\n\n// last point above 1.5 * IQR\nfunction computeUpperFence(cdi, boxVals, N) {\n    if(N === 0) return cdi.q3;\n    return Math.max(\n        cdi.q3,\n        boxVals[Math.max(\n            Lib.findBin(2.5 * cdi.q3 - 1.5 * cdi.q1, boxVals),\n            0\n        )]\n    );\n}\n\n// 3 IQR below (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeLowerOutlierBound(cdi) {\n    return 4 * cdi.q1 - 3 * cdi.q3;\n}\n\n// 3 IQR above (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeUpperOutlierBound(cdi) {\n    return 4 * cdi.q3 - 3 * cdi.q1;\n}\n\n// 95% confidence intervals for median\nfunction computeNotchSpan(cdi, N) {\n    if(N === 0) return 0;\n    return 1.57 * (cdi.q3 - cdi.q1) / Math.sqrt(N);\n}\n"]},"metadata":{},"sourceType":"script"}