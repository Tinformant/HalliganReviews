{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar countryRegex = require('country-regex');\n\nvar turfArea = require('@turf/area');\n\nvar turfCentroid = require('@turf/centroid');\n\nvar turfBbox = require('@turf/bbox');\n\nvar identity = require('./identity');\n\nvar loggers = require('./loggers');\n\nvar isPlainObject = require('./is_plain_object');\n\nvar nestedProperty = require('./nested_property');\n\nvar polygon = require('./polygon'); // make list of all country iso3 ids from at runtime\n\n\nvar countryIds = Object.keys(countryRegex);\nvar locationmodeToIdFinder = {\n  'ISO-3': identity,\n  'USA-states': identity,\n  'country names': countryNameToISO3\n};\n\nfunction countryNameToISO3(countryName) {\n  for (var i = 0; i < countryIds.length; i++) {\n    var iso3 = countryIds[i];\n    var regex = new RegExp(countryRegex[iso3]);\n    if (regex.test(countryName.trim().toLowerCase())) return iso3;\n  }\n\n  loggers.log('Unrecognized country name: ' + countryName + '.');\n  return false;\n}\n\nfunction locationToFeature(locationmode, location, features) {\n  if (!location || typeof location !== 'string') return false;\n  var locationId = locationmodeToIdFinder[locationmode](location);\n  var filteredFeatures;\n  var f, i;\n\n  if (locationId) {\n    if (locationmode === 'USA-states') {\n      // Filter out features out in USA\n      //\n      // This is important as the Natural Earth files\n      // include state/provinces from USA, Canada, Australia and Brazil\n      // which have some overlay in their two-letter ids. For example,\n      // 'WA' is used for both Washington state and Western Australia.\n      filteredFeatures = [];\n\n      for (i = 0; i < features.length; i++) {\n        f = features[i];\n\n        if (f.properties && f.properties.gu && f.properties.gu === 'USA') {\n          filteredFeatures.push(f);\n        }\n      }\n    } else {\n      filteredFeatures = features;\n    }\n\n    for (i = 0; i < filteredFeatures.length; i++) {\n      f = filteredFeatures[i];\n      if (f.id === locationId) return f;\n    }\n\n    loggers.log(['Location with id', locationId, 'does not have a matching topojson feature at this resolution.'].join(' '));\n  }\n\n  return false;\n}\n\nfunction feature2polygons(feature) {\n  var geometry = feature.geometry;\n  var coords = geometry.coordinates;\n  var loc = feature.id;\n  var polygons = [];\n  var appendPolygon, j, k, m;\n\n  function doesCrossAntiMerdian(pts) {\n    for (var l = 0; l < pts.length - 1; l++) {\n      if (pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n    }\n\n    return null;\n  }\n\n  if (loc === 'RUS' || loc === 'FJI') {\n    // Russia and Fiji have landmasses that cross the antimeridian,\n    // we need to add +360 to their longitude coordinates, so that\n    // polygon 'contains' doesn't get confused when crossing the antimeridian.\n    //\n    // Note that other countries have polygons on either side of the antimeridian\n    // (e.g. some Aleutian island for the USA), but those don't confuse\n    // the 'contains' method; these are skipped here.\n    appendPolygon = function (_pts) {\n      var pts;\n\n      if (doesCrossAntiMerdian(_pts) === null) {\n        pts = _pts;\n      } else {\n        pts = new Array(_pts.length);\n\n        for (m = 0; m < _pts.length; m++) {\n          // do not mutate calcdata[i][j].geojson !!\n          pts[m] = [_pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0], _pts[m][1]];\n        }\n      }\n\n      polygons.push(polygon.tester(pts));\n    };\n  } else if (loc === 'ATA') {\n    // Antarctica has a landmass that wraps around every longitudes which\n    // confuses the 'contains' methods.\n    appendPolygon = function (pts) {\n      var crossAntiMeridianIndex = doesCrossAntiMerdian(pts); // polygon that do not cross anti-meridian need no special handling\n\n      if (crossAntiMeridianIndex === null) {\n        return polygons.push(polygon.tester(pts));\n      } // stitch polygon by adding pt over South Pole,\n      // so that it covers the projected region covers all latitudes\n      //\n      // Note that the algorithm below only works for polygons that\n      // start and end on longitude -180 (like the ones built by\n      // https://github.com/etpinard/sane-topojson).\n\n\n      var stitch = new Array(pts.length + 1);\n      var si = 0;\n\n      for (m = 0; m < pts.length; m++) {\n        if (m > crossAntiMeridianIndex) {\n          stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n        } else if (m === crossAntiMeridianIndex) {\n          stitch[si++] = pts[m];\n          stitch[si++] = [pts[m][0], -90];\n        } else {\n          stitch[si++] = pts[m];\n        }\n      } // polygon.tester by default appends pt[0] to the points list,\n      // we must remove it here, to avoid a jump in longitude from 180 to -180,\n      // that would confuse the 'contains' method\n\n\n      var tester = polygon.tester(stitch);\n      tester.pts.pop();\n      polygons.push(tester);\n    };\n  } else {\n    // otherwise using same array ref is fine\n    appendPolygon = function (pts) {\n      polygons.push(polygon.tester(pts));\n    };\n  }\n\n  switch (geometry.type) {\n    case 'MultiPolygon':\n      for (j = 0; j < coords.length; j++) {\n        for (k = 0; k < coords[j].length; k++) {\n          appendPolygon(coords[j][k]);\n        }\n      }\n\n      break;\n\n    case 'Polygon':\n      for (j = 0; j < coords.length; j++) {\n        appendPolygon(coords[j]);\n      }\n\n      break;\n  }\n\n  return polygons;\n}\n\nfunction getTraceGeojson(trace) {\n  var g = trace.geojson;\n  var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n  var geojsonIn = typeof g === 'string' ? PlotlyGeoAssets[g] : g; // This should not happen, but just in case something goes\n  // really wrong when fetching the GeoJSON\n\n  if (!isPlainObject(geojsonIn)) {\n    loggers.error('Oops ... something went wrong when fetching ' + g);\n    return false;\n  }\n\n  return geojsonIn;\n}\n\nfunction extractTraceFeature(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var geojsonIn = getTraceGeojson(trace);\n  if (!geojsonIn) return false;\n  var lookup = {};\n  var featuresOut = [];\n  var i;\n\n  for (i = 0; i < trace._length; i++) {\n    var cdi = calcTrace[i];\n\n    if (cdi.loc || cdi.loc === 0) {\n      lookup[cdi.loc] = cdi;\n    }\n  }\n\n  function appendFeature(fIn) {\n    var id = nestedProperty(fIn, trace.featureidkey || 'id').get();\n    var cdi = lookup[id];\n\n    if (cdi) {\n      var geometry = fIn.geometry;\n\n      if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n        var fOut = {\n          type: 'Feature',\n          id: id,\n          geometry: geometry,\n          properties: {}\n        }; // Compute centroid, add it to the properties\n\n        fOut.properties.ct = findCentroid(fOut); // Mutate in in/out features into calcdata\n\n        cdi.fIn = fIn;\n        cdi.fOut = fOut;\n        featuresOut.push(fOut);\n      } else {\n        loggers.log(['Location', cdi.loc, 'does not have a valid GeoJSON geometry.', 'Traces with locationmode *geojson-id* only support', '*Polygon* and *MultiPolygon* geometries.'].join(' '));\n      }\n    } // remove key from lookup, so that we can track (if any)\n    // the locations that did not have a corresponding GeoJSON feature\n\n\n    delete lookup[id];\n  }\n\n  switch (geojsonIn.type) {\n    case 'FeatureCollection':\n      var featuresIn = geojsonIn.features;\n\n      for (i = 0; i < featuresIn.length; i++) {\n        appendFeature(featuresIn[i]);\n      }\n\n      break;\n\n    case 'Feature':\n      appendFeature(geojsonIn);\n      break;\n\n    default:\n      loggers.warn(['Invalid GeoJSON type', (geojsonIn.type || 'none') + '.', 'Traces with locationmode *geojson-id* only support', '*FeatureCollection* and *Feature* types.'].join(' '));\n      return false;\n  }\n\n  for (var loc in lookup) {\n    loggers.log(['Location *' + loc + '*', 'does not have a matching feature with id-key', '*' + trace.featureidkey + '*.'].join(' '));\n  }\n\n  return featuresOut;\n} // TODO this find the centroid of the polygon of maxArea\n// (just like we currently do for geo choropleth polygons),\n// maybe instead it would make more sense to compute the centroid\n// of each polygon and consider those on hover/select\n\n\nfunction findCentroid(feature) {\n  var geometry = feature.geometry;\n  var poly;\n\n  if (geometry.type === 'MultiPolygon') {\n    var coords = geometry.coordinates;\n    var maxArea = 0;\n\n    for (var i = 0; i < coords.length; i++) {\n      var polyi = {\n        type: 'Polygon',\n        coordinates: coords[i]\n      };\n      var area = turfArea.default(polyi);\n\n      if (area > maxArea) {\n        maxArea = area;\n        poly = polyi;\n      }\n    }\n  } else {\n    poly = geometry;\n  }\n\n  return turfCentroid.default(poly).geometry.coordinates;\n}\n\nfunction fetchTraceGeoData(calcData) {\n  var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n  var promises = [];\n\n  function fetch(url) {\n    return new Promise(function (resolve, reject) {\n      d3.json(url, function (err, d) {\n        if (err) {\n          delete PlotlyGeoAssets[url];\n          var msg = err.status === 404 ? 'GeoJSON at URL \"' + url + '\" does not exist.' : 'Unexpected error while fetching from ' + url;\n          return reject(new Error(msg));\n        }\n\n        PlotlyGeoAssets[url] = d;\n        return resolve(d);\n      });\n    });\n  }\n\n  function wait(url) {\n    return new Promise(function (resolve, reject) {\n      var cnt = 0;\n      var interval = setInterval(function () {\n        if (PlotlyGeoAssets[url] && PlotlyGeoAssets[url] !== 'pending') {\n          clearInterval(interval);\n          return resolve(PlotlyGeoAssets[url]);\n        }\n\n        if (cnt > 100) {\n          clearInterval(interval);\n          return reject('Unexpected error while fetching from ' + url);\n        }\n\n        cnt++;\n      }, 50);\n    });\n  }\n\n  for (var i = 0; i < calcData.length; i++) {\n    var trace = calcData[i][0].trace;\n    var url = trace.geojson;\n\n    if (typeof url === 'string') {\n      if (!PlotlyGeoAssets[url]) {\n        PlotlyGeoAssets[url] = 'pending';\n        promises.push(fetch(url));\n      } else if (PlotlyGeoAssets[url] === 'pending') {\n        promises.push(wait(url));\n      }\n    }\n  }\n\n  return promises;\n} // TODO `turf/bbox` gives wrong result when the input feature/geometry\n// crosses the anti-meridian. We should try to implement our own bbox logic.\n\n\nfunction computeBbox(d) {\n  return turfBbox.default(d);\n}\n\nmodule.exports = {\n  locationToFeature: locationToFeature,\n  feature2polygons: feature2polygons,\n  getTraceGeojson: getTraceGeojson,\n  extractTraceFeature: extractTraceFeature,\n  fetchTraceGeoData: fetchTraceGeoData,\n  computeBbox: computeBbox\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/lib/geo_location_utils.js"],"names":["d3","require","countryRegex","turfArea","turfCentroid","turfBbox","identity","loggers","isPlainObject","nestedProperty","polygon","countryIds","Object","keys","locationmodeToIdFinder","countryNameToISO3","countryName","i","length","iso3","regex","RegExp","test","trim","toLowerCase","log","locationToFeature","locationmode","location","features","locationId","filteredFeatures","f","properties","gu","push","id","join","feature2polygons","feature","geometry","coords","coordinates","loc","polygons","appendPolygon","j","k","m","doesCrossAntiMerdian","pts","l","_pts","Array","tester","crossAntiMeridianIndex","stitch","si","pop","type","getTraceGeojson","trace","g","geojson","PlotlyGeoAssets","window","geojsonIn","error","extractTraceFeature","calcTrace","lookup","featuresOut","_length","cdi","appendFeature","fIn","featureidkey","get","fOut","ct","findCentroid","featuresIn","warn","poly","maxArea","polyi","area","default","fetchTraceGeoData","calcData","promises","fetch","url","Promise","resolve","reject","json","err","d","msg","status","Error","wait","cnt","interval","setInterval","clearInterval","computeBbox","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar countryRegex = require('country-regex');\nvar turfArea = require('@turf/area');\nvar turfCentroid = require('@turf/centroid');\nvar turfBbox = require('@turf/bbox');\n\nvar identity = require('./identity');\nvar loggers = require('./loggers');\nvar isPlainObject = require('./is_plain_object');\nvar nestedProperty = require('./nested_property');\nvar polygon = require('./polygon');\n\n// make list of all country iso3 ids from at runtime\nvar countryIds = Object.keys(countryRegex);\n\nvar locationmodeToIdFinder = {\n    'ISO-3': identity,\n    'USA-states': identity,\n    'country names': countryNameToISO3\n};\n\nfunction countryNameToISO3(countryName) {\n    for(var i = 0; i < countryIds.length; i++) {\n        var iso3 = countryIds[i];\n        var regex = new RegExp(countryRegex[iso3]);\n\n        if(regex.test(countryName.trim().toLowerCase())) return iso3;\n    }\n\n    loggers.log('Unrecognized country name: ' + countryName + '.');\n\n    return false;\n}\n\nfunction locationToFeature(locationmode, location, features) {\n    if(!location || typeof location !== 'string') return false;\n\n    var locationId = locationmodeToIdFinder[locationmode](location);\n    var filteredFeatures;\n    var f, i;\n\n    if(locationId) {\n        if(locationmode === 'USA-states') {\n            // Filter out features out in USA\n            //\n            // This is important as the Natural Earth files\n            // include state/provinces from USA, Canada, Australia and Brazil\n            // which have some overlay in their two-letter ids. For example,\n            // 'WA' is used for both Washington state and Western Australia.\n            filteredFeatures = [];\n            for(i = 0; i < features.length; i++) {\n                f = features[i];\n                if(f.properties && f.properties.gu && f.properties.gu === 'USA') {\n                    filteredFeatures.push(f);\n                }\n            }\n        } else {\n            filteredFeatures = features;\n        }\n\n        for(i = 0; i < filteredFeatures.length; i++) {\n            f = filteredFeatures[i];\n            if(f.id === locationId) return f;\n        }\n\n        loggers.log([\n            'Location with id', locationId,\n            'does not have a matching topojson feature at this resolution.'\n        ].join(' '));\n    }\n\n    return false;\n}\n\nfunction feature2polygons(feature) {\n    var geometry = feature.geometry;\n    var coords = geometry.coordinates;\n    var loc = feature.id;\n\n    var polygons = [];\n    var appendPolygon, j, k, m;\n\n    function doesCrossAntiMerdian(pts) {\n        for(var l = 0; l < pts.length - 1; l++) {\n            if(pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n        }\n        return null;\n    }\n\n    if(loc === 'RUS' || loc === 'FJI') {\n        // Russia and Fiji have landmasses that cross the antimeridian,\n        // we need to add +360 to their longitude coordinates, so that\n        // polygon 'contains' doesn't get confused when crossing the antimeridian.\n        //\n        // Note that other countries have polygons on either side of the antimeridian\n        // (e.g. some Aleutian island for the USA), but those don't confuse\n        // the 'contains' method; these are skipped here.\n        appendPolygon = function(_pts) {\n            var pts;\n\n            if(doesCrossAntiMerdian(_pts) === null) {\n                pts = _pts;\n            } else {\n                pts = new Array(_pts.length);\n                for(m = 0; m < _pts.length; m++) {\n                    // do not mutate calcdata[i][j].geojson !!\n                    pts[m] = [\n                        _pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0],\n                        _pts[m][1]\n                    ];\n                }\n            }\n\n            polygons.push(polygon.tester(pts));\n        };\n    } else if(loc === 'ATA') {\n        // Antarctica has a landmass that wraps around every longitudes which\n        // confuses the 'contains' methods.\n        appendPolygon = function(pts) {\n            var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);\n\n            // polygon that do not cross anti-meridian need no special handling\n            if(crossAntiMeridianIndex === null) {\n                return polygons.push(polygon.tester(pts));\n            }\n\n            // stitch polygon by adding pt over South Pole,\n            // so that it covers the projected region covers all latitudes\n            //\n            // Note that the algorithm below only works for polygons that\n            // start and end on longitude -180 (like the ones built by\n            // https://github.com/etpinard/sane-topojson).\n            var stitch = new Array(pts.length + 1);\n            var si = 0;\n\n            for(m = 0; m < pts.length; m++) {\n                if(m > crossAntiMeridianIndex) {\n                    stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n                } else if(m === crossAntiMeridianIndex) {\n                    stitch[si++] = pts[m];\n                    stitch[si++] = [pts[m][0], -90];\n                } else {\n                    stitch[si++] = pts[m];\n                }\n            }\n\n            // polygon.tester by default appends pt[0] to the points list,\n            // we must remove it here, to avoid a jump in longitude from 180 to -180,\n            // that would confuse the 'contains' method\n            var tester = polygon.tester(stitch);\n            tester.pts.pop();\n            polygons.push(tester);\n        };\n    } else {\n        // otherwise using same array ref is fine\n        appendPolygon = function(pts) {\n            polygons.push(polygon.tester(pts));\n        };\n    }\n\n    switch(geometry.type) {\n        case 'MultiPolygon':\n            for(j = 0; j < coords.length; j++) {\n                for(k = 0; k < coords[j].length; k++) {\n                    appendPolygon(coords[j][k]);\n                }\n            }\n            break;\n        case 'Polygon':\n            for(j = 0; j < coords.length; j++) {\n                appendPolygon(coords[j]);\n            }\n            break;\n    }\n\n    return polygons;\n}\n\nfunction getTraceGeojson(trace) {\n    var g = trace.geojson;\n    var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n    var geojsonIn = typeof g === 'string' ? PlotlyGeoAssets[g] : g;\n\n    // This should not happen, but just in case something goes\n    // really wrong when fetching the GeoJSON\n    if(!isPlainObject(geojsonIn)) {\n        loggers.error('Oops ... something went wrong when fetching ' + g);\n        return false;\n    }\n\n    return geojsonIn;\n}\n\nfunction extractTraceFeature(calcTrace) {\n    var trace = calcTrace[0].trace;\n\n    var geojsonIn = getTraceGeojson(trace);\n    if(!geojsonIn) return false;\n\n    var lookup = {};\n    var featuresOut = [];\n    var i;\n\n    for(i = 0; i < trace._length; i++) {\n        var cdi = calcTrace[i];\n        if(cdi.loc || cdi.loc === 0) {\n            lookup[cdi.loc] = cdi;\n        }\n    }\n\n    function appendFeature(fIn) {\n        var id = nestedProperty(fIn, trace.featureidkey || 'id').get();\n        var cdi = lookup[id];\n\n        if(cdi) {\n            var geometry = fIn.geometry;\n\n            if(geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n                var fOut = {\n                    type: 'Feature',\n                    id: id,\n                    geometry: geometry,\n                    properties: {}\n                };\n\n                // Compute centroid, add it to the properties\n                fOut.properties.ct = findCentroid(fOut);\n\n                // Mutate in in/out features into calcdata\n                cdi.fIn = fIn;\n                cdi.fOut = fOut;\n\n                featuresOut.push(fOut);\n            } else {\n                loggers.log([\n                    'Location', cdi.loc, 'does not have a valid GeoJSON geometry.',\n                    'Traces with locationmode *geojson-id* only support',\n                    '*Polygon* and *MultiPolygon* geometries.'\n                ].join(' '));\n            }\n        }\n\n        // remove key from lookup, so that we can track (if any)\n        // the locations that did not have a corresponding GeoJSON feature\n        delete lookup[id];\n    }\n\n    switch(geojsonIn.type) {\n        case 'FeatureCollection':\n            var featuresIn = geojsonIn.features;\n            for(i = 0; i < featuresIn.length; i++) {\n                appendFeature(featuresIn[i]);\n            }\n            break;\n        case 'Feature':\n            appendFeature(geojsonIn);\n            break;\n        default:\n            loggers.warn([\n                'Invalid GeoJSON type', (geojsonIn.type || 'none') + '.',\n                'Traces with locationmode *geojson-id* only support',\n                '*FeatureCollection* and *Feature* types.'\n            ].join(' '));\n            return false;\n    }\n\n    for(var loc in lookup) {\n        loggers.log([\n            'Location *' + loc + '*',\n            'does not have a matching feature with id-key',\n            '*' + trace.featureidkey + '*.'\n        ].join(' '));\n    }\n\n    return featuresOut;\n}\n\n// TODO this find the centroid of the polygon of maxArea\n// (just like we currently do for geo choropleth polygons),\n// maybe instead it would make more sense to compute the centroid\n// of each polygon and consider those on hover/select\nfunction findCentroid(feature) {\n    var geometry = feature.geometry;\n    var poly;\n\n    if(geometry.type === 'MultiPolygon') {\n        var coords = geometry.coordinates;\n        var maxArea = 0;\n\n        for(var i = 0; i < coords.length; i++) {\n            var polyi = {type: 'Polygon', coordinates: coords[i]};\n            var area = turfArea.default(polyi);\n            if(area > maxArea) {\n                maxArea = area;\n                poly = polyi;\n            }\n        }\n    } else {\n        poly = geometry;\n    }\n\n    return turfCentroid.default(poly).geometry.coordinates;\n}\n\nfunction fetchTraceGeoData(calcData) {\n    var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n    var promises = [];\n\n    function fetch(url) {\n        return new Promise(function(resolve, reject) {\n            d3.json(url, function(err, d) {\n                if(err) {\n                    delete PlotlyGeoAssets[url];\n                    var msg = err.status === 404 ?\n                        ('GeoJSON at URL \"' + url + '\" does not exist.') :\n                        ('Unexpected error while fetching from ' + url);\n                    return reject(new Error(msg));\n                }\n\n                PlotlyGeoAssets[url] = d;\n                return resolve(d);\n            });\n        });\n    }\n\n    function wait(url) {\n        return new Promise(function(resolve, reject) {\n            var cnt = 0;\n            var interval = setInterval(function() {\n                if(PlotlyGeoAssets[url] && PlotlyGeoAssets[url] !== 'pending') {\n                    clearInterval(interval);\n                    return resolve(PlotlyGeoAssets[url]);\n                }\n                if(cnt > 100) {\n                    clearInterval(interval);\n                    return reject('Unexpected error while fetching from ' + url);\n                }\n                cnt++;\n            }, 50);\n        });\n    }\n\n    for(var i = 0; i < calcData.length; i++) {\n        var trace = calcData[i][0].trace;\n        var url = trace.geojson;\n\n        if(typeof url === 'string') {\n            if(!PlotlyGeoAssets[url]) {\n                PlotlyGeoAssets[url] = 'pending';\n                promises.push(fetch(url));\n            } else if(PlotlyGeoAssets[url] === 'pending') {\n                promises.push(wait(url));\n            }\n        }\n    }\n\n    return promises;\n}\n\n// TODO `turf/bbox` gives wrong result when the input feature/geometry\n// crosses the anti-meridian. We should try to implement our own bbox logic.\nfunction computeBbox(d) {\n    return turfBbox.default(d);\n}\n\nmodule.exports = {\n    locationToFeature: locationToFeature,\n    feature2polygons: feature2polygons,\n    getTraceGeojson: getTraceGeojson,\n    extractTraceFeature: extractTraceFeature,\n    fetchTraceGeoData: fetchTraceGeoData,\n    computeBbox: computeBbox\n};\n"]},"metadata":{},"sourceType":"script"}