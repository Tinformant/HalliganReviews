{"ast":null,"code":"module.exports = slerp;\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > 0.000001) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/gl-quat/slerp.js"],"names":["module","exports","slerp","out","a","b","t","ax","ay","az","aw","bx","by","bz","bw","omega","cosom","sinom","scale0","scale1","Math","acos","sin"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,KAAjB;AAEA;;;;;;;;;;AASA,SAASA,KAAT,CAAgBC,GAAhB,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2BC,CAA3B,EAA8B;AAC5B;AACA;AAEA,MAAIC,EAAE,GAAGH,CAAC,CAAC,CAAD,CAAV;AAAA,MAAeI,EAAE,GAAGJ,CAAC,CAAC,CAAD,CAArB;AAAA,MAA0BK,EAAE,GAAGL,CAAC,CAAC,CAAD,CAAhC;AAAA,MAAqCM,EAAE,GAAGN,CAAC,CAAC,CAAD,CAA3C;AAAA,MACEO,EAAE,GAAGN,CAAC,CAAC,CAAD,CADR;AAAA,MACaO,EAAE,GAAGP,CAAC,CAAC,CAAD,CADnB;AAAA,MACwBQ,EAAE,GAAGR,CAAC,CAAC,CAAD,CAD9B;AAAA,MACmCS,EAAE,GAAGT,CAAC,CAAC,CAAD,CADzC;AAGA,MAAIU,KAAJ,EAAWC,KAAX,EAAkBC,KAAlB,EAAyBC,MAAzB,EAAiCC,MAAjC,CAP4B,CAS5B;;AACAH,EAAAA,KAAK,GAAGT,EAAE,GAAGI,EAAL,GAAUH,EAAE,GAAGI,EAAf,GAAoBH,EAAE,GAAGI,EAAzB,GAA8BH,EAAE,GAAGI,EAA3C,CAV4B,CAW5B;;AACA,MAAIE,KAAK,GAAG,GAAZ,EAAiB;AACfA,IAAAA,KAAK,GAAG,CAACA,KAAT;AACAL,IAAAA,EAAE,GAAG,CAACA,EAAN;AACAC,IAAAA,EAAE,GAAG,CAACA,EAAN;AACAC,IAAAA,EAAE,GAAG,CAACA,EAAN;AACAC,IAAAA,EAAE,GAAG,CAACA,EAAN;AACD,GAlB2B,CAmB5B;;;AACA,MAAK,MAAME,KAAP,GAAgB,QAApB,EAA8B;AAC5B;AACAD,IAAAA,KAAK,GAAGK,IAAI,CAACC,IAAL,CAAUL,KAAV,CAAR;AACAC,IAAAA,KAAK,GAAGG,IAAI,CAACE,GAAL,CAASP,KAAT,CAAR;AACAG,IAAAA,MAAM,GAAGE,IAAI,CAACE,GAAL,CAAS,CAAC,MAAMhB,CAAP,IAAYS,KAArB,IAA8BE,KAAvC;AACAE,IAAAA,MAAM,GAAGC,IAAI,CAACE,GAAL,CAAShB,CAAC,GAAGS,KAAb,IAAsBE,KAA/B;AACD,GAND,MAMO;AACL;AACA;AACAC,IAAAA,MAAM,GAAG,MAAMZ,CAAf;AACAa,IAAAA,MAAM,GAAGb,CAAT;AACD,GA/B2B,CAgC5B;;;AACAH,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASe,MAAM,GAAGX,EAAT,GAAcY,MAAM,GAAGR,EAAhC;AACAR,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASe,MAAM,GAAGV,EAAT,GAAcW,MAAM,GAAGP,EAAhC;AACAT,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASe,MAAM,GAAGT,EAAT,GAAcU,MAAM,GAAGN,EAAhC;AACAV,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASe,MAAM,GAAGR,EAAT,GAAcS,MAAM,GAAGL,EAAhC;AAEA,SAAOX,GAAP;AACD","sourcesContent":["module.exports = slerp\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nfunction slerp (out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n\n  var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n    bx = b[0], by = b[1], bz = b[2], bw = b[3]\n\n  var omega, cosom, sinom, scale0, scale1\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw\n  // adjust signs (if necessary)\n  if (cosom < 0.0) {\n    cosom = -cosom\n    bx = -bx\n    by = -by\n    bz = -bz\n    bw = -bw\n  }\n  // calculate coefficients\n  if ((1.0 - cosom) > 0.000001) {\n    // standard case (slerp)\n    omega = Math.acos(cosom)\n    sinom = Math.sin(omega)\n    scale0 = Math.sin((1.0 - t) * omega) / sinom\n    scale1 = Math.sin(t * omega) / sinom\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t\n    scale1 = t\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx\n  out[1] = scale0 * ay + scale1 * by\n  out[2] = scale0 * az + scale1 * bz\n  out[3] = scale0 * aw + scale1 * bw\n\n  return out\n}\n"]},"metadata":{},"sourceType":"script"}