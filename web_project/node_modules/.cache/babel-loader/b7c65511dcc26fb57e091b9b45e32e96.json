{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../registry');\n\nvar Plots = require('../plots/plots');\n\nvar Lib = require('../lib');\n\nvar clearGlCanvases = require('../lib/clear_gl_canvases');\n\nvar Color = require('../components/color');\n\nvar Drawing = require('../components/drawing');\n\nvar Titles = require('../components/titles');\n\nvar ModeBar = require('../components/modebar');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar alignmentConstants = require('../constants/alignment');\n\nvar axisConstraints = require('../plots/cartesian/constraints');\n\nvar enforceAxisConstraints = axisConstraints.enforce;\nvar cleanAxisConstraints = axisConstraints.clean;\n\nvar doAutoRange = require('../plots/cartesian/autorange').doAutoRange;\n\nvar SVG_TEXT_ANCHOR_START = 'start';\nvar SVG_TEXT_ANCHOR_MIDDLE = 'middle';\nvar SVG_TEXT_ANCHOR_END = 'end';\n\nexports.layoutStyles = function (gd) {\n  return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);\n};\n\nfunction overlappingDomain(xDomain, yDomain, domains) {\n  for (var i = 0; i < domains.length; i++) {\n    var existingX = domains[i][0];\n    var existingY = domains[i][1];\n\n    if (existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {\n      continue;\n    }\n\n    if (existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction lsInner(gd) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var pad = gs.p;\n  var axList = Axes.list(gd, '', true);\n  var i, subplot, plotinfo, ax, xa, ya;\n\n  fullLayout._paperdiv.style({\n    width: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width ? '100%' : fullLayout.width + 'px',\n    height: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height ? '100%' : fullLayout.height + 'px'\n  }).selectAll('.main-svg').call(Drawing.setSize, fullLayout.width, fullLayout.height);\n\n  gd._context.setBackground(gd, fullLayout.paper_bgcolor);\n\n  exports.drawMainTitle(gd);\n  ModeBar.manage(gd); // _has('cartesian') means SVG specifically, not GL2D - but GL2D\n  // can still get here because it makes some of the SVG structure\n  // for shared features like selections.\n\n  if (!fullLayout._has('cartesian')) {\n    return Plots.previousPromises(gd);\n  }\n\n  function getLinePosition(ax, counterAx, side) {\n    var lwHalf = ax._lw / 2;\n\n    if (ax._id.charAt(0) === 'x') {\n      if (!counterAx) return gs.t + gs.h * (1 - (ax.position || 0)) + lwHalf % 1;else if (side === 'top') return counterAx._offset - pad - lwHalf;\n      return counterAx._offset + counterAx._length + pad + lwHalf;\n    }\n\n    if (!counterAx) return gs.l + gs.w * (ax.position || 0) + lwHalf % 1;else if (side === 'right') return counterAx._offset + counterAx._length + pad + lwHalf;\n    return counterAx._offset - pad - lwHalf;\n  } // some preparation of axis position info\n\n\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    var counterAx = ax._anchorAxis; // clear axis line positions, to be set in the subplot loop below\n\n    ax._linepositions = {}; // stash crispRounded linewidth so we don't need to pass gd all over the place\n\n    ax._lw = Drawing.crispRound(gd, ax.linewidth, 1); // figure out the main axis line and main mirror line position.\n    // it's easier to follow the logic if we handle these separately from\n    // ax._linepositions, which are only used by mirror=allticks\n    // for non-main-subplot ticks, and mirror=all(ticks)? for zero line\n    // hiding logic\n\n    ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);\n    ax._mainMirrorPosition = ax.mirror && counterAx ? getLinePosition(ax, counterAx, alignmentConstants.OPPOSITE_SIDE[ax.side]) : null;\n  } // figure out which backgrounds we need to draw,\n  // and in which layers to put them\n\n\n  var lowerBackgroundIDs = [];\n  var backgroundIds = [];\n  var lowerDomains = []; // no need to draw background when paper and plot color are the same color,\n  // activate mode just for large splom (which benefit the most from this\n  // optimization), but this could apply to all cartesian subplots.\n\n  var noNeedForBg = Color.opacity(fullLayout.paper_bgcolor) === 1 && Color.opacity(fullLayout.plot_bgcolor) === 1 && fullLayout.paper_bgcolor === fullLayout.plot_bgcolor;\n\n  for (subplot in fullLayout._plots) {\n    plotinfo = fullLayout._plots[subplot];\n\n    if (plotinfo.mainplot) {\n      // mainplot is a reference to the main plot this one is overlaid on\n      // so if it exists, this is an overlaid plot and we don't need to\n      // give it its own background\n      if (plotinfo.bg) {\n        plotinfo.bg.remove();\n      }\n\n      plotinfo.bg = undefined;\n    } else {\n      var xDomain = plotinfo.xaxis.domain;\n      var yDomain = plotinfo.yaxis.domain;\n      var plotgroup = plotinfo.plotgroup;\n\n      if (overlappingDomain(xDomain, yDomain, lowerDomains)) {\n        var pgNode = plotgroup.node();\n        var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, 'rect', 'bg');\n        pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);\n        backgroundIds.push(subplot);\n      } else {\n        plotgroup.select('rect.bg').remove();\n        lowerDomains.push([xDomain, yDomain]);\n\n        if (!noNeedForBg) {\n          lowerBackgroundIDs.push(subplot);\n          backgroundIds.push(subplot);\n        }\n      }\n    }\n  } // now create all the lower-layer backgrounds at once now that\n  // we have the list of subplots that need them\n\n\n  var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg').data(lowerBackgroundIDs);\n\n  lowerBackgrounds.enter().append('rect').classed('bg', true);\n  lowerBackgrounds.exit().remove();\n  lowerBackgrounds.each(function (subplot) {\n    fullLayout._plots[subplot].bg = d3.select(this);\n  }); // style all backgrounds\n\n  for (i = 0; i < backgroundIds.length; i++) {\n    plotinfo = fullLayout._plots[backgroundIds[i]];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis;\n\n    if (plotinfo.bg) {\n      plotinfo.bg.call(Drawing.setRect, xa._offset - pad, ya._offset - pad, xa._length + 2 * pad, ya._length + 2 * pad).call(Color.fill, fullLayout.plot_bgcolor).style('stroke-width', 0);\n    }\n  }\n\n  if (!fullLayout._hasOnlyLargeSploms) {\n    for (subplot in fullLayout._plots) {\n      plotinfo = fullLayout._plots[subplot];\n      xa = plotinfo.xaxis;\n      ya = plotinfo.yaxis; // Clip so that data only shows up on the plot area.\n\n      var clipId = plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n      var plotClip = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function (s) {\n        s.classed('plotclip', true).append('rect');\n      });\n      plotinfo.clipRect = plotClip.select('rect').attr({\n        width: xa._length,\n        height: ya._length\n      });\n      Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);\n      var plotClipId;\n      var layerClipId;\n\n      if (plotinfo._hasClipOnAxisFalse) {\n        plotClipId = null;\n        layerClipId = clipId;\n      } else {\n        plotClipId = clipId;\n        layerClipId = null;\n      }\n\n      Drawing.setClipUrl(plotinfo.plot, plotClipId, gd); // stash layer clipId value (null or same as clipId)\n      // to DRY up Drawing.setClipUrl calls on trace-module and trace layers\n      // downstream\n\n      plotinfo.layerClipId = layerClipId;\n    }\n  }\n\n  var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop, leftYLineWidth, rightYLineWidth;\n  var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight, connectYBottom, connectYTop;\n  var extraSubplot;\n\n  function xLinePath(y) {\n    return 'M' + xLinesXLeft + ',' + y + 'H' + xLinesXRight;\n  }\n\n  function xLinePathFree(y) {\n    return 'M' + xa._offset + ',' + y + 'h' + xa._length;\n  }\n\n  function yLinePath(x) {\n    return 'M' + x + ',' + yLinesYTop + 'V' + yLinesYBottom;\n  }\n\n  function yLinePathFree(x) {\n    return 'M' + x + ',' + ya._offset + 'v' + ya._length;\n  }\n\n  function mainPath(ax, pathFn, pathFnFree) {\n    if (!ax.showline || subplot !== ax._mainSubplot) return '';\n    if (!ax._anchorAxis) return pathFnFree(ax._mainLinePosition);\n    var out = pathFn(ax._mainLinePosition);\n    if (ax.mirror) out += pathFn(ax._mainMirrorPosition);\n    return out;\n  }\n\n  for (subplot in fullLayout._plots) {\n    plotinfo = fullLayout._plots[subplot];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis;\n    /*\n     * x lines get longer where they meet y lines, to make a crisp corner.\n     * The x lines get the padding (margin.pad) plus the y line width to\n     * fill up the corner nicely. Free x lines are excluded - they always\n     * span exactly the data area of the plot\n     *\n     *  | XXXXX\n     *  | XXXXX\n     *  |\n     *  +------\n     *     x1\n     *    -----\n     *     x2\n     */\n\n    var xPath = 'M0,0';\n\n    if (shouldShowLinesOrTicks(xa, subplot)) {\n      leftYLineWidth = findCounterAxisLineWidth(xa, 'left', ya, axList);\n      xLinesXLeft = xa._offset - (leftYLineWidth ? pad + leftYLineWidth : 0);\n      rightYLineWidth = findCounterAxisLineWidth(xa, 'right', ya, axList);\n      xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? pad + rightYLineWidth : 0);\n      xLinesYBottom = getLinePosition(xa, ya, 'bottom');\n      xLinesYTop = getLinePosition(xa, ya, 'top'); // save axis line positions for extra ticks to reference\n      // each subplot that gets ticks from \"allticks\" gets an entry:\n      //    [left or bottom, right or top]\n\n      extraSubplot = !xa._anchorAxis || subplot !== xa._mainSubplot;\n\n      if (extraSubplot && (xa.mirror === 'allticks' || xa.mirror === 'all')) {\n        xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];\n      }\n\n      xPath = mainPath(xa, xLinePath, xLinePathFree);\n\n      if (extraSubplot && xa.showline && (xa.mirror === 'all' || xa.mirror === 'allticks')) {\n        xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);\n      }\n\n      plotinfo.xlines.style('stroke-width', xa._lw + 'px').call(Color.stroke, xa.showline ? xa.linecolor : 'rgba(0,0,0,0)');\n    }\n\n    plotinfo.xlines.attr('d', xPath);\n    /*\n     * y lines that meet x axes get longer only by margin.pad, because\n     * the x axes fill in the corner space. Free y axes, like free x axes,\n     * always span exactly the data area of the plot\n     *\n     *   |   | XXXX\n     * y2| y1| XXXX\n     *   |   | XXXX\n     *       |\n     *       +-----\n     */\n\n    var yPath = 'M0,0';\n\n    if (shouldShowLinesOrTicks(ya, subplot)) {\n      connectYBottom = findCounterAxisLineWidth(ya, 'bottom', xa, axList);\n      yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);\n      connectYTop = findCounterAxisLineWidth(ya, 'top', xa, axList);\n      yLinesYTop = ya._offset - (connectYTop ? pad : 0);\n      yLinesXLeft = getLinePosition(ya, xa, 'left');\n      yLinesXRight = getLinePosition(ya, xa, 'right');\n      extraSubplot = !ya._anchorAxis || subplot !== ya._mainSubplot;\n\n      if (extraSubplot && (ya.mirror === 'allticks' || ya.mirror === 'all')) {\n        ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];\n      }\n\n      yPath = mainPath(ya, yLinePath, yLinePathFree);\n\n      if (extraSubplot && ya.showline && (ya.mirror === 'all' || ya.mirror === 'allticks')) {\n        yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);\n      }\n\n      plotinfo.ylines.style('stroke-width', ya._lw + 'px').call(Color.stroke, ya.showline ? ya.linecolor : 'rgba(0,0,0,0)');\n    }\n\n    plotinfo.ylines.attr('d', yPath);\n  }\n\n  Axes.makeClipPaths(gd);\n  return Plots.previousPromises(gd);\n}\n\nfunction shouldShowLinesOrTicks(ax, subplot) {\n  return (ax.ticks || ax.showline) && (subplot === ax._mainSubplot || ax.mirror === 'all' || ax.mirror === 'allticks');\n}\n/*\n * should we draw a line on counterAx at this side of ax?\n * It's assumed that counterAx is known to overlay the subplot we're working on\n * but it may not be its main axis.\n */\n\n\nfunction shouldShowLineThisSide(ax, side, counterAx) {\n  // does counterAx get a line at all?\n  if (!counterAx.showline || !counterAx._lw) return false; // are we drawing *all* lines for counterAx?\n\n  if (counterAx.mirror === 'all' || counterAx.mirror === 'allticks') return true;\n  var anchorAx = counterAx._anchorAxis; // is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring\n\n  if (!anchorAx) return false; // in order to handle cases where the user forgot to anchor this axis correctly\n  // (because its default anchor has the same domain on the relevant end)\n  // check whether the relevant position is the same.\n\n  var sideIndex = alignmentConstants.FROM_BL[side];\n\n  if (counterAx.side === side) {\n    return anchorAx.domain[sideIndex] === ax.domain[sideIndex];\n  }\n\n  return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];\n}\n/*\n * Is there another axis intersecting `side` end of `ax`?\n * First look at `counterAx` (the axis for this subplot),\n * then at all other potential counteraxes on or overlaying this subplot.\n * Take the line width from the first one that has a line.\n */\n\n\nfunction findCounterAxisLineWidth(ax, side, counterAx, axList) {\n  if (shouldShowLineThisSide(ax, side, counterAx)) {\n    return counterAx._lw;\n  }\n\n  for (var i = 0; i < axList.length; i++) {\n    var axi = axList[i];\n\n    if (axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {\n      return axi._lw;\n    }\n  }\n\n  return 0;\n}\n\nexports.drawMainTitle = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var textAnchor = getMainTitleTextAnchor(fullLayout);\n  var dy = getMainTitleDy(fullLayout);\n  Titles.draw(gd, 'gtitle', {\n    propContainer: fullLayout,\n    propName: 'title.text',\n    placeholder: fullLayout._dfltTitle.plot,\n    attributes: {\n      x: getMainTitleX(fullLayout, textAnchor),\n      y: getMainTitleY(fullLayout, dy),\n      'text-anchor': textAnchor,\n      dy: dy\n    }\n  });\n};\n\nfunction getMainTitleX(fullLayout, textAnchor) {\n  var title = fullLayout.title;\n  var gs = fullLayout._size;\n  var hPadShift = 0;\n\n  if (textAnchor === SVG_TEXT_ANCHOR_START) {\n    hPadShift = title.pad.l;\n  } else if (textAnchor === SVG_TEXT_ANCHOR_END) {\n    hPadShift = -title.pad.r;\n  }\n\n  switch (title.xref) {\n    case 'paper':\n      return gs.l + gs.w * title.x + hPadShift;\n\n    case 'container':\n    default:\n      return fullLayout.width * title.x + hPadShift;\n  }\n}\n\nfunction getMainTitleY(fullLayout, dy) {\n  var title = fullLayout.title;\n  var gs = fullLayout._size;\n  var vPadShift = 0;\n\n  if (dy === '0em' || !dy) {\n    vPadShift = -title.pad.b;\n  } else if (dy === alignmentConstants.CAP_SHIFT + 'em') {\n    vPadShift = title.pad.t;\n  }\n\n  if (title.y === 'auto') {\n    return gs.t / 2;\n  } else {\n    switch (title.yref) {\n      case 'paper':\n        return gs.t + gs.h - gs.h * title.y + vPadShift;\n\n      case 'container':\n      default:\n        return fullLayout.height - fullLayout.height * title.y + vPadShift;\n    }\n  }\n}\n\nfunction getMainTitleTextAnchor(fullLayout) {\n  var title = fullLayout.title;\n  var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;\n\n  if (Lib.isRightAnchor(title)) {\n    textAnchor = SVG_TEXT_ANCHOR_END;\n  } else if (Lib.isLeftAnchor(title)) {\n    textAnchor = SVG_TEXT_ANCHOR_START;\n  }\n\n  return textAnchor;\n}\n\nfunction getMainTitleDy(fullLayout) {\n  var title = fullLayout.title;\n  var dy = '0em';\n\n  if (Lib.isTopAnchor(title)) {\n    dy = alignmentConstants.CAP_SHIFT + 'em';\n  } else if (Lib.isMiddleAnchor(title)) {\n    dy = alignmentConstants.MID_SHIFT + 'em';\n  }\n\n  return dy;\n}\n\nexports.doTraceStyle = function (gd) {\n  var calcdata = gd.calcdata;\n  var editStyleCalls = [];\n  var i;\n\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0] || {};\n    var trace = cd0.trace || {};\n\n    var _module = trace._module || {}; // See if we need to do arraysToCalcdata\n    // call it regardless of what change we made, in case\n    // supplyDefaults brought in an array that was already\n    // in gd.data but not in gd._fullData previously\n\n\n    var arraysToCalcdata = _module.arraysToCalcdata;\n    if (arraysToCalcdata) arraysToCalcdata(cd, trace);\n    var editStyle = _module.editStyle;\n    if (editStyle) editStyleCalls.push({\n      fn: editStyle,\n      cd0: cd0\n    });\n  }\n\n  if (editStyleCalls.length) {\n    for (i = 0; i < editStyleCalls.length; i++) {\n      var edit = editStyleCalls[i];\n      edit.fn(gd, edit.cd0);\n    }\n\n    clearGlCanvases(gd);\n    exports.redrawReglTraces(gd);\n  }\n\n  Plots.style(gd);\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  return Plots.previousPromises(gd);\n};\n\nexports.doColorBars = function (gd) {\n  Registry.getComponentMethod('colorbar', 'draw')(gd);\n  return Plots.previousPromises(gd);\n}; // force plot() to redo the layout and replot with the modified layout\n\n\nexports.layoutReplot = function (gd) {\n  var layout = gd.layout;\n  gd.layout = undefined;\n  return Registry.call('plot', gd, '', layout);\n};\n\nexports.doLegend = function (gd) {\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  return Plots.previousPromises(gd);\n};\n\nexports.doTicksRelayout = function (gd) {\n  Axes.draw(gd, 'redraw');\n\n  if (gd._fullLayout._hasOnlyLargeSploms) {\n    Registry.subplotsRegistry.splom.updateGrid(gd);\n    clearGlCanvases(gd);\n    exports.redrawReglTraces(gd);\n  }\n\n  exports.drawMainTitle(gd);\n  return Plots.previousPromises(gd);\n};\n\nexports.doModeBar = function (gd) {\n  var fullLayout = gd._fullLayout;\n  ModeBar.manage(gd);\n\n  for (var i = 0; i < fullLayout._basePlotModules.length; i++) {\n    var updateFx = fullLayout._basePlotModules[i].updateFx;\n    if (updateFx) updateFx(gd);\n  }\n\n  return Plots.previousPromises(gd);\n};\n\nexports.doCamera = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var sceneIds = fullLayout._subplots.gl3d;\n\n  for (var i = 0; i < sceneIds.length; i++) {\n    var sceneLayout = fullLayout[sceneIds[i]];\n    var scene = sceneLayout._scene;\n    scene.setViewport(sceneLayout);\n  }\n};\n\nexports.drawData = function (gd) {\n  var fullLayout = gd._fullLayout;\n  clearGlCanvases(gd); // loop over the base plot modules present on graph\n\n  var basePlotModules = fullLayout._basePlotModules;\n\n  for (var i = 0; i < basePlotModules.length; i++) {\n    basePlotModules[i].plot(gd);\n  }\n\n  exports.redrawReglTraces(gd); // styling separate from drawing\n\n  Plots.style(gd); // draw components that can be drawn on axes,\n  // and that do not push the margins\n\n  Registry.getComponentMethod('shapes', 'draw')(gd);\n  Registry.getComponentMethod('annotations', 'draw')(gd);\n  Registry.getComponentMethod('images', 'draw')(gd); // Mark the first render as complete\n\n  fullLayout._replotting = false;\n  return Plots.previousPromises(gd);\n}; // Draw (or redraw) all regl-based traces in one go,\n// useful during drag and selection where buffers of targeted traces are updated,\n// but all traces need to be redrawn following clearGlCanvases.\n//\n// Note that _module.plot for regl trace does NOT draw things\n// on the canvas, they only update the buffers.\n// Drawing is perform here.\n//\n// TODO try adding per-subplot option using gl.SCISSOR_TEST for\n// non-overlaying, disjoint subplots.\n//\n// TODO try to include parcoords in here.\n// https://github.com/plotly/plotly.js/issues/3069\n\n\nexports.redrawReglTraces = function (gd) {\n  var fullLayout = gd._fullLayout;\n\n  if (fullLayout._has('regl')) {\n    var fullData = gd._fullData;\n    var cartesianIds = [];\n    var polarIds = [];\n    var i, sp;\n\n    if (fullLayout._hasOnlyLargeSploms) {\n      fullLayout._splomGrid.draw();\n    } // N.B.\n    // - Loop over fullData (not _splomScenes) to preserve splom trace-to-trace ordering\n    // - Fill list if subplot ids (instead of fullLayout._subplots) to handle cases where all traces\n    //   of a given module are `visible !== true`\n\n\n    for (i = 0; i < fullData.length; i++) {\n      var trace = fullData[i];\n\n      if (trace.visible === true && trace._length !== 0) {\n        if (trace.type === 'splom') {\n          fullLayout._splomScenes[trace.uid].draw();\n        } else if (trace.type === 'scattergl') {\n          Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);\n        } else if (trace.type === 'scatterpolargl') {\n          Lib.pushUnique(polarIds, trace.subplot);\n        }\n      }\n    }\n\n    for (i = 0; i < cartesianIds.length; i++) {\n      sp = fullLayout._plots[cartesianIds[i]];\n      if (sp._scene) sp._scene.draw();\n    }\n\n    for (i = 0; i < polarIds.length; i++) {\n      sp = fullLayout[polarIds[i]]._subplot;\n      if (sp._scene) sp._scene.draw();\n    }\n  }\n};\n\nexports.doAutoRangeAndConstraints = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var axList = Axes.list(gd, '', true);\n  var matchGroups = fullLayout._axisMatchGroups || [];\n  var axLookup = {};\n  var ax;\n  var axRng;\n\n  for (var i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    cleanAxisConstraints(gd, ax);\n    doAutoRange(gd, ax);\n    axLookup[ax._id] = 1;\n  }\n\n  enforceAxisConstraints(gd);\n\n  groupLoop: for (var j = 0; j < matchGroups.length; j++) {\n    var group = matchGroups[j];\n    var rng = null;\n    var id;\n\n    for (id in group) {\n      ax = Axes.getFromId(gd, id); // skip over 'missing' axes which do not pass through doAutoRange\n\n      if (!axLookup[ax._id]) continue; // if one axis has autorange false, we're done\n\n      if (ax.autorange === false) continue groupLoop;\n      axRng = Lib.simpleMap(ax.range, ax.r2l);\n\n      if (rng) {\n        if (rng[0] < rng[1]) {\n          rng[0] = Math.min(rng[0], axRng[0]);\n          rng[1] = Math.max(rng[1], axRng[1]);\n        } else {\n          rng[0] = Math.max(rng[0], axRng[0]);\n          rng[1] = Math.min(rng[1], axRng[1]);\n        }\n      } else {\n        rng = axRng;\n      }\n    }\n\n    for (id in group) {\n      ax = Axes.getFromId(gd, id);\n      ax.range = Lib.simpleMap(rng, ax.l2r);\n      ax._input.range = ax.range.slice();\n      ax.setScale();\n    }\n  }\n}; // An initial paint must be completed before these components can be\n// correctly sized and the whole plot re-margined. fullLayout._replotting must\n// be set to false before these will work properly.\n\n\nexports.finalDraw = function (gd) {\n  // TODO: rangesliders really belong in marginPushers but they need to be\n  // drawn after data - can we at least get the margin pushing part separated\n  // out and done earlier?\n  Registry.getComponentMethod('rangeslider', 'draw')(gd); // TODO: rangeselector only needs to be here (in addition to drawMarginPushers)\n  // because the margins need to be fully determined before we can call\n  // autorange and update axis ranges (which rangeselector needs to know which\n  // button is active). Can we break out its automargin step from its draw step?\n\n  Registry.getComponentMethod('rangeselector', 'draw')(gd);\n};\n\nexports.drawMarginPushers = function (gd) {\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  Registry.getComponentMethod('rangeselector', 'draw')(gd);\n  Registry.getComponentMethod('sliders', 'draw')(gd);\n  Registry.getComponentMethod('updatemenus', 'draw')(gd);\n  Registry.getComponentMethod('colorbar', 'draw')(gd);\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/plot_api/subroutines.js"],"names":["d3","require","Registry","Plots","Lib","clearGlCanvases","Color","Drawing","Titles","ModeBar","Axes","alignmentConstants","axisConstraints","enforceAxisConstraints","enforce","cleanAxisConstraints","clean","doAutoRange","SVG_TEXT_ANCHOR_START","SVG_TEXT_ANCHOR_MIDDLE","SVG_TEXT_ANCHOR_END","exports","layoutStyles","gd","syncOrAsync","doAutoMargin","lsInner","overlappingDomain","xDomain","yDomain","domains","i","length","existingX","existingY","fullLayout","_fullLayout","gs","_size","pad","p","axList","list","subplot","plotinfo","ax","xa","ya","_paperdiv","style","width","_context","responsive","autosize","_hasZeroWidth","layout","height","_hasZeroHeight","selectAll","call","setSize","setBackground","paper_bgcolor","drawMainTitle","manage","_has","previousPromises","getLinePosition","counterAx","side","lwHalf","_lw","_id","charAt","t","h","position","_offset","_length","l","w","_anchorAxis","_linepositions","crispRound","linewidth","_mainLinePosition","_mainMirrorPosition","mirror","OPPOSITE_SIDE","lowerBackgroundIDs","backgroundIds","lowerDomains","noNeedForBg","opacity","plot_bgcolor","_plots","mainplot","bg","remove","undefined","xaxis","domain","yaxis","plotgroup","pgNode","node","plotgroupBg","ensureSingle","insertBefore","childNodes","push","select","lowerBackgrounds","_bgLayer","data","enter","append","classed","exit","each","setRect","fill","_hasOnlyLargeSploms","clipId","_uid","plotClip","ensureSingleById","_clips","s","clipRect","attr","setTranslate","plot","plotClipId","layerClipId","_hasClipOnAxisFalse","setClipUrl","xLinesXLeft","xLinesXRight","xLinesYBottom","xLinesYTop","leftYLineWidth","rightYLineWidth","yLinesYBottom","yLinesYTop","yLinesXLeft","yLinesXRight","connectYBottom","connectYTop","extraSubplot","xLinePath","y","xLinePathFree","yLinePath","x","yLinePathFree","mainPath","pathFn","pathFnFree","showline","_mainSubplot","out","xPath","shouldShowLinesOrTicks","findCounterAxisLineWidth","xlines","stroke","linecolor","yPath","ylines","makeClipPaths","ticks","shouldShowLineThisSide","anchorAx","sideIndex","FROM_BL","axi","_mainAxis","textAnchor","getMainTitleTextAnchor","dy","getMainTitleDy","draw","propContainer","propName","placeholder","_dfltTitle","attributes","getMainTitleX","getMainTitleY","title","hPadShift","r","xref","vPadShift","b","CAP_SHIFT","yref","isRightAnchor","isLeftAnchor","isTopAnchor","isMiddleAnchor","MID_SHIFT","doTraceStyle","calcdata","editStyleCalls","cd","cd0","trace","_module","arraysToCalcdata","editStyle","fn","edit","redrawReglTraces","getComponentMethod","doColorBars","layoutReplot","doLegend","doTicksRelayout","subplotsRegistry","splom","updateGrid","doModeBar","_basePlotModules","updateFx","doCamera","sceneIds","_subplots","gl3d","sceneLayout","scene","_scene","setViewport","drawData","basePlotModules","_replotting","fullData","_fullData","cartesianIds","polarIds","sp","_splomGrid","visible","type","_splomScenes","uid","pushUnique","_subplot","doAutoRangeAndConstraints","matchGroups","_axisMatchGroups","axLookup","axRng","groupLoop","j","group","rng","id","getFromId","autorange","simpleMap","range","r2l","Math","min","max","l2r","_input","slice","setScale","finalDraw","drawMarginPushers"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Registry = require('../registry');\nvar Plots = require('../plots/plots');\n\nvar Lib = require('../lib');\nvar clearGlCanvases = require('../lib/clear_gl_canvases');\n\nvar Color = require('../components/color');\nvar Drawing = require('../components/drawing');\nvar Titles = require('../components/titles');\nvar ModeBar = require('../components/modebar');\n\nvar Axes = require('../plots/cartesian/axes');\nvar alignmentConstants = require('../constants/alignment');\nvar axisConstraints = require('../plots/cartesian/constraints');\nvar enforceAxisConstraints = axisConstraints.enforce;\nvar cleanAxisConstraints = axisConstraints.clean;\nvar doAutoRange = require('../plots/cartesian/autorange').doAutoRange;\n\nvar SVG_TEXT_ANCHOR_START = 'start';\nvar SVG_TEXT_ANCHOR_MIDDLE = 'middle';\nvar SVG_TEXT_ANCHOR_END = 'end';\n\nexports.layoutStyles = function(gd) {\n    return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);\n};\n\nfunction overlappingDomain(xDomain, yDomain, domains) {\n    for(var i = 0; i < domains.length; i++) {\n        var existingX = domains[i][0];\n        var existingY = domains[i][1];\n\n        if(existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {\n            continue;\n        }\n        if(existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction lsInner(gd) {\n    var fullLayout = gd._fullLayout;\n    var gs = fullLayout._size;\n    var pad = gs.p;\n    var axList = Axes.list(gd, '', true);\n    var i, subplot, plotinfo, ax, xa, ya;\n\n    fullLayout._paperdiv.style({\n        width: (gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width) ? '100%' : fullLayout.width + 'px',\n        height: (gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height) ? '100%' : fullLayout.height + 'px'\n    })\n    .selectAll('.main-svg')\n    .call(Drawing.setSize, fullLayout.width, fullLayout.height);\n    gd._context.setBackground(gd, fullLayout.paper_bgcolor);\n\n    exports.drawMainTitle(gd);\n    ModeBar.manage(gd);\n\n    // _has('cartesian') means SVG specifically, not GL2D - but GL2D\n    // can still get here because it makes some of the SVG structure\n    // for shared features like selections.\n    if(!fullLayout._has('cartesian')) {\n        return Plots.previousPromises(gd);\n    }\n\n    function getLinePosition(ax, counterAx, side) {\n        var lwHalf = ax._lw / 2;\n\n        if(ax._id.charAt(0) === 'x') {\n            if(!counterAx) return gs.t + gs.h * (1 - (ax.position || 0)) + (lwHalf % 1);\n            else if(side === 'top') return counterAx._offset - pad - lwHalf;\n            return counterAx._offset + counterAx._length + pad + lwHalf;\n        }\n\n        if(!counterAx) return gs.l + gs.w * (ax.position || 0) + (lwHalf % 1);\n        else if(side === 'right') return counterAx._offset + counterAx._length + pad + lwHalf;\n        return counterAx._offset - pad - lwHalf;\n    }\n\n    // some preparation of axis position info\n    for(i = 0; i < axList.length; i++) {\n        ax = axList[i];\n\n        var counterAx = ax._anchorAxis;\n\n        // clear axis line positions, to be set in the subplot loop below\n        ax._linepositions = {};\n\n        // stash crispRounded linewidth so we don't need to pass gd all over the place\n        ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);\n\n        // figure out the main axis line and main mirror line position.\n        // it's easier to follow the logic if we handle these separately from\n        // ax._linepositions, which are only used by mirror=allticks\n        // for non-main-subplot ticks, and mirror=all(ticks)? for zero line\n        // hiding logic\n        ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);\n        ax._mainMirrorPosition = (ax.mirror && counterAx) ?\n            getLinePosition(ax, counterAx,\n                alignmentConstants.OPPOSITE_SIDE[ax.side]) : null;\n    }\n\n    // figure out which backgrounds we need to draw,\n    // and in which layers to put them\n    var lowerBackgroundIDs = [];\n    var backgroundIds = [];\n    var lowerDomains = [];\n    // no need to draw background when paper and plot color are the same color,\n    // activate mode just for large splom (which benefit the most from this\n    // optimization), but this could apply to all cartesian subplots.\n    var noNeedForBg = (\n        Color.opacity(fullLayout.paper_bgcolor) === 1 &&\n        Color.opacity(fullLayout.plot_bgcolor) === 1 &&\n        fullLayout.paper_bgcolor === fullLayout.plot_bgcolor\n    );\n\n    for(subplot in fullLayout._plots) {\n        plotinfo = fullLayout._plots[subplot];\n\n        if(plotinfo.mainplot) {\n            // mainplot is a reference to the main plot this one is overlaid on\n            // so if it exists, this is an overlaid plot and we don't need to\n            // give it its own background\n            if(plotinfo.bg) {\n                plotinfo.bg.remove();\n            }\n            plotinfo.bg = undefined;\n        } else {\n            var xDomain = plotinfo.xaxis.domain;\n            var yDomain = plotinfo.yaxis.domain;\n            var plotgroup = plotinfo.plotgroup;\n\n            if(overlappingDomain(xDomain, yDomain, lowerDomains)) {\n                var pgNode = plotgroup.node();\n                var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, 'rect', 'bg');\n                pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);\n                backgroundIds.push(subplot);\n            } else {\n                plotgroup.select('rect.bg').remove();\n                lowerDomains.push([xDomain, yDomain]);\n                if(!noNeedForBg) {\n                    lowerBackgroundIDs.push(subplot);\n                    backgroundIds.push(subplot);\n                }\n            }\n        }\n    }\n\n    // now create all the lower-layer backgrounds at once now that\n    // we have the list of subplots that need them\n    var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg')\n        .data(lowerBackgroundIDs);\n\n    lowerBackgrounds.enter().append('rect')\n        .classed('bg', true);\n\n    lowerBackgrounds.exit().remove();\n\n    lowerBackgrounds.each(function(subplot) {\n        fullLayout._plots[subplot].bg = d3.select(this);\n    });\n\n    // style all backgrounds\n    for(i = 0; i < backgroundIds.length; i++) {\n        plotinfo = fullLayout._plots[backgroundIds[i]];\n        xa = plotinfo.xaxis;\n        ya = plotinfo.yaxis;\n\n        if(plotinfo.bg) {\n            plotinfo.bg\n                .call(Drawing.setRect,\n                    xa._offset - pad, ya._offset - pad,\n                    xa._length + 2 * pad, ya._length + 2 * pad)\n                .call(Color.fill, fullLayout.plot_bgcolor)\n                .style('stroke-width', 0);\n        }\n    }\n\n    if(!fullLayout._hasOnlyLargeSploms) {\n        for(subplot in fullLayout._plots) {\n            plotinfo = fullLayout._plots[subplot];\n            xa = plotinfo.xaxis;\n            ya = plotinfo.yaxis;\n\n            // Clip so that data only shows up on the plot area.\n            var clipId = plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n\n            var plotClip = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function(s) {\n                s.classed('plotclip', true)\n                    .append('rect');\n            });\n\n            plotinfo.clipRect = plotClip.select('rect').attr({\n                width: xa._length,\n                height: ya._length\n            });\n\n            Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);\n\n            var plotClipId;\n            var layerClipId;\n\n            if(plotinfo._hasClipOnAxisFalse) {\n                plotClipId = null;\n                layerClipId = clipId;\n            } else {\n                plotClipId = clipId;\n                layerClipId = null;\n            }\n\n            Drawing.setClipUrl(plotinfo.plot, plotClipId, gd);\n\n            // stash layer clipId value (null or same as clipId)\n            // to DRY up Drawing.setClipUrl calls on trace-module and trace layers\n            // downstream\n            plotinfo.layerClipId = layerClipId;\n        }\n    }\n\n    var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop,\n        leftYLineWidth, rightYLineWidth;\n    var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight,\n        connectYBottom, connectYTop;\n    var extraSubplot;\n\n    function xLinePath(y) {\n        return 'M' + xLinesXLeft + ',' + y + 'H' + xLinesXRight;\n    }\n\n    function xLinePathFree(y) {\n        return 'M' + xa._offset + ',' + y + 'h' + xa._length;\n    }\n\n    function yLinePath(x) {\n        return 'M' + x + ',' + yLinesYTop + 'V' + yLinesYBottom;\n    }\n\n    function yLinePathFree(x) {\n        return 'M' + x + ',' + ya._offset + 'v' + ya._length;\n    }\n\n    function mainPath(ax, pathFn, pathFnFree) {\n        if(!ax.showline || subplot !== ax._mainSubplot) return '';\n        if(!ax._anchorAxis) return pathFnFree(ax._mainLinePosition);\n        var out = pathFn(ax._mainLinePosition);\n        if(ax.mirror) out += pathFn(ax._mainMirrorPosition);\n        return out;\n    }\n\n    for(subplot in fullLayout._plots) {\n        plotinfo = fullLayout._plots[subplot];\n        xa = plotinfo.xaxis;\n        ya = plotinfo.yaxis;\n\n        /*\n         * x lines get longer where they meet y lines, to make a crisp corner.\n         * The x lines get the padding (margin.pad) plus the y line width to\n         * fill up the corner nicely. Free x lines are excluded - they always\n         * span exactly the data area of the plot\n         *\n         *  | XXXXX\n         *  | XXXXX\n         *  |\n         *  +------\n         *     x1\n         *    -----\n         *     x2\n         */\n        var xPath = 'M0,0';\n        if(shouldShowLinesOrTicks(xa, subplot)) {\n            leftYLineWidth = findCounterAxisLineWidth(xa, 'left', ya, axList);\n            xLinesXLeft = xa._offset - (leftYLineWidth ? (pad + leftYLineWidth) : 0);\n            rightYLineWidth = findCounterAxisLineWidth(xa, 'right', ya, axList);\n            xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? (pad + rightYLineWidth) : 0);\n            xLinesYBottom = getLinePosition(xa, ya, 'bottom');\n            xLinesYTop = getLinePosition(xa, ya, 'top');\n\n            // save axis line positions for extra ticks to reference\n            // each subplot that gets ticks from \"allticks\" gets an entry:\n            //    [left or bottom, right or top]\n            extraSubplot = (!xa._anchorAxis || subplot !== xa._mainSubplot);\n            if(extraSubplot && (xa.mirror === 'allticks' || xa.mirror === 'all')) {\n                xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];\n            }\n\n            xPath = mainPath(xa, xLinePath, xLinePathFree);\n            if(extraSubplot && xa.showline && (xa.mirror === 'all' || xa.mirror === 'allticks')) {\n                xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);\n            }\n\n            plotinfo.xlines\n                .style('stroke-width', xa._lw + 'px')\n                .call(Color.stroke, xa.showline ?\n                    xa.linecolor : 'rgba(0,0,0,0)');\n        }\n        plotinfo.xlines.attr('d', xPath);\n\n        /*\n         * y lines that meet x axes get longer only by margin.pad, because\n         * the x axes fill in the corner space. Free y axes, like free x axes,\n         * always span exactly the data area of the plot\n         *\n         *   |   | XXXX\n         * y2| y1| XXXX\n         *   |   | XXXX\n         *       |\n         *       +-----\n         */\n        var yPath = 'M0,0';\n        if(shouldShowLinesOrTicks(ya, subplot)) {\n            connectYBottom = findCounterAxisLineWidth(ya, 'bottom', xa, axList);\n            yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);\n            connectYTop = findCounterAxisLineWidth(ya, 'top', xa, axList);\n            yLinesYTop = ya._offset - (connectYTop ? pad : 0);\n            yLinesXLeft = getLinePosition(ya, xa, 'left');\n            yLinesXRight = getLinePosition(ya, xa, 'right');\n\n            extraSubplot = (!ya._anchorAxis || subplot !== ya._mainSubplot);\n            if(extraSubplot && (ya.mirror === 'allticks' || ya.mirror === 'all')) {\n                ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];\n            }\n\n            yPath = mainPath(ya, yLinePath, yLinePathFree);\n            if(extraSubplot && ya.showline && (ya.mirror === 'all' || ya.mirror === 'allticks')) {\n                yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);\n            }\n\n            plotinfo.ylines\n                .style('stroke-width', ya._lw + 'px')\n                .call(Color.stroke, ya.showline ?\n                    ya.linecolor : 'rgba(0,0,0,0)');\n        }\n        plotinfo.ylines.attr('d', yPath);\n    }\n\n    Axes.makeClipPaths(gd);\n\n    return Plots.previousPromises(gd);\n}\n\nfunction shouldShowLinesOrTicks(ax, subplot) {\n    return (ax.ticks || ax.showline) &&\n        (subplot === ax._mainSubplot || ax.mirror === 'all' || ax.mirror === 'allticks');\n}\n\n/*\n * should we draw a line on counterAx at this side of ax?\n * It's assumed that counterAx is known to overlay the subplot we're working on\n * but it may not be its main axis.\n */\nfunction shouldShowLineThisSide(ax, side, counterAx) {\n    // does counterAx get a line at all?\n    if(!counterAx.showline || !counterAx._lw) return false;\n\n    // are we drawing *all* lines for counterAx?\n    if(counterAx.mirror === 'all' || counterAx.mirror === 'allticks') return true;\n\n    var anchorAx = counterAx._anchorAxis;\n\n    // is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring\n    if(!anchorAx) return false;\n\n    // in order to handle cases where the user forgot to anchor this axis correctly\n    // (because its default anchor has the same domain on the relevant end)\n    // check whether the relevant position is the same.\n    var sideIndex = alignmentConstants.FROM_BL[side];\n    if(counterAx.side === side) {\n        return anchorAx.domain[sideIndex] === ax.domain[sideIndex];\n    }\n    return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];\n}\n\n/*\n * Is there another axis intersecting `side` end of `ax`?\n * First look at `counterAx` (the axis for this subplot),\n * then at all other potential counteraxes on or overlaying this subplot.\n * Take the line width from the first one that has a line.\n */\nfunction findCounterAxisLineWidth(ax, side, counterAx, axList) {\n    if(shouldShowLineThisSide(ax, side, counterAx)) {\n        return counterAx._lw;\n    }\n    for(var i = 0; i < axList.length; i++) {\n        var axi = axList[i];\n        if(axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {\n            return axi._lw;\n        }\n    }\n    return 0;\n}\n\nexports.drawMainTitle = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var textAnchor = getMainTitleTextAnchor(fullLayout);\n    var dy = getMainTitleDy(fullLayout);\n\n    Titles.draw(gd, 'gtitle', {\n        propContainer: fullLayout,\n        propName: 'title.text',\n        placeholder: fullLayout._dfltTitle.plot,\n        attributes: {\n            x: getMainTitleX(fullLayout, textAnchor),\n            y: getMainTitleY(fullLayout, dy),\n            'text-anchor': textAnchor,\n            dy: dy\n        }\n    });\n};\n\nfunction getMainTitleX(fullLayout, textAnchor) {\n    var title = fullLayout.title;\n    var gs = fullLayout._size;\n    var hPadShift = 0;\n\n    if(textAnchor === SVG_TEXT_ANCHOR_START) {\n        hPadShift = title.pad.l;\n    } else if(textAnchor === SVG_TEXT_ANCHOR_END) {\n        hPadShift = -title.pad.r;\n    }\n\n    switch(title.xref) {\n        case 'paper':\n            return gs.l + gs.w * title.x + hPadShift;\n        case 'container':\n        default:\n            return fullLayout.width * title.x + hPadShift;\n    }\n}\n\nfunction getMainTitleY(fullLayout, dy) {\n    var title = fullLayout.title;\n    var gs = fullLayout._size;\n    var vPadShift = 0;\n\n    if(dy === '0em' || !dy) {\n        vPadShift = -title.pad.b;\n    } else if(dy === alignmentConstants.CAP_SHIFT + 'em') {\n        vPadShift = title.pad.t;\n    }\n\n    if(title.y === 'auto') {\n        return gs.t / 2;\n    } else {\n        switch(title.yref) {\n            case 'paper':\n                return gs.t + gs.h - gs.h * title.y + vPadShift;\n            case 'container':\n            default:\n                return fullLayout.height - fullLayout.height * title.y + vPadShift;\n        }\n    }\n}\n\nfunction getMainTitleTextAnchor(fullLayout) {\n    var title = fullLayout.title;\n\n    var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;\n    if(Lib.isRightAnchor(title)) {\n        textAnchor = SVG_TEXT_ANCHOR_END;\n    } else if(Lib.isLeftAnchor(title)) {\n        textAnchor = SVG_TEXT_ANCHOR_START;\n    }\n\n    return textAnchor;\n}\n\nfunction getMainTitleDy(fullLayout) {\n    var title = fullLayout.title;\n\n    var dy = '0em';\n    if(Lib.isTopAnchor(title)) {\n        dy = alignmentConstants.CAP_SHIFT + 'em';\n    } else if(Lib.isMiddleAnchor(title)) {\n        dy = alignmentConstants.MID_SHIFT + 'em';\n    }\n\n    return dy;\n}\n\nexports.doTraceStyle = function(gd) {\n    var calcdata = gd.calcdata;\n    var editStyleCalls = [];\n    var i;\n\n    for(i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var cd0 = cd[0] || {};\n        var trace = cd0.trace || {};\n        var _module = trace._module || {};\n\n        // See if we need to do arraysToCalcdata\n        // call it regardless of what change we made, in case\n        // supplyDefaults brought in an array that was already\n        // in gd.data but not in gd._fullData previously\n        var arraysToCalcdata = _module.arraysToCalcdata;\n        if(arraysToCalcdata) arraysToCalcdata(cd, trace);\n\n        var editStyle = _module.editStyle;\n        if(editStyle) editStyleCalls.push({fn: editStyle, cd0: cd0});\n    }\n\n    if(editStyleCalls.length) {\n        for(i = 0; i < editStyleCalls.length; i++) {\n            var edit = editStyleCalls[i];\n            edit.fn(gd, edit.cd0);\n        }\n        clearGlCanvases(gd);\n        exports.redrawReglTraces(gd);\n    }\n\n    Plots.style(gd);\n    Registry.getComponentMethod('legend', 'draw')(gd);\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doColorBars = function(gd) {\n    Registry.getComponentMethod('colorbar', 'draw')(gd);\n    return Plots.previousPromises(gd);\n};\n\n// force plot() to redo the layout and replot with the modified layout\nexports.layoutReplot = function(gd) {\n    var layout = gd.layout;\n    gd.layout = undefined;\n    return Registry.call('plot', gd, '', layout);\n};\n\nexports.doLegend = function(gd) {\n    Registry.getComponentMethod('legend', 'draw')(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doTicksRelayout = function(gd) {\n    Axes.draw(gd, 'redraw');\n\n    if(gd._fullLayout._hasOnlyLargeSploms) {\n        Registry.subplotsRegistry.splom.updateGrid(gd);\n        clearGlCanvases(gd);\n        exports.redrawReglTraces(gd);\n    }\n\n    exports.drawMainTitle(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doModeBar = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    ModeBar.manage(gd);\n\n    for(var i = 0; i < fullLayout._basePlotModules.length; i++) {\n        var updateFx = fullLayout._basePlotModules[i].updateFx;\n        if(updateFx) updateFx(gd);\n    }\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doCamera = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var sceneIds = fullLayout._subplots.gl3d;\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneLayout = fullLayout[sceneIds[i]];\n        var scene = sceneLayout._scene;\n\n        scene.setViewport(sceneLayout);\n    }\n};\n\nexports.drawData = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    clearGlCanvases(gd);\n\n    // loop over the base plot modules present on graph\n    var basePlotModules = fullLayout._basePlotModules;\n    for(var i = 0; i < basePlotModules.length; i++) {\n        basePlotModules[i].plot(gd);\n    }\n\n    exports.redrawReglTraces(gd);\n\n    // styling separate from drawing\n    Plots.style(gd);\n\n    // draw components that can be drawn on axes,\n    // and that do not push the margins\n    Registry.getComponentMethod('shapes', 'draw')(gd);\n    Registry.getComponentMethod('annotations', 'draw')(gd);\n    Registry.getComponentMethod('images', 'draw')(gd);\n\n    // Mark the first render as complete\n    fullLayout._replotting = false;\n\n    return Plots.previousPromises(gd);\n};\n\n// Draw (or redraw) all regl-based traces in one go,\n// useful during drag and selection where buffers of targeted traces are updated,\n// but all traces need to be redrawn following clearGlCanvases.\n//\n// Note that _module.plot for regl trace does NOT draw things\n// on the canvas, they only update the buffers.\n// Drawing is perform here.\n//\n// TODO try adding per-subplot option using gl.SCISSOR_TEST for\n// non-overlaying, disjoint subplots.\n//\n// TODO try to include parcoords in here.\n// https://github.com/plotly/plotly.js/issues/3069\nexports.redrawReglTraces = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    if(fullLayout._has('regl')) {\n        var fullData = gd._fullData;\n        var cartesianIds = [];\n        var polarIds = [];\n        var i, sp;\n\n        if(fullLayout._hasOnlyLargeSploms) {\n            fullLayout._splomGrid.draw();\n        }\n\n        // N.B.\n        // - Loop over fullData (not _splomScenes) to preserve splom trace-to-trace ordering\n        // - Fill list if subplot ids (instead of fullLayout._subplots) to handle cases where all traces\n        //   of a given module are `visible !== true`\n        for(i = 0; i < fullData.length; i++) {\n            var trace = fullData[i];\n\n            if(trace.visible === true && trace._length !== 0) {\n                if(trace.type === 'splom') {\n                    fullLayout._splomScenes[trace.uid].draw();\n                } else if(trace.type === 'scattergl') {\n                    Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);\n                } else if(trace.type === 'scatterpolargl') {\n                    Lib.pushUnique(polarIds, trace.subplot);\n                }\n            }\n        }\n\n        for(i = 0; i < cartesianIds.length; i++) {\n            sp = fullLayout._plots[cartesianIds[i]];\n            if(sp._scene) sp._scene.draw();\n        }\n\n        for(i = 0; i < polarIds.length; i++) {\n            sp = fullLayout[polarIds[i]]._subplot;\n            if(sp._scene) sp._scene.draw();\n        }\n    }\n};\n\nexports.doAutoRangeAndConstraints = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var axList = Axes.list(gd, '', true);\n    var matchGroups = fullLayout._axisMatchGroups || [];\n    var axLookup = {};\n    var ax;\n    var axRng;\n\n    for(var i = 0; i < axList.length; i++) {\n        ax = axList[i];\n        cleanAxisConstraints(gd, ax);\n        doAutoRange(gd, ax);\n        axLookup[ax._id] = 1;\n    }\n\n    enforceAxisConstraints(gd);\n\n    groupLoop:\n    for(var j = 0; j < matchGroups.length; j++) {\n        var group = matchGroups[j];\n        var rng = null;\n        var id;\n\n        for(id in group) {\n            ax = Axes.getFromId(gd, id);\n\n            // skip over 'missing' axes which do not pass through doAutoRange\n            if(!axLookup[ax._id]) continue;\n            // if one axis has autorange false, we're done\n            if(ax.autorange === false) continue groupLoop;\n\n            axRng = Lib.simpleMap(ax.range, ax.r2l);\n            if(rng) {\n                if(rng[0] < rng[1]) {\n                    rng[0] = Math.min(rng[0], axRng[0]);\n                    rng[1] = Math.max(rng[1], axRng[1]);\n                } else {\n                    rng[0] = Math.max(rng[0], axRng[0]);\n                    rng[1] = Math.min(rng[1], axRng[1]);\n                }\n            } else {\n                rng = axRng;\n            }\n        }\n\n        for(id in group) {\n            ax = Axes.getFromId(gd, id);\n            ax.range = Lib.simpleMap(rng, ax.l2r);\n            ax._input.range = ax.range.slice();\n            ax.setScale();\n        }\n    }\n};\n\n// An initial paint must be completed before these components can be\n// correctly sized and the whole plot re-margined. fullLayout._replotting must\n// be set to false before these will work properly.\nexports.finalDraw = function(gd) {\n    // TODO: rangesliders really belong in marginPushers but they need to be\n    // drawn after data - can we at least get the margin pushing part separated\n    // out and done earlier?\n    Registry.getComponentMethod('rangeslider', 'draw')(gd);\n    // TODO: rangeselector only needs to be here (in addition to drawMarginPushers)\n    // because the margins need to be fully determined before we can call\n    // autorange and update axis ranges (which rangeselector needs to know which\n    // button is active). Can we break out its automargin step from its draw step?\n    Registry.getComponentMethod('rangeselector', 'draw')(gd);\n};\n\nexports.drawMarginPushers = function(gd) {\n    Registry.getComponentMethod('legend', 'draw')(gd);\n    Registry.getComponentMethod('rangeselector', 'draw')(gd);\n    Registry.getComponentMethod('sliders', 'draw')(gd);\n    Registry.getComponentMethod('updatemenus', 'draw')(gd);\n    Registry.getComponentMethod('colorbar', 'draw')(gd);\n};\n"]},"metadata":{},"sourceType":"script"}