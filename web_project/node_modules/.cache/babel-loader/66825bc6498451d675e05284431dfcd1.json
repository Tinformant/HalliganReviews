{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\n\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar geoUtils = require('../../lib/geo_location_utils');\n\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\n\nvar subTypes = require('../scatter/subtypes');\n\nvar style = require('./style');\n\nfunction plot(gd, geo, calcData) {\n  var scatterLayer = geo.layers.frontplot.select('.scatterlayer');\n  var gTraces = Lib.makeTraceGroups(scatterLayer, calcData, 'trace scattergeo');\n\n  function removeBADNUM(d, node) {\n    if (d.lonlat[0] === BADNUM) {\n      d3.select(node).remove();\n    }\n  } // TODO find a way to order the inner nodes on update\n\n\n  gTraces.selectAll('*').remove();\n  gTraces.each(function (calcTrace) {\n    var s = d3.select(this);\n    var trace = calcTrace[0].trace;\n\n    if (subTypes.hasLines(trace) || trace.fill !== 'none') {\n      var lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n      var lineData = trace.fill !== 'none' ? geoJsonUtils.makePolygon(lineCoords) : geoJsonUtils.makeLine(lineCoords);\n      s.selectAll('path.js-line').data([{\n        geojson: lineData,\n        trace: trace\n      }]).enter().append('path').classed('js-line', true).style('stroke-miterlimit', 2);\n    }\n\n    if (subTypes.hasMarkers(trace)) {\n      s.selectAll('path.point').data(Lib.identity).enter().append('path').classed('point', true).each(function (calcPt) {\n        removeBADNUM(calcPt, this);\n      });\n    }\n\n    if (subTypes.hasText(trace)) {\n      s.selectAll('g').data(Lib.identity).enter().append('g').append('text').each(function (calcPt) {\n        removeBADNUM(calcPt, this);\n      });\n    } // call style here within topojson request callback\n\n\n    style(gd, calcTrace);\n  });\n}\n\nfunction calcGeoJSON(calcTrace, fullLayout) {\n  var trace = calcTrace[0].trace;\n  var geoLayout = fullLayout[trace.geo];\n  var geo = geoLayout._subplot;\n  var len = trace._length;\n  var i, calcPt;\n\n  if (Array.isArray(trace.locations)) {\n    var locationmode = trace.locationmode;\n    var features = locationmode === 'geojson-id' ? geoUtils.extractTraceFeature(calcTrace) : getTopojsonFeatures(trace, geo.topojson);\n\n    for (i = 0; i < len; i++) {\n      calcPt = calcTrace[i];\n      var feature = locationmode === 'geojson-id' ? calcPt.fOut : geoUtils.locationToFeature(locationmode, calcPt.loc, features);\n      calcPt.lonlat = feature ? feature.properties.ct : [BADNUM, BADNUM];\n    }\n  }\n\n  var opts = {\n    padded: true\n  };\n  var lonArray;\n  var latArray;\n\n  if (geoLayout.fitbounds === 'geojson' && trace.locationmode === 'geojson-id') {\n    var bboxGeojson = geoUtils.computeBbox(geoUtils.getTraceGeojson(trace));\n    lonArray = [bboxGeojson[0], bboxGeojson[2]];\n    latArray = [bboxGeojson[1], bboxGeojson[3]];\n  } else {\n    lonArray = new Array(len);\n    latArray = new Array(len);\n\n    for (i = 0; i < len; i++) {\n      calcPt = calcTrace[i];\n      lonArray[i] = calcPt.lonlat[0];\n      latArray[i] = calcPt.lonlat[1];\n    }\n\n    opts.ppad = calcMarkerSize(trace, len);\n  }\n\n  trace._extremes.lon = findExtremes(geoLayout.lonaxis._ax, lonArray, opts);\n  trace._extremes.lat = findExtremes(geoLayout.lataxis._ax, latArray, opts);\n}\n\nmodule.exports = {\n  calcGeoJSON: calcGeoJSON,\n  plot: plot\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/scattergeo/plot.js"],"names":["d3","require","Lib","getTopojsonFeatures","geoJsonUtils","geoUtils","findExtremes","BADNUM","calcMarkerSize","subTypes","style","plot","gd","geo","calcData","scatterLayer","layers","frontplot","select","gTraces","makeTraceGroups","removeBADNUM","d","node","lonlat","remove","selectAll","each","calcTrace","s","trace","hasLines","fill","lineCoords","calcTraceToLineCoords","lineData","makePolygon","makeLine","data","geojson","enter","append","classed","hasMarkers","identity","calcPt","hasText","calcGeoJSON","fullLayout","geoLayout","_subplot","len","_length","i","Array","isArray","locations","locationmode","features","extractTraceFeature","topojson","feature","fOut","locationToFeature","loc","properties","ct","opts","padded","lonArray","latArray","fitbounds","bboxGeojson","computeBbox","getTraceGeojson","ppad","_extremes","lon","lonaxis","_ax","lat","lataxis","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\nvar geoJsonUtils = require('../../lib/geojson_utils');\nvar geoUtils = require('../../lib/geo_location_utils');\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\nvar subTypes = require('../scatter/subtypes');\nvar style = require('./style');\n\nfunction plot(gd, geo, calcData) {\n    var scatterLayer = geo.layers.frontplot.select('.scatterlayer');\n    var gTraces = Lib.makeTraceGroups(scatterLayer, calcData, 'trace scattergeo');\n\n    function removeBADNUM(d, node) {\n        if(d.lonlat[0] === BADNUM) {\n            d3.select(node).remove();\n        }\n    }\n\n    // TODO find a way to order the inner nodes on update\n    gTraces.selectAll('*').remove();\n\n    gTraces.each(function(calcTrace) {\n        var s = d3.select(this);\n        var trace = calcTrace[0].trace;\n\n        if(subTypes.hasLines(trace) || trace.fill !== 'none') {\n            var lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n\n            var lineData = (trace.fill !== 'none') ?\n                geoJsonUtils.makePolygon(lineCoords) :\n                geoJsonUtils.makeLine(lineCoords);\n\n            s.selectAll('path.js-line')\n                .data([{geojson: lineData, trace: trace}])\n              .enter().append('path')\n                .classed('js-line', true)\n                .style('stroke-miterlimit', 2);\n        }\n\n        if(subTypes.hasMarkers(trace)) {\n            s.selectAll('path.point')\n                .data(Lib.identity)\n             .enter().append('path')\n                .classed('point', true)\n                .each(function(calcPt) { removeBADNUM(calcPt, this); });\n        }\n\n        if(subTypes.hasText(trace)) {\n            s.selectAll('g')\n                .data(Lib.identity)\n              .enter().append('g')\n                .append('text')\n                .each(function(calcPt) { removeBADNUM(calcPt, this); });\n        }\n\n        // call style here within topojson request callback\n        style(gd, calcTrace);\n    });\n}\n\nfunction calcGeoJSON(calcTrace, fullLayout) {\n    var trace = calcTrace[0].trace;\n    var geoLayout = fullLayout[trace.geo];\n    var geo = geoLayout._subplot;\n    var len = trace._length;\n    var i, calcPt;\n\n    if(Array.isArray(trace.locations)) {\n        var locationmode = trace.locationmode;\n        var features = locationmode === 'geojson-id' ?\n            geoUtils.extractTraceFeature(calcTrace) :\n            getTopojsonFeatures(trace, geo.topojson);\n\n        for(i = 0; i < len; i++) {\n            calcPt = calcTrace[i];\n\n            var feature = locationmode === 'geojson-id' ?\n                calcPt.fOut :\n                geoUtils.locationToFeature(locationmode, calcPt.loc, features);\n\n            calcPt.lonlat = feature ? feature.properties.ct : [BADNUM, BADNUM];\n        }\n    }\n\n    var opts = {padded: true};\n    var lonArray;\n    var latArray;\n\n    if(geoLayout.fitbounds === 'geojson' && trace.locationmode === 'geojson-id') {\n        var bboxGeojson = geoUtils.computeBbox(geoUtils.getTraceGeojson(trace));\n        lonArray = [bboxGeojson[0], bboxGeojson[2]];\n        latArray = [bboxGeojson[1], bboxGeojson[3]];\n    } else {\n        lonArray = new Array(len);\n        latArray = new Array(len);\n        for(i = 0; i < len; i++) {\n            calcPt = calcTrace[i];\n            lonArray[i] = calcPt.lonlat[0];\n            latArray[i] = calcPt.lonlat[1];\n        }\n\n        opts.ppad = calcMarkerSize(trace, len);\n    }\n\n    trace._extremes.lon = findExtremes(geoLayout.lonaxis._ax, lonArray, opts);\n    trace._extremes.lat = findExtremes(geoLayout.lataxis._ax, latArray, opts);\n}\n\nmodule.exports = {\n    calcGeoJSON: calcGeoJSON,\n    plot: plot\n};\n"]},"metadata":{},"sourceType":"script"}