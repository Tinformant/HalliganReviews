{"ast":null,"code":"\"use strict\";\n\nmodule.exports = simplifyPolygon;\n\nvar orient = require(\"robust-orientation\");\n\nvar sc = require(\"simplicial-complex\");\n\nfunction errorWeight(base, a, b) {\n  var area = Math.abs(orient(base, a, b));\n  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\n  return area / perim;\n}\n\nfunction simplifyPolygon(cells, positions, minArea) {\n  var n = positions.length;\n  var nc = cells.length;\n  var inv = new Array(n);\n  var outv = new Array(n);\n  var weights = new Array(n);\n  var dead = new Array(n); //Initialize tables\n\n  for (var i = 0; i < n; ++i) {\n    inv[i] = outv[i] = -1;\n    weights[i] = Infinity;\n    dead[i] = false;\n  } //Compute neighbors\n\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    if (c.length !== 2) {\n      throw new Error(\"Input must be a graph\");\n    }\n\n    var s = c[1];\n    var t = c[0];\n\n    if (outv[t] !== -1) {\n      outv[t] = -2;\n    } else {\n      outv[t] = s;\n    }\n\n    if (inv[s] !== -1) {\n      inv[s] = -2;\n    } else {\n      inv[s] = t;\n    }\n  } //Updates the weight for vertex i\n\n\n  function computeWeight(i) {\n    if (dead[i]) {\n      return Infinity;\n    } //TODO: Check that the line segment doesn't cross once simplified\n\n\n    var s = inv[i];\n    var t = outv[i];\n\n    if (s < 0 || t < 0) {\n      return Infinity;\n    } else {\n      return errorWeight(positions[i], positions[s], positions[t]);\n    }\n  } //Swaps two nodes on the heap (i,j) are the index of the nodes\n\n\n  function heapSwap(i, j) {\n    var a = heap[i];\n    var b = heap[j];\n    heap[i] = b;\n    heap[j] = a;\n    index[a] = j;\n    index[b] = i;\n  } //Returns the weight of node i on the heap\n\n\n  function heapWeight(i) {\n    return weights[heap[i]];\n  }\n\n  function heapParent(i) {\n    if (i & 1) {\n      return i - 1 >> 1;\n    }\n\n    return (i >> 1) - 1;\n  } //Bubble element i down the heap\n\n\n  function heapDown(i) {\n    var w = heapWeight(i);\n\n    while (true) {\n      var tw = w;\n      var left = 2 * i + 1;\n      var right = 2 * (i + 1);\n      var next = i;\n\n      if (left < heapCount) {\n        var lw = heapWeight(left);\n\n        if (lw < tw) {\n          next = left;\n          tw = lw;\n        }\n      }\n\n      if (right < heapCount) {\n        var rw = heapWeight(right);\n\n        if (rw < tw) {\n          next = right;\n        }\n      }\n\n      if (next === i) {\n        return i;\n      }\n\n      heapSwap(i, next);\n      i = next;\n    }\n  } //Bubbles element i up the heap\n\n\n  function heapUp(i) {\n    var w = heapWeight(i);\n\n    while (i > 0) {\n      var parent = heapParent(i);\n\n      if (parent >= 0) {\n        var pw = heapWeight(parent);\n\n        if (w < pw) {\n          heapSwap(i, parent);\n          i = parent;\n          continue;\n        }\n      }\n\n      return i;\n    }\n  } //Pop minimum element\n\n\n  function heapPop() {\n    if (heapCount > 0) {\n      var head = heap[0];\n      heapSwap(0, heapCount - 1);\n      heapCount -= 1;\n      heapDown(0);\n      return head;\n    }\n\n    return -1;\n  } //Update heap item i\n\n\n  function heapUpdate(i, w) {\n    var a = heap[i];\n\n    if (weights[a] === w) {\n      return i;\n    }\n\n    weights[a] = -Infinity;\n    heapUp(i);\n    heapPop();\n    weights[a] = w;\n    heapCount += 1;\n    return heapUp(heapCount - 1);\n  } //Kills a vertex (assume vertex already removed from heap)\n\n\n  function kill(i) {\n    if (dead[i]) {\n      return;\n    } //Kill vertex\n\n\n    dead[i] = true; //Fixup topology\n\n    var s = inv[i];\n    var t = outv[i];\n\n    if (inv[t] >= 0) {\n      inv[t] = s;\n    }\n\n    if (outv[s] >= 0) {\n      outv[s] = t;\n    } //Update weights on s and t\n\n\n    if (index[s] >= 0) {\n      heapUpdate(index[s], computeWeight(s));\n    }\n\n    if (index[t] >= 0) {\n      heapUpdate(index[t], computeWeight(t));\n    }\n  } //Initialize weights and heap\n\n\n  var heap = [];\n  var index = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    var w = weights[i] = computeWeight(i);\n\n    if (w < Infinity) {\n      index[i] = heap.length;\n      heap.push(i);\n    } else {\n      index[i] = -1;\n    }\n  }\n\n  var heapCount = heap.length;\n\n  for (var i = heapCount >> 1; i >= 0; --i) {\n    heapDown(i);\n  } //Kill vertices\n\n\n  while (true) {\n    var hmin = heapPop();\n\n    if (hmin < 0 || weights[hmin] > minArea) {\n      break;\n    }\n\n    kill(hmin);\n  } //Build collapsed vertex table\n\n\n  var npositions = [];\n\n  for (var i = 0; i < n; ++i) {\n    if (!dead[i]) {\n      index[i] = npositions.length;\n      npositions.push(positions[i].slice());\n    }\n  }\n\n  var nv = npositions.length;\n\n  function tortoiseHare(seq, start) {\n    if (seq[start] < 0) {\n      return start;\n    }\n\n    var t = start;\n    var h = start;\n\n    do {\n      //Walk two steps with h\n      var nh = seq[h];\n\n      if (!dead[h] || nh < 0 || nh === h) {\n        break;\n      }\n\n      h = nh;\n      nh = seq[h];\n\n      if (!dead[h] || nh < 0 || nh === h) {\n        break;\n      }\n\n      h = nh; //Walk one step with t\n\n      t = seq[t];\n    } while (t !== h); //Compress cycles\n\n\n    for (var v = start; v !== h; v = seq[v]) {\n      seq[v] = h;\n    }\n\n    return h;\n  }\n\n  var ncells = [];\n  cells.forEach(function (c) {\n    var tin = tortoiseHare(inv, c[0]);\n    var tout = tortoiseHare(outv, c[1]);\n\n    if (tin >= 0 && tout >= 0 && tin !== tout) {\n      var cin = index[tin];\n      var cout = index[tout];\n\n      if (cin !== cout) {\n        ncells.push([cin, cout]);\n      }\n    }\n  }); //Normalize result\n\n  sc.unique(sc.normalize(ncells)); //Return final list of cells\n\n  return {\n    positions: npositions,\n    edges: ncells\n  };\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/simplify-planar-graph/simplify.js"],"names":["module","exports","simplifyPolygon","orient","require","sc","errorWeight","base","a","b","area","Math","abs","perim","sqrt","pow","cells","positions","minArea","n","length","nc","inv","Array","outv","weights","dead","i","Infinity","c","Error","s","t","computeWeight","heapSwap","j","heap","index","heapWeight","heapParent","heapDown","w","tw","left","right","next","heapCount","lw","rw","heapUp","parent","pw","heapPop","head","heapUpdate","kill","push","hmin","npositions","slice","nv","tortoiseHare","seq","start","h","nh","v","ncells","forEach","tin","tout","cin","cout","unique","normalize","edges"],"mappings":"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","sourcesContent":["\"use strict\"\n\nmodule.exports = simplifyPolygon\n\nvar orient = require(\"robust-orientation\")\nvar sc = require(\"simplicial-complex\")\n\nfunction errorWeight(base, a, b) {\n  var area = Math.abs(orient(base, a, b))\n  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1]-b[1], 2))\n  return area / perim\n}\n\nfunction simplifyPolygon(cells, positions, minArea) {\n\n  var n = positions.length\n  var nc = cells.length\n  var inv = new Array(n)\n  var outv = new Array(n)\n  var weights = new Array(n)\n  var dead = new Array(n)\n  \n  //Initialize tables\n  for(var i=0; i<n; ++i) {\n    inv[i] = outv[i] = -1\n    weights[i] = Infinity\n    dead[i] = false\n  }\n\n  //Compute neighbors\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    if(c.length !== 2) {\n      throw new Error(\"Input must be a graph\")\n    }\n    var s = c[1]\n    var t = c[0]\n    if(outv[t] !== -1) {\n      outv[t] = -2\n    } else {\n      outv[t] = s\n    }\n    if(inv[s] !== -1) {\n      inv[s] = -2\n    } else {\n      inv[s] = t\n    }\n  }\n\n  //Updates the weight for vertex i\n  function computeWeight(i) {\n    if(dead[i]) {\n      return Infinity\n    }\n    //TODO: Check that the line segment doesn't cross once simplified\n    var s = inv[i]\n    var t = outv[i]\n    if((s<0) || (t<0)) {\n      return Infinity\n    } else {\n      return errorWeight(positions[i], positions[s], positions[t])\n    }\n  }\n\n  //Swaps two nodes on the heap (i,j) are the index of the nodes\n  function heapSwap(i,j) {\n    var a = heap[i]\n    var b = heap[j]\n    heap[i] = b\n    heap[j] = a\n    index[a] = j\n    index[b] = i\n  }\n\n  //Returns the weight of node i on the heap\n  function heapWeight(i) {\n    return weights[heap[i]]\n  }\n\n  function heapParent(i) {\n    if(i & 1) {\n      return (i - 1) >> 1\n    }\n    return (i >> 1) - 1\n  }\n\n  //Bubble element i down the heap\n  function heapDown(i) {\n    var w = heapWeight(i)\n    while(true) {\n      var tw = w\n      var left  = 2*i + 1\n      var right = 2*(i + 1)\n      var next = i\n      if(left < heapCount) {\n        var lw = heapWeight(left)\n        if(lw < tw) {\n          next = left\n          tw = lw\n        }\n      }\n      if(right < heapCount) {\n        var rw = heapWeight(right)\n        if(rw < tw) {\n          next = right\n        }\n      }\n      if(next === i) {\n        return i\n      }\n      heapSwap(i, next)\n      i = next      \n    }\n  }\n\n  //Bubbles element i up the heap\n  function heapUp(i) {\n    var w = heapWeight(i)\n    while(i > 0) {\n      var parent = heapParent(i)\n      if(parent >= 0) {\n        var pw = heapWeight(parent)\n        if(w < pw) {\n          heapSwap(i, parent)\n          i = parent\n          continue\n        }\n      }\n      return i\n    }\n  }\n\n  //Pop minimum element\n  function heapPop() {\n    if(heapCount > 0) {\n      var head = heap[0]\n      heapSwap(0, heapCount-1)\n      heapCount -= 1\n      heapDown(0)\n      return head\n    }\n    return -1\n  }\n\n  //Update heap item i\n  function heapUpdate(i, w) {\n    var a = heap[i]\n    if(weights[a] === w) {\n      return i\n    }\n    weights[a] = -Infinity\n    heapUp(i)\n    heapPop()\n    weights[a] = w\n    heapCount += 1\n    return heapUp(heapCount-1)\n  }\n\n  //Kills a vertex (assume vertex already removed from heap)\n  function kill(i) {\n    if(dead[i]) {\n      return\n    }\n    //Kill vertex\n    dead[i] = true\n    //Fixup topology\n    var s = inv[i]\n    var t = outv[i]\n    if(inv[t] >= 0) {\n      inv[t] = s\n    }\n    if(outv[s] >= 0) {\n      outv[s] = t\n    }\n\n    //Update weights on s and t\n    if(index[s] >= 0) {\n      heapUpdate(index[s], computeWeight(s))\n    }\n    if(index[t] >= 0) {\n      heapUpdate(index[t], computeWeight(t))\n    }\n  }\n\n  //Initialize weights and heap\n  var heap = []\n  var index = new Array(n)\n  for(var i=0; i<n; ++i) {\n    var w = weights[i] = computeWeight(i)\n    if(w < Infinity) {\n      index[i] = heap.length\n      heap.push(i)\n    } else {\n      index[i] = -1\n    }\n  }\n  var heapCount = heap.length\n  for(var i=heapCount>>1; i>=0; --i) {\n    heapDown(i)\n  }\n  \n  //Kill vertices\n  while(true) {\n    var hmin = heapPop()\n    if((hmin < 0) || (weights[hmin] > minArea)) {\n      break\n    }\n    kill(hmin)\n  }\n\n  //Build collapsed vertex table\n  var npositions = []\n  for(var i=0; i<n; ++i) {\n    if(!dead[i]) {\n      index[i] = npositions.length\n      npositions.push(positions[i].slice())\n    }\n  }\n  var nv = npositions.length\n\n  function tortoiseHare(seq, start) {\n    if(seq[start] < 0) {\n      return start\n    }\n    var t = start\n    var h = start\n    do {\n      //Walk two steps with h\n      var nh = seq[h]\n      if(!dead[h] || nh < 0 || nh === h) {\n        break\n      }\n      h = nh\n      nh = seq[h]\n      if(!dead[h] || nh < 0 || nh === h) {\n        break\n      }\n      h = nh\n\n      //Walk one step with t\n      t = seq[t]\n    } while(t !== h)\n    //Compress cycles\n    for(var v=start; v!==h; v = seq[v]) {\n      seq[v] = h\n    }\n    return h\n  }\n\n  var ncells = []\n  cells.forEach(function(c) {\n    var tin = tortoiseHare(inv, c[0])\n    var tout = tortoiseHare(outv, c[1])\n    if(tin >= 0 && tout >= 0 && tin !== tout) {\n      var cin = index[tin]\n      var cout = index[tout]\n      if(cin !== cout) {\n        ncells.push([ cin, cout ])\n      }\n    }\n  })\n\n  //Normalize result\n  sc.unique(sc.normalize(ncells))\n\n  //Return final list of cells\n  return {\n    positions: npositions,\n    edges: ncells\n  }\n}"]},"metadata":{},"sourceType":"script"}