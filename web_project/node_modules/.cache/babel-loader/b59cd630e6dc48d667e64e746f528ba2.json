{"ast":null,"code":"\"use strict\";\n\nmodule.exports = planarDual;\n\nvar compareAngle = require(\"compare-angle\");\n\nfunction planarDual(cells, positions) {\n  var numVertices = positions.length | 0;\n  var numEdges = cells.length;\n  var adj = [new Array(numVertices), new Array(numVertices)];\n\n  for (var i = 0; i < numVertices; ++i) {\n    adj[0][i] = [];\n    adj[1][i] = [];\n  }\n\n  for (var i = 0; i < numEdges; ++i) {\n    var c = cells[i];\n    adj[0][c[0]].push(c);\n    adj[1][c[1]].push(c);\n  }\n\n  var cycles = []; //Add isolated vertices as trivial case\n\n  for (var i = 0; i < numVertices; ++i) {\n    if (adj[0][i].length + adj[1][i].length === 0) {\n      cycles.push([i]);\n    }\n  } //Remove a half edge\n\n\n  function cut(c, i) {\n    var a = adj[i][c[i]];\n    a.splice(a.indexOf(c), 1);\n  } //Find next vertex and cut edge\n\n\n  function next(a, b, noCut) {\n    var nextCell, nextVertex, nextDir;\n\n    for (var i = 0; i < 2; ++i) {\n      if (adj[i][b].length > 0) {\n        nextCell = adj[i][b][0];\n        nextDir = i;\n        break;\n      }\n    }\n\n    nextVertex = nextCell[nextDir ^ 1];\n\n    for (var dir = 0; dir < 2; ++dir) {\n      var nbhd = adj[dir][b];\n\n      for (var k = 0; k < nbhd.length; ++k) {\n        var e = nbhd[k];\n        var p = e[dir ^ 1];\n        var cmp = compareAngle(positions[a], positions[b], positions[nextVertex], positions[p]);\n\n        if (cmp > 0) {\n          nextCell = e;\n          nextVertex = p;\n          nextDir = dir;\n        }\n      }\n    }\n\n    if (noCut) {\n      return nextVertex;\n    }\n\n    if (nextCell) {\n      cut(nextCell, nextDir);\n    }\n\n    return nextVertex;\n  }\n\n  function extractCycle(v, dir) {\n    var e0 = adj[dir][v][0];\n    var cycle = [v];\n    cut(e0, dir);\n    var u = e0[dir ^ 1];\n    var d0 = dir;\n\n    while (true) {\n      while (u !== v) {\n        cycle.push(u);\n        u = next(cycle[cycle.length - 2], u, false);\n      }\n\n      if (adj[0][v].length + adj[1][v].length === 0) {\n        break;\n      }\n\n      var a = cycle[cycle.length - 1];\n      var b = v;\n      var c = cycle[1];\n      var d = next(a, b, true);\n\n      if (compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {\n        break;\n      }\n\n      cycle.push(v);\n      u = next(a, b);\n    }\n\n    return cycle;\n  }\n\n  function shouldGlue(pcycle, ncycle) {\n    return ncycle[1] === ncycle[ncycle.length - 1];\n  }\n\n  for (var i = 0; i < numVertices; ++i) {\n    for (var j = 0; j < 2; ++j) {\n      var pcycle = [];\n\n      while (adj[j][i].length > 0) {\n        var ni = adj[0][i].length;\n        var ncycle = extractCycle(i, j);\n\n        if (shouldGlue(pcycle, ncycle)) {\n          //Glue together trivial cycles\n          pcycle.push.apply(pcycle, ncycle);\n        } else {\n          if (pcycle.length > 0) {\n            cycles.push(pcycle);\n          }\n\n          pcycle = ncycle;\n        }\n      }\n\n      if (pcycle.length > 0) {\n        cycles.push(pcycle);\n      }\n    }\n  } //Combine paths and loops together\n\n\n  return cycles;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/planar-dual/loops.js"],"names":["module","exports","planarDual","compareAngle","require","cells","positions","numVertices","length","numEdges","adj","Array","i","c","push","cycles","cut","a","splice","indexOf","next","b","noCut","nextCell","nextVertex","nextDir","dir","nbhd","k","e","p","cmp","extractCycle","v","e0","cycle","u","d0","d","shouldGlue","pcycle","ncycle","j","ni","apply"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,UAAjB;;AAEA,IAAIC,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AAEA,SAASF,UAAT,CAAoBG,KAApB,EAA2BC,SAA3B,EAAsC;AAEpC,MAAIC,WAAW,GAAGD,SAAS,CAACE,MAAV,GAAiB,CAAnC;AACA,MAAIC,QAAQ,GAAGJ,KAAK,CAACG,MAArB;AACA,MAAIE,GAAG,GAAG,CAAC,IAAIC,KAAJ,CAAUJ,WAAV,CAAD,EAAyB,IAAII,KAAJ,CAAUJ,WAAV,CAAzB,CAAV;;AACA,OAAI,IAAIK,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACL,WAAf,EAA4B,EAAEK,CAA9B,EAAiC;AAC/BF,IAAAA,GAAG,CAAC,CAAD,CAAH,CAAOE,CAAP,IAAY,EAAZ;AACAF,IAAAA,GAAG,CAAC,CAAD,CAAH,CAAOE,CAAP,IAAY,EAAZ;AACD;;AACD,OAAI,IAAIA,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACH,QAAf,EAAyB,EAAEG,CAA3B,EAA8B;AAC5B,QAAIC,CAAC,GAAGR,KAAK,CAACO,CAAD,CAAb;AACAF,IAAAA,GAAG,CAAC,CAAD,CAAH,CAAOG,CAAC,CAAC,CAAD,CAAR,EAAaC,IAAb,CAAkBD,CAAlB;AACAH,IAAAA,GAAG,CAAC,CAAD,CAAH,CAAOG,CAAC,CAAC,CAAD,CAAR,EAAaC,IAAb,CAAkBD,CAAlB;AACD;;AAED,MAAIE,MAAM,GAAG,EAAb,CAfoC,CAiBpC;;AACA,OAAI,IAAIH,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACL,WAAf,EAA4B,EAAEK,CAA9B,EAAiC;AAC/B,QAAGF,GAAG,CAAC,CAAD,CAAH,CAAOE,CAAP,EAAUJ,MAAV,GAAmBE,GAAG,CAAC,CAAD,CAAH,CAAOE,CAAP,EAAUJ,MAA7B,KAAwC,CAA3C,EAA8C;AAC5CO,MAAAA,MAAM,CAACD,IAAP,CAAa,CAACF,CAAD,CAAb;AACD;AACF,GAtBmC,CAwBpC;;;AACA,WAASI,GAAT,CAAaH,CAAb,EAAgBD,CAAhB,EAAmB;AACjB,QAAIK,CAAC,GAAGP,GAAG,CAACE,CAAD,CAAH,CAAOC,CAAC,CAACD,CAAD,CAAR,CAAR;AACAK,IAAAA,CAAC,CAACC,MAAF,CAASD,CAAC,CAACE,OAAF,CAAUN,CAAV,CAAT,EAAuB,CAAvB;AACD,GA5BmC,CA8BpC;;;AACA,WAASO,IAAT,CAAcH,CAAd,EAAiBI,CAAjB,EAAoBC,KAApB,EAA2B;AACzB,QAAIC,QAAJ,EAAcC,UAAd,EAA0BC,OAA1B;;AACA,SAAI,IAAIb,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,CAAf,EAAkB,EAAEA,CAApB,EAAuB;AACrB,UAAGF,GAAG,CAACE,CAAD,CAAH,CAAOS,CAAP,EAAUb,MAAV,GAAmB,CAAtB,EAAyB;AACvBe,QAAAA,QAAQ,GAAGb,GAAG,CAACE,CAAD,CAAH,CAAOS,CAAP,EAAU,CAAV,CAAX;AACAI,QAAAA,OAAO,GAAGb,CAAV;AACA;AACD;AACF;;AACDY,IAAAA,UAAU,GAAGD,QAAQ,CAACE,OAAO,GAAC,CAAT,CAArB;;AAEA,SAAI,IAAIC,GAAG,GAAC,CAAZ,EAAeA,GAAG,GAAC,CAAnB,EAAsB,EAAEA,GAAxB,EAA6B;AAC3B,UAAIC,IAAI,GAAGjB,GAAG,CAACgB,GAAD,CAAH,CAASL,CAAT,CAAX;;AACA,WAAI,IAAIO,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACD,IAAI,CAACnB,MAApB,EAA4B,EAAEoB,CAA9B,EAAiC;AAC/B,YAAIC,CAAC,GAAGF,IAAI,CAACC,CAAD,CAAZ;AACA,YAAIE,CAAC,GAAGD,CAAC,CAACH,GAAG,GAAC,CAAL,CAAT;AACA,YAAIK,GAAG,GAAG5B,YAAY,CAClBG,SAAS,CAACW,CAAD,CADS,EAElBX,SAAS,CAACe,CAAD,CAFS,EAGlBf,SAAS,CAACkB,UAAD,CAHS,EAIlBlB,SAAS,CAACwB,CAAD,CAJS,CAAtB;;AAKA,YAAGC,GAAG,GAAG,CAAT,EAAY;AACVR,UAAAA,QAAQ,GAAGM,CAAX;AACAL,UAAAA,UAAU,GAAGM,CAAb;AACAL,UAAAA,OAAO,GAAGC,GAAV;AACD;AACF;AACF;;AACD,QAAGJ,KAAH,EAAU;AACR,aAAOE,UAAP;AACD;;AACD,QAAGD,QAAH,EAAa;AACXP,MAAAA,GAAG,CAACO,QAAD,EAAWE,OAAX,CAAH;AACD;;AACD,WAAOD,UAAP;AACD;;AAED,WAASQ,YAAT,CAAsBC,CAAtB,EAAyBP,GAAzB,EAA8B;AAC5B,QAAIQ,EAAE,GAAGxB,GAAG,CAACgB,GAAD,CAAH,CAASO,CAAT,EAAY,CAAZ,CAAT;AACA,QAAIE,KAAK,GAAG,CAACF,CAAD,CAAZ;AACAjB,IAAAA,GAAG,CAACkB,EAAD,EAAKR,GAAL,CAAH;AACA,QAAIU,CAAC,GAAGF,EAAE,CAACR,GAAG,GAAC,CAAL,CAAV;AACA,QAAIW,EAAE,GAAGX,GAAT;;AACA,WAAM,IAAN,EAAY;AACV,aAAMU,CAAC,KAAKH,CAAZ,EAAe;AACbE,QAAAA,KAAK,CAACrB,IAAN,CAAWsB,CAAX;AACAA,QAAAA,CAAC,GAAGhB,IAAI,CAACe,KAAK,CAACA,KAAK,CAAC3B,MAAN,GAAa,CAAd,CAAN,EAAwB4B,CAAxB,EAA2B,KAA3B,CAAR;AACD;;AACD,UAAG1B,GAAG,CAAC,CAAD,CAAH,CAAOuB,CAAP,EAAUzB,MAAV,GAAmBE,GAAG,CAAC,CAAD,CAAH,CAAOuB,CAAP,EAAUzB,MAA7B,KAAwC,CAA3C,EAA8C;AAC5C;AACD;;AACD,UAAIS,CAAC,GAAGkB,KAAK,CAACA,KAAK,CAAC3B,MAAN,GAAa,CAAd,CAAb;AACA,UAAIa,CAAC,GAAGY,CAAR;AACA,UAAIpB,CAAC,GAAGsB,KAAK,CAAC,CAAD,CAAb;AACA,UAAIG,CAAC,GAAGlB,IAAI,CAACH,CAAD,EAAII,CAAJ,EAAO,IAAP,CAAZ;;AACA,UAAGlB,YAAY,CAACG,SAAS,CAACW,CAAD,CAAV,EAAeX,SAAS,CAACe,CAAD,CAAxB,EAA6Bf,SAAS,CAACO,CAAD,CAAtC,EAA2CP,SAAS,CAACgC,CAAD,CAApD,CAAZ,GAAuE,CAA1E,EAA6E;AAC3E;AACD;;AACDH,MAAAA,KAAK,CAACrB,IAAN,CAAWmB,CAAX;AACAG,MAAAA,CAAC,GAAGhB,IAAI,CAACH,CAAD,EAAII,CAAJ,CAAR;AACD;;AACD,WAAOc,KAAP;AACD;;AAED,WAASI,UAAT,CAAoBC,MAApB,EAA4BC,MAA5B,EAAoC;AAClC,WAAQA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAACA,MAAM,CAACjC,MAAP,GAAc,CAAf,CAA5B;AACD;;AAED,OAAI,IAAII,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACL,WAAf,EAA4B,EAAEK,CAA9B,EAAiC;AAC/B,SAAI,IAAI8B,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,CAAf,EAAkB,EAAEA,CAApB,EAAuB;AACrB,UAAIF,MAAM,GAAG,EAAb;;AACA,aAAM9B,GAAG,CAACgC,CAAD,CAAH,CAAO9B,CAAP,EAAUJ,MAAV,GAAmB,CAAzB,EAA4B;AAC1B,YAAImC,EAAE,GAAGjC,GAAG,CAAC,CAAD,CAAH,CAAOE,CAAP,EAAUJ,MAAnB;AACA,YAAIiC,MAAM,GAAGT,YAAY,CAACpB,CAAD,EAAG8B,CAAH,CAAzB;;AACA,YAAGH,UAAU,CAACC,MAAD,EAASC,MAAT,CAAb,EAA+B;AAC7B;AACAD,UAAAA,MAAM,CAAC1B,IAAP,CAAY8B,KAAZ,CAAkBJ,MAAlB,EAA0BC,MAA1B;AACD,SAHD,MAGO;AACL,cAAGD,MAAM,CAAChC,MAAP,GAAgB,CAAnB,EAAsB;AACpBO,YAAAA,MAAM,CAACD,IAAP,CAAY0B,MAAZ;AACD;;AACDA,UAAAA,MAAM,GAAGC,MAAT;AACD;AACF;;AACD,UAAGD,MAAM,CAAChC,MAAP,GAAgB,CAAnB,EAAsB;AACpBO,QAAAA,MAAM,CAACD,IAAP,CAAY0B,MAAZ;AACD;AACF;AACF,GAvHmC,CAyHpC;;;AACA,SAAOzB,MAAP;AACD","sourcesContent":["\"use strict\"\n\nmodule.exports = planarDual\n\nvar compareAngle = require(\"compare-angle\")\n\nfunction planarDual(cells, positions) {\n\n  var numVertices = positions.length|0\n  var numEdges = cells.length\n  var adj = [new Array(numVertices), new Array(numVertices)]\n  for(var i=0; i<numVertices; ++i) {\n    adj[0][i] = []\n    adj[1][i] = []\n  }\n  for(var i=0; i<numEdges; ++i) {\n    var c = cells[i]\n    adj[0][c[0]].push(c)\n    adj[1][c[1]].push(c)\n  }\n\n  var cycles = []\n\n  //Add isolated vertices as trivial case\n  for(var i=0; i<numVertices; ++i) {\n    if(adj[0][i].length + adj[1][i].length === 0) {\n      cycles.push( [i] )\n    }\n  }\n\n  //Remove a half edge\n  function cut(c, i) {\n    var a = adj[i][c[i]]\n    a.splice(a.indexOf(c), 1)\n  }\n\n  //Find next vertex and cut edge\n  function next(a, b, noCut) {\n    var nextCell, nextVertex, nextDir\n    for(var i=0; i<2; ++i) {\n      if(adj[i][b].length > 0) {\n        nextCell = adj[i][b][0]\n        nextDir = i\n        break\n      }\n    }\n    nextVertex = nextCell[nextDir^1]\n\n    for(var dir=0; dir<2; ++dir) {\n      var nbhd = adj[dir][b]\n      for(var k=0; k<nbhd.length; ++k) {\n        var e = nbhd[k]\n        var p = e[dir^1]\n        var cmp = compareAngle(\n            positions[a], \n            positions[b], \n            positions[nextVertex],\n            positions[p])\n        if(cmp > 0) {\n          nextCell = e\n          nextVertex = p\n          nextDir = dir\n        }\n      }\n    }\n    if(noCut) {\n      return nextVertex\n    }\n    if(nextCell) {\n      cut(nextCell, nextDir)\n    }\n    return nextVertex\n  }\n\n  function extractCycle(v, dir) {\n    var e0 = adj[dir][v][0]\n    var cycle = [v]\n    cut(e0, dir)\n    var u = e0[dir^1]\n    var d0 = dir\n    while(true) {\n      while(u !== v) {\n        cycle.push(u)\n        u = next(cycle[cycle.length-2], u, false)\n      }\n      if(adj[0][v].length + adj[1][v].length === 0) {\n        break\n      }\n      var a = cycle[cycle.length-1]\n      var b = v\n      var c = cycle[1]\n      var d = next(a, b, true)\n      if(compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {\n        break\n      }\n      cycle.push(v)\n      u = next(a, b)\n    }\n    return cycle\n  }\n\n  function shouldGlue(pcycle, ncycle) {\n    return (ncycle[1] === ncycle[ncycle.length-1])\n  }\n\n  for(var i=0; i<numVertices; ++i) {\n    for(var j=0; j<2; ++j) {\n      var pcycle = []\n      while(adj[j][i].length > 0) {\n        var ni = adj[0][i].length\n        var ncycle = extractCycle(i,j)\n        if(shouldGlue(pcycle, ncycle)) {\n          //Glue together trivial cycles\n          pcycle.push.apply(pcycle, ncycle)\n        } else {\n          if(pcycle.length > 0) {\n            cycles.push(pcycle)\n          }\n          pcycle = ncycle\n        }\n      }\n      if(pcycle.length > 0) {\n        cycles.push(pcycle)\n      }\n    }\n  }\n\n  //Combine paths and loops together\n  return cycles\n}"]},"metadata":{},"sourceType":"script"}