{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar tube2mesh = require('gl-streamtube3d');\n\nvar createTubeMesh = tube2mesh.createTubeMesh;\n\nvar Lib = require('../../lib');\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nvar zip3 = require('../../plots/gl3d/zip3');\n\nvar axisName2scaleIndex = {\n  xaxis: 0,\n  yaxis: 1,\n  zaxis: 2\n};\n\nfunction Streamtube(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = null;\n  this.data = null;\n}\n\nvar proto = Streamtube.prototype;\n\nproto.handlePick = function (selection) {\n  var sceneLayout = this.scene.fullSceneLayout;\n  var dataScale = this.scene.dataScale;\n\n  function fromDataScale(v, axisName) {\n    var ax = sceneLayout[axisName];\n    var scale = dataScale[axisName2scaleIndex[axisName]];\n    return ax.l2c(v) / scale;\n  }\n\n  if (selection.object === this.mesh) {\n    var pos = selection.data.position;\n    var uvx = selection.data.velocity;\n    selection.traceCoordinate = [fromDataScale(pos[0], 'xaxis'), fromDataScale(pos[1], 'yaxis'), fromDataScale(pos[2], 'zaxis'), fromDataScale(uvx[0], 'xaxis'), fromDataScale(uvx[1], 'yaxis'), fromDataScale(uvx[2], 'zaxis'), // u/v/w norm\n    selection.data.intensity * this.data._normMax, // divergence\n    selection.data.divergence];\n    selection.textLabel = this.data.hovertext || this.data.text;\n    return true;\n  }\n};\n\nfunction getDfltStartingPositions(vec) {\n  var len = vec.length;\n  var s;\n\n  if (len > 2) {\n    s = vec.slice(1, len - 1);\n  } else if (len === 2) {\n    s = [(vec[0] + vec[1]) / 2];\n  } else {\n    s = vec;\n  }\n\n  return s;\n}\n\nfunction getBoundPads(vec) {\n  var len = vec.length;\n\n  if (len === 1) {\n    return [0.5, 0.5];\n  } else {\n    return [vec[1] - vec[0], vec[len - 1] - vec[len - 2]];\n  }\n}\n\nfunction convert(scene, trace) {\n  var sceneLayout = scene.fullSceneLayout;\n  var dataScale = scene.dataScale;\n  var len = trace._len;\n  var tubeOpts = {};\n\n  function toDataCoords(arr, axisName) {\n    var ax = sceneLayout[axisName];\n    var scale = dataScale[axisName2scaleIndex[axisName]];\n    return Lib.simpleMap(arr, function (v) {\n      return ax.d2l(v) * scale;\n    });\n  }\n\n  tubeOpts.vectors = zip3(toDataCoords(trace._u, 'xaxis'), toDataCoords(trace._v, 'yaxis'), toDataCoords(trace._w, 'zaxis'), len); // Over-specified mesh case, this would error in tube2mesh\n\n  if (!len) {\n    return {\n      positions: [],\n      cells: []\n    };\n  }\n\n  var meshx = toDataCoords(trace._Xs, 'xaxis');\n  var meshy = toDataCoords(trace._Ys, 'yaxis');\n  var meshz = toDataCoords(trace._Zs, 'zaxis');\n  tubeOpts.meshgrid = [meshx, meshy, meshz];\n  tubeOpts.gridFill = trace._gridFill;\n  var slen = trace._slen;\n\n  if (slen) {\n    tubeOpts.startingPositions = zip3(toDataCoords(trace._startsX, 'xaxis'), toDataCoords(trace._startsY, 'yaxis'), toDataCoords(trace._startsZ, 'zaxis'));\n  } else {\n    // Default starting positions:\n    //\n    // if len>2, cut xz plane at min-y,\n    // takes all x/y/z pts on that plane except those on the edges\n    // to generate \"well-defined\" tubes,\n    //\n    // if len=2, take position halfway between two the pts,\n    //\n    // if len=1, take that pt\n    var sy0 = meshy[0];\n    var sx = getDfltStartingPositions(meshx);\n    var sz = getDfltStartingPositions(meshz);\n    var startingPositions = new Array(sx.length * sz.length);\n    var m = 0;\n\n    for (var i = 0; i < sx.length; i++) {\n      for (var k = 0; k < sz.length; k++) {\n        startingPositions[m++] = [sx[i], sy0, sz[k]];\n      }\n    }\n\n    tubeOpts.startingPositions = startingPositions;\n  }\n\n  tubeOpts.colormap = parseColorScale(trace);\n  tubeOpts.tubeSize = trace.sizeref;\n  tubeOpts.maxLength = trace.maxdisplayed; // add some padding around the bounds\n  // to e.g. allow tubes starting from a slice of the x/y/z mesh\n  // to go beyond bounds a little bit w/o getting clipped\n\n  var xbnds = toDataCoords(trace._xbnds, 'xaxis');\n  var ybnds = toDataCoords(trace._ybnds, 'yaxis');\n  var zbnds = toDataCoords(trace._zbnds, 'zaxis');\n  var xpads = getBoundPads(meshx);\n  var ypads = getBoundPads(meshy);\n  var zpads = getBoundPads(meshz);\n  var bounds = [[xbnds[0] - xpads[0], ybnds[0] - ypads[0], zbnds[0] - zpads[0]], [xbnds[1] + xpads[1], ybnds[1] + ypads[1], zbnds[1] + zpads[1]]];\n  var meshData = tube2mesh(tubeOpts, bounds); // N.B. cmin/cmax correspond to the min/max vector norm\n  // in the u/v/w arrays, which in general is NOT equal to max\n  // intensity that colors the tubes.\n\n  var cOpts = extractOpts(trace);\n  meshData.vertexIntensityBounds = [cOpts.min / trace._normMax, cOpts.max / trace._normMax]; // pass gl-mesh3d lighting attributes\n\n  var lp = trace.lightposition;\n  meshData.lightPosition = [lp.x, lp.y, lp.z];\n  meshData.ambient = trace.lighting.ambient;\n  meshData.diffuse = trace.lighting.diffuse;\n  meshData.specular = trace.lighting.specular;\n  meshData.roughness = trace.lighting.roughness;\n  meshData.fresnel = trace.lighting.fresnel;\n  meshData.opacity = trace.opacity; // stash autorange pad value\n\n  trace._pad = meshData.tubeScale * trace.sizeref * 2;\n  return meshData;\n}\n\nproto.update = function (data) {\n  this.data = data;\n  var meshData = convert(this.scene, data);\n  this.mesh.update(meshData);\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\n\nfunction createStreamtubeTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var meshData = convert(scene, data);\n  var mesh = createTubeMesh(gl, meshData);\n  var streamtube = new Streamtube(scene, data.uid);\n  streamtube.mesh = mesh;\n  streamtube.data = data;\n  mesh._trace = streamtube;\n  scene.glplot.add(mesh);\n  return streamtube;\n}\n\nmodule.exports = createStreamtubeTrace;","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/streamtube/convert.js"],"names":["tube2mesh","require","createTubeMesh","Lib","parseColorScale","extractOpts","zip3","axisName2scaleIndex","xaxis","yaxis","zaxis","Streamtube","scene","uid","mesh","data","proto","prototype","handlePick","selection","sceneLayout","fullSceneLayout","dataScale","fromDataScale","v","axisName","ax","scale","l2c","object","pos","position","uvx","velocity","traceCoordinate","intensity","_normMax","divergence","textLabel","hovertext","text","getDfltStartingPositions","vec","len","length","s","slice","getBoundPads","convert","trace","_len","tubeOpts","toDataCoords","arr","simpleMap","d2l","vectors","_u","_v","_w","positions","cells","meshx","_Xs","meshy","_Ys","meshz","_Zs","meshgrid","gridFill","_gridFill","slen","_slen","startingPositions","_startsX","_startsY","_startsZ","sy0","sx","sz","Array","m","i","k","colormap","tubeSize","sizeref","maxLength","maxdisplayed","xbnds","_xbnds","ybnds","_ybnds","zbnds","_zbnds","xpads","ypads","zpads","bounds","meshData","cOpts","vertexIntensityBounds","min","max","lp","lightposition","lightPosition","x","y","z","ambient","lighting","diffuse","specular","roughness","fresnel","opacity","_pad","tubeScale","update","dispose","glplot","remove","createStreamtubeTrace","gl","streamtube","_trace","add","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar tube2mesh = require('gl-streamtube3d');\nvar createTubeMesh = tube2mesh.createTubeMesh;\n\nvar Lib = require('../../lib');\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\nvar extractOpts = require('../../components/colorscale').extractOpts;\nvar zip3 = require('../../plots/gl3d/zip3');\n\nvar axisName2scaleIndex = {xaxis: 0, yaxis: 1, zaxis: 2};\n\nfunction Streamtube(scene, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.mesh = null;\n    this.data = null;\n}\n\nvar proto = Streamtube.prototype;\n\nproto.handlePick = function(selection) {\n    var sceneLayout = this.scene.fullSceneLayout;\n    var dataScale = this.scene.dataScale;\n\n    function fromDataScale(v, axisName) {\n        var ax = sceneLayout[axisName];\n        var scale = dataScale[axisName2scaleIndex[axisName]];\n        return ax.l2c(v) / scale;\n    }\n\n    if(selection.object === this.mesh) {\n        var pos = selection.data.position;\n        var uvx = selection.data.velocity;\n\n        selection.traceCoordinate = [\n            fromDataScale(pos[0], 'xaxis'),\n            fromDataScale(pos[1], 'yaxis'),\n            fromDataScale(pos[2], 'zaxis'),\n\n            fromDataScale(uvx[0], 'xaxis'),\n            fromDataScale(uvx[1], 'yaxis'),\n            fromDataScale(uvx[2], 'zaxis'),\n\n            // u/v/w norm\n            selection.data.intensity * this.data._normMax,\n            // divergence\n            selection.data.divergence\n        ];\n\n        selection.textLabel = this.data.hovertext || this.data.text;\n\n        return true;\n    }\n};\n\nfunction getDfltStartingPositions(vec) {\n    var len = vec.length;\n    var s;\n\n    if(len > 2) {\n        s = vec.slice(1, len - 1);\n    } else if(len === 2) {\n        s = [(vec[0] + vec[1]) / 2];\n    } else {\n        s = vec;\n    }\n    return s;\n}\n\nfunction getBoundPads(vec) {\n    var len = vec.length;\n    if(len === 1) {\n        return [0.5, 0.5];\n    } else {\n        return [vec[1] - vec[0], vec[len - 1] - vec[len - 2]];\n    }\n}\n\nfunction convert(scene, trace) {\n    var sceneLayout = scene.fullSceneLayout;\n    var dataScale = scene.dataScale;\n    var len = trace._len;\n    var tubeOpts = {};\n\n    function toDataCoords(arr, axisName) {\n        var ax = sceneLayout[axisName];\n        var scale = dataScale[axisName2scaleIndex[axisName]];\n        return Lib.simpleMap(arr, function(v) { return ax.d2l(v) * scale; });\n    }\n\n    tubeOpts.vectors = zip3(\n        toDataCoords(trace._u, 'xaxis'),\n        toDataCoords(trace._v, 'yaxis'),\n        toDataCoords(trace._w, 'zaxis'),\n        len\n    );\n\n    // Over-specified mesh case, this would error in tube2mesh\n    if(!len) {\n        return {\n            positions: [],\n            cells: []\n        };\n    }\n\n    var meshx = toDataCoords(trace._Xs, 'xaxis');\n    var meshy = toDataCoords(trace._Ys, 'yaxis');\n    var meshz = toDataCoords(trace._Zs, 'zaxis');\n\n    tubeOpts.meshgrid = [meshx, meshy, meshz];\n    tubeOpts.gridFill = trace._gridFill;\n\n    var slen = trace._slen;\n    if(slen) {\n        tubeOpts.startingPositions = zip3(\n            toDataCoords(trace._startsX, 'xaxis'),\n            toDataCoords(trace._startsY, 'yaxis'),\n            toDataCoords(trace._startsZ, 'zaxis')\n        );\n    } else {\n        // Default starting positions:\n        //\n        // if len>2, cut xz plane at min-y,\n        // takes all x/y/z pts on that plane except those on the edges\n        // to generate \"well-defined\" tubes,\n        //\n        // if len=2, take position halfway between two the pts,\n        //\n        // if len=1, take that pt\n        var sy0 = meshy[0];\n        var sx = getDfltStartingPositions(meshx);\n        var sz = getDfltStartingPositions(meshz);\n        var startingPositions = new Array(sx.length * sz.length);\n        var m = 0;\n\n        for(var i = 0; i < sx.length; i++) {\n            for(var k = 0; k < sz.length; k++) {\n                startingPositions[m++] = [sx[i], sy0, sz[k]];\n            }\n        }\n        tubeOpts.startingPositions = startingPositions;\n    }\n\n    tubeOpts.colormap = parseColorScale(trace);\n    tubeOpts.tubeSize = trace.sizeref;\n    tubeOpts.maxLength = trace.maxdisplayed;\n\n    // add some padding around the bounds\n    // to e.g. allow tubes starting from a slice of the x/y/z mesh\n    // to go beyond bounds a little bit w/o getting clipped\n    var xbnds = toDataCoords(trace._xbnds, 'xaxis');\n    var ybnds = toDataCoords(trace._ybnds, 'yaxis');\n    var zbnds = toDataCoords(trace._zbnds, 'zaxis');\n    var xpads = getBoundPads(meshx);\n    var ypads = getBoundPads(meshy);\n    var zpads = getBoundPads(meshz);\n\n    var bounds = [\n        [xbnds[0] - xpads[0], ybnds[0] - ypads[0], zbnds[0] - zpads[0]],\n        [xbnds[1] + xpads[1], ybnds[1] + ypads[1], zbnds[1] + zpads[1]]\n    ];\n\n    var meshData = tube2mesh(tubeOpts, bounds);\n\n    // N.B. cmin/cmax correspond to the min/max vector norm\n    // in the u/v/w arrays, which in general is NOT equal to max\n    // intensity that colors the tubes.\n    var cOpts = extractOpts(trace);\n    meshData.vertexIntensityBounds = [cOpts.min / trace._normMax, cOpts.max / trace._normMax];\n\n    // pass gl-mesh3d lighting attributes\n    var lp = trace.lightposition;\n    meshData.lightPosition = [lp.x, lp.y, lp.z];\n    meshData.ambient = trace.lighting.ambient;\n    meshData.diffuse = trace.lighting.diffuse;\n    meshData.specular = trace.lighting.specular;\n    meshData.roughness = trace.lighting.roughness;\n    meshData.fresnel = trace.lighting.fresnel;\n    meshData.opacity = trace.opacity;\n\n    // stash autorange pad value\n    trace._pad = meshData.tubeScale * trace.sizeref * 2;\n\n    return meshData;\n}\n\nproto.update = function(data) {\n    this.data = data;\n\n    var meshData = convert(this.scene, data);\n    this.mesh.update(meshData);\n};\n\nproto.dispose = function() {\n    this.scene.glplot.remove(this.mesh);\n    this.mesh.dispose();\n};\n\nfunction createStreamtubeTrace(scene, data) {\n    var gl = scene.glplot.gl;\n\n    var meshData = convert(scene, data);\n    var mesh = createTubeMesh(gl, meshData);\n\n    var streamtube = new Streamtube(scene, data.uid);\n    streamtube.mesh = mesh;\n    streamtube.data = data;\n    mesh._trace = streamtube;\n\n    scene.glplot.add(mesh);\n\n    return streamtube;\n}\n\nmodule.exports = createStreamtubeTrace;\n"]},"metadata":{},"sourceType":"script"}