{"ast":null,"code":"\"use strict\";\n\"use restrict\";\n\nvar bits = require(\"bit-twiddle\"),\n    UnionFind = require(\"union-find\"); //Returns the dimension of a cell complex\n\n\nfunction dimension(cells) {\n  var d = 0,\n      max = Math.max;\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    d = max(d, cells[i].length);\n  }\n\n  return d - 1;\n}\n\nexports.dimension = dimension; //Counts the number of vertices in faces\n\nfunction countVertices(cells) {\n  var vc = -1,\n      max = Math.max;\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    var c = cells[i];\n\n    for (var j = 0, jl = c.length; j < jl; ++j) {\n      vc = max(vc, c[j]);\n    }\n  }\n\n  return vc + 1;\n}\n\nexports.countVertices = countVertices; //Returns a deep copy of cells\n\nfunction cloneCells(cells) {\n  var ncells = new Array(cells.length);\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    ncells[i] = cells[i].slice(0);\n  }\n\n  return ncells;\n}\n\nexports.cloneCells = cloneCells; //Ranks a pair of cells up to permutation\n\nfunction compareCells(a, b) {\n  var n = a.length,\n      t = a.length - b.length,\n      min = Math.min;\n\n  if (t) {\n    return t;\n  }\n\n  switch (n) {\n    case 0:\n      return 0;\n\n    case 1:\n      return a[0] - b[0];\n\n    case 2:\n      var d = a[0] + a[1] - b[0] - b[1];\n\n      if (d) {\n        return d;\n      }\n\n      return min(a[0], a[1]) - min(b[0], b[1]);\n\n    case 3:\n      var l1 = a[0] + a[1],\n          m1 = b[0] + b[1];\n      d = l1 + a[2] - (m1 + b[2]);\n\n      if (d) {\n        return d;\n      }\n\n      var l0 = min(a[0], a[1]),\n          m0 = min(b[0], b[1]),\n          d = min(l0, a[2]) - min(m0, b[2]);\n\n      if (d) {\n        return d;\n      }\n\n      return min(l0 + a[2], l1) - min(m0 + b[2], m1);\n    //TODO: Maybe optimize n=4 as well?\n\n    default:\n      var as = a.slice(0);\n      as.sort();\n      var bs = b.slice(0);\n      bs.sort();\n\n      for (var i = 0; i < n; ++i) {\n        t = as[i] - bs[i];\n\n        if (t) {\n          return t;\n        }\n      }\n\n      return 0;\n  }\n}\n\nexports.compareCells = compareCells;\n\nfunction compareZipped(a, b) {\n  return compareCells(a[0], b[0]);\n} //Puts a cell complex into normal order for the purposes of findCell queries\n\n\nfunction normalize(cells, attr) {\n  if (attr) {\n    var len = cells.length;\n    var zipped = new Array(len);\n\n    for (var i = 0; i < len; ++i) {\n      zipped[i] = [cells[i], attr[i]];\n    }\n\n    zipped.sort(compareZipped);\n\n    for (var i = 0; i < len; ++i) {\n      cells[i] = zipped[i][0];\n      attr[i] = zipped[i][1];\n    }\n\n    return cells;\n  } else {\n    cells.sort(compareCells);\n    return cells;\n  }\n}\n\nexports.normalize = normalize; //Removes all duplicate cells in the complex\n\nfunction unique(cells) {\n  if (cells.length === 0) {\n    return [];\n  }\n\n  var ptr = 1,\n      len = cells.length;\n\n  for (var i = 1; i < len; ++i) {\n    var a = cells[i];\n\n    if (compareCells(a, cells[i - 1])) {\n      if (i === ptr) {\n        ptr++;\n        continue;\n      }\n\n      cells[ptr++] = a;\n    }\n  }\n\n  cells.length = ptr;\n  return cells;\n}\n\nexports.unique = unique; //Finds a cell in a normalized cell complex\n\nfunction findCell(cells, c) {\n  var lo = 0,\n      hi = cells.length - 1,\n      r = -1;\n\n  while (lo <= hi) {\n    var mid = lo + hi >> 1,\n        s = compareCells(cells[mid], c);\n\n    if (s <= 0) {\n      if (s === 0) {\n        r = mid;\n      }\n\n      lo = mid + 1;\n    } else if (s > 0) {\n      hi = mid - 1;\n    }\n  }\n\n  return r;\n}\n\nexports.findCell = findCell; //Builds an index for an n-cell.  This is more general than dual, but less efficient\n\nfunction incidence(from_cells, to_cells) {\n  var index = new Array(from_cells.length);\n\n  for (var i = 0, il = index.length; i < il; ++i) {\n    index[i] = [];\n  }\n\n  var b = [];\n\n  for (var i = 0, n = to_cells.length; i < n; ++i) {\n    var c = to_cells[i];\n    var cl = c.length;\n\n    for (var k = 1, kn = 1 << cl; k < kn; ++k) {\n      b.length = bits.popCount(k);\n      var l = 0;\n\n      for (var j = 0; j < cl; ++j) {\n        if (k & 1 << j) {\n          b[l++] = c[j];\n        }\n      }\n\n      var idx = findCell(from_cells, b);\n\n      if (idx < 0) {\n        continue;\n      }\n\n      while (true) {\n        index[idx++].push(i);\n\n        if (idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {\n          break;\n        }\n      }\n    }\n  }\n\n  return index;\n}\n\nexports.incidence = incidence; //Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices\n\nfunction dual(cells, vertex_count) {\n  if (!vertex_count) {\n    return incidence(unique(skeleton(cells, 0)), cells, 0);\n  }\n\n  var res = new Array(vertex_count);\n\n  for (var i = 0; i < vertex_count; ++i) {\n    res[i] = [];\n  }\n\n  for (var i = 0, len = cells.length; i < len; ++i) {\n    var c = cells[i];\n\n    for (var j = 0, cl = c.length; j < cl; ++j) {\n      res[c[j]].push(i);\n    }\n  }\n\n  return res;\n}\n\nexports.dual = dual; //Enumerates all cells in the complex\n\nfunction explode(cells) {\n  var result = [];\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    var c = cells[i],\n        cl = c.length | 0;\n\n    for (var j = 1, jl = 1 << cl; j < jl; ++j) {\n      var b = [];\n\n      for (var k = 0; k < cl; ++k) {\n        if (j >>> k & 1) {\n          b.push(c[k]);\n        }\n      }\n\n      result.push(b);\n    }\n  }\n\n  return normalize(result);\n}\n\nexports.explode = explode; //Enumerates all of the n-cells of a cell complex\n\nfunction skeleton(cells, n) {\n  if (n < 0) {\n    return [];\n  }\n\n  var result = [],\n      k0 = (1 << n + 1) - 1;\n\n  for (var i = 0; i < cells.length; ++i) {\n    var c = cells[i];\n\n    for (var k = k0; k < 1 << c.length; k = bits.nextCombination(k)) {\n      var b = new Array(n + 1),\n          l = 0;\n\n      for (var j = 0; j < c.length; ++j) {\n        if (k & 1 << j) {\n          b[l++] = c[j];\n        }\n      }\n\n      result.push(b);\n    }\n  }\n\n  return normalize(result);\n}\n\nexports.skeleton = skeleton; //Computes the boundary of all cells, does not remove duplicates\n\nfunction boundary(cells) {\n  var res = [];\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    var c = cells[i];\n\n    for (var j = 0, cl = c.length; j < cl; ++j) {\n      var b = new Array(c.length - 1);\n\n      for (var k = 0, l = 0; k < cl; ++k) {\n        if (k !== j) {\n          b[l++] = c[k];\n        }\n      }\n\n      res.push(b);\n    }\n  }\n\n  return normalize(res);\n}\n\nexports.boundary = boundary; //Computes connected components for a dense cell complex\n\nfunction connectedComponents_dense(cells, vertex_count) {\n  var labels = new UnionFind(vertex_count);\n\n  for (var i = 0; i < cells.length; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      for (var k = j + 1; k < c.length; ++k) {\n        labels.link(c[j], c[k]);\n      }\n    }\n  }\n\n  var components = [],\n      component_labels = labels.ranks;\n\n  for (var i = 0; i < component_labels.length; ++i) {\n    component_labels[i] = -1;\n  }\n\n  for (var i = 0; i < cells.length; ++i) {\n    var l = labels.find(cells[i][0]);\n\n    if (component_labels[l] < 0) {\n      component_labels[l] = components.length;\n      components.push([cells[i].slice(0)]);\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0));\n    }\n  }\n\n  return components;\n} //Computes connected components for a sparse graph\n\n\nfunction connectedComponents_sparse(cells) {\n  var vertices = unique(normalize(skeleton(cells, 0))),\n      labels = new UnionFind(vertices.length);\n\n  for (var i = 0; i < cells.length; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      var vj = findCell(vertices, [c[j]]);\n\n      for (var k = j + 1; k < c.length; ++k) {\n        labels.link(vj, findCell(vertices, [c[k]]));\n      }\n    }\n  }\n\n  var components = [],\n      component_labels = labels.ranks;\n\n  for (var i = 0; i < component_labels.length; ++i) {\n    component_labels[i] = -1;\n  }\n\n  for (var i = 0; i < cells.length; ++i) {\n    var l = labels.find(findCell(vertices, [cells[i][0]]));\n\n    if (component_labels[l] < 0) {\n      component_labels[l] = components.length;\n      components.push([cells[i].slice(0)]);\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0));\n    }\n  }\n\n  return components;\n} //Computes connected components for a cell complex\n\n\nfunction connectedComponents(cells, vertex_count) {\n  if (vertex_count) {\n    return connectedComponents_dense(cells, vertex_count);\n  }\n\n  return connectedComponents_sparse(cells);\n}\n\nexports.connectedComponents = connectedComponents;","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/simplicial-complex/topology.js"],"names":["bits","require","UnionFind","dimension","cells","d","max","Math","i","il","length","exports","countVertices","vc","c","j","jl","cloneCells","ncells","Array","slice","compareCells","a","b","n","t","min","l1","m1","l0","m0","as","sort","bs","compareZipped","normalize","attr","len","zipped","unique","ptr","findCell","lo","hi","r","mid","s","incidence","from_cells","to_cells","index","cl","k","kn","popCount","l","idx","push","dual","vertex_count","skeleton","res","explode","result","k0","nextCombination","boundary","connectedComponents_dense","labels","link","components","component_labels","ranks","find","connectedComponents_sparse","vertices","vj","connectedComponents"],"mappings":"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","sourcesContent":["\"use strict\"; \"use restrict\";\n\nvar bits      = require(\"bit-twiddle\")\n  , UnionFind = require(\"union-find\")\n\n//Returns the dimension of a cell complex\nfunction dimension(cells) {\n  var d = 0\n    , max = Math.max\n  for(var i=0, il=cells.length; i<il; ++i) {\n    d = max(d, cells[i].length)\n  }\n  return d-1\n}\nexports.dimension = dimension\n\n//Counts the number of vertices in faces\nfunction countVertices(cells) {\n  var vc = -1\n    , max = Math.max\n  for(var i=0, il=cells.length; i<il; ++i) {\n    var c = cells[i]\n    for(var j=0, jl=c.length; j<jl; ++j) {\n      vc = max(vc, c[j])\n    }\n  }\n  return vc+1\n}\nexports.countVertices = countVertices\n\n//Returns a deep copy of cells\nfunction cloneCells(cells) {\n  var ncells = new Array(cells.length)\n  for(var i=0, il=cells.length; i<il; ++i) {\n    ncells[i] = cells[i].slice(0)\n  }\n  return ncells\n}\nexports.cloneCells = cloneCells\n\n//Ranks a pair of cells up to permutation\nfunction compareCells(a, b) {\n  var n = a.length\n    , t = a.length - b.length\n    , min = Math.min\n  if(t) {\n    return t\n  }\n  switch(n) {\n    case 0:\n      return 0;\n    case 1:\n      return a[0] - b[0];\n    case 2:\n      var d = a[0]+a[1]-b[0]-b[1]\n      if(d) {\n        return d\n      }\n      return min(a[0],a[1]) - min(b[0],b[1])\n    case 3:\n      var l1 = a[0]+a[1]\n        , m1 = b[0]+b[1]\n      d = l1+a[2] - (m1+b[2])\n      if(d) {\n        return d\n      }\n      var l0 = min(a[0], a[1])\n        , m0 = min(b[0], b[1])\n        , d  = min(l0, a[2]) - min(m0, b[2])\n      if(d) {\n        return d\n      }\n      return min(l0+a[2], l1) - min(m0+b[2], m1)\n    \n    //TODO: Maybe optimize n=4 as well?\n    \n    default:\n      var as = a.slice(0)\n      as.sort()\n      var bs = b.slice(0)\n      bs.sort()\n      for(var i=0; i<n; ++i) {\n        t = as[i] - bs[i]\n        if(t) {\n          return t\n        }\n      }\n      return 0\n  }\n}\nexports.compareCells = compareCells\n\nfunction compareZipped(a, b) {\n  return compareCells(a[0], b[0])\n}\n\n//Puts a cell complex into normal order for the purposes of findCell queries\nfunction normalize(cells, attr) {\n  if(attr) {\n    var len = cells.length\n    var zipped = new Array(len)\n    for(var i=0; i<len; ++i) {\n      zipped[i] = [cells[i], attr[i]]\n    }\n    zipped.sort(compareZipped)\n    for(var i=0; i<len; ++i) {\n      cells[i] = zipped[i][0]\n      attr[i] = zipped[i][1]\n    }\n    return cells\n  } else {\n    cells.sort(compareCells)\n    return cells\n  }\n}\nexports.normalize = normalize\n\n//Removes all duplicate cells in the complex\nfunction unique(cells) {\n  if(cells.length === 0) {\n    return []\n  }\n  var ptr = 1\n    , len = cells.length\n  for(var i=1; i<len; ++i) {\n    var a = cells[i]\n    if(compareCells(a, cells[i-1])) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      cells[ptr++] = a\n    }\n  }\n  cells.length = ptr\n  return cells\n}\nexports.unique = unique;\n\n//Finds a cell in a normalized cell complex\nfunction findCell(cells, c) {\n  var lo = 0\n    , hi = cells.length-1\n    , r  = -1\n  while (lo <= hi) {\n    var mid = (lo + hi) >> 1\n      , s   = compareCells(cells[mid], c)\n    if(s <= 0) {\n      if(s === 0) {\n        r = mid\n      }\n      lo = mid + 1\n    } else if(s > 0) {\n      hi = mid - 1\n    }\n  }\n  return r\n}\nexports.findCell = findCell;\n\n//Builds an index for an n-cell.  This is more general than dual, but less efficient\nfunction incidence(from_cells, to_cells) {\n  var index = new Array(from_cells.length)\n  for(var i=0, il=index.length; i<il; ++i) {\n    index[i] = []\n  }\n  var b = []\n  for(var i=0, n=to_cells.length; i<n; ++i) {\n    var c = to_cells[i]\n    var cl = c.length\n    for(var k=1, kn=(1<<cl); k<kn; ++k) {\n      b.length = bits.popCount(k)\n      var l = 0\n      for(var j=0; j<cl; ++j) {\n        if(k & (1<<j)) {\n          b[l++] = c[j]\n        }\n      }\n      var idx=findCell(from_cells, b)\n      if(idx < 0) {\n        continue\n      }\n      while(true) {\n        index[idx++].push(i)\n        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {\n          break\n        }\n      }\n    }\n  }\n  return index\n}\nexports.incidence = incidence\n\n//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices\nfunction dual(cells, vertex_count) {\n  if(!vertex_count) {\n    return incidence(unique(skeleton(cells, 0)), cells, 0)\n  }\n  var res = new Array(vertex_count)\n  for(var i=0; i<vertex_count; ++i) {\n    res[i] = []\n  }\n  for(var i=0, len=cells.length; i<len; ++i) {\n    var c = cells[i]\n    for(var j=0, cl=c.length; j<cl; ++j) {\n      res[c[j]].push(i)\n    }\n  }\n  return res\n}\nexports.dual = dual\n\n//Enumerates all cells in the complex\nfunction explode(cells) {\n  var result = []\n  for(var i=0, il=cells.length; i<il; ++i) {\n    var c = cells[i]\n      , cl = c.length|0\n    for(var j=1, jl=(1<<cl); j<jl; ++j) {\n      var b = []\n      for(var k=0; k<cl; ++k) {\n        if((j >>> k) & 1) {\n          b.push(c[k])\n        }\n      }\n      result.push(b)\n    }\n  }\n  return normalize(result)\n}\nexports.explode = explode\n\n//Enumerates all of the n-cells of a cell complex\nfunction skeleton(cells, n) {\n  if(n < 0) {\n    return []\n  }\n  var result = []\n    , k0     = (1<<(n+1))-1\n  for(var i=0; i<cells.length; ++i) {\n    var c = cells[i]\n    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {\n      var b = new Array(n+1)\n        , l = 0\n      for(var j=0; j<c.length; ++j) {\n        if(k & (1<<j)) {\n          b[l++] = c[j]\n        }\n      }\n      result.push(b)\n    }\n  }\n  return normalize(result)\n}\nexports.skeleton = skeleton;\n\n//Computes the boundary of all cells, does not remove duplicates\nfunction boundary(cells) {\n  var res = []\n  for(var i=0,il=cells.length; i<il; ++i) {\n    var c = cells[i]\n    for(var j=0,cl=c.length; j<cl; ++j) {\n      var b = new Array(c.length-1)\n      for(var k=0, l=0; k<cl; ++k) {\n        if(k !== j) {\n          b[l++] = c[k]\n        }\n      }\n      res.push(b)\n    }\n  }\n  return normalize(res)\n}\nexports.boundary = boundary;\n\n//Computes connected components for a dense cell complex\nfunction connectedComponents_dense(cells, vertex_count) {\n  var labels = new UnionFind(vertex_count)\n  for(var i=0; i<cells.length; ++i) {\n    var c = cells[i]\n    for(var j=0; j<c.length; ++j) {\n      for(var k=j+1; k<c.length; ++k) {\n        labels.link(c[j], c[k])\n      }\n    }\n  }\n  var components = []\n    , component_labels = labels.ranks\n  for(var i=0; i<component_labels.length; ++i) {\n    component_labels[i] = -1\n  }\n  for(var i=0; i<cells.length; ++i) {\n    var l = labels.find(cells[i][0])\n    if(component_labels[l] < 0) {\n      component_labels[l] = components.length\n      components.push([cells[i].slice(0)])\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0))\n    }\n  }\n  return components\n}\n\n//Computes connected components for a sparse graph\nfunction connectedComponents_sparse(cells) {\n  var vertices  = unique(normalize(skeleton(cells, 0)))\n    , labels    = new UnionFind(vertices.length)\n  for(var i=0; i<cells.length; ++i) {\n    var c = cells[i]\n    for(var j=0; j<c.length; ++j) {\n      var vj = findCell(vertices, [c[j]])\n      for(var k=j+1; k<c.length; ++k) {\n        labels.link(vj, findCell(vertices, [c[k]]))\n      }\n    }\n  }\n  var components        = []\n    , component_labels  = labels.ranks\n  for(var i=0; i<component_labels.length; ++i) {\n    component_labels[i] = -1\n  }\n  for(var i=0; i<cells.length; ++i) {\n    var l = labels.find(findCell(vertices, [cells[i][0]]));\n    if(component_labels[l] < 0) {\n      component_labels[l] = components.length\n      components.push([cells[i].slice(0)])\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0))\n    }\n  }\n  return components\n}\n\n//Computes connected components for a cell complex\nfunction connectedComponents(cells, vertex_count) {\n  if(vertex_count) {\n    return connectedComponents_dense(cells, vertex_count)\n  }\n  return connectedComponents_sparse(cells)\n}\nexports.connectedComponents = connectedComponents\n"]},"metadata":{},"sourceType":"script"}