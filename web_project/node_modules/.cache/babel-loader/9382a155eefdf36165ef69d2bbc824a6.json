{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nfunction calculateAxisErrors(data, params, scaleFactor, axis) {\n  if (!params || !params.visible) return null;\n  var computeError = Registry.getComponentMethod('errorbars', 'makeComputeError')(params);\n  var result = new Array(data.length);\n\n  for (var i = 0; i < data.length; i++) {\n    var errors = computeError(+data[i], i);\n\n    if (axis.type === 'log') {\n      var point = axis.c2l(data[i]);\n      var min = data[i] - errors[0];\n      var max = data[i] + errors[1];\n      result[i] = [(axis.c2l(min, true) - point) * scaleFactor, (axis.c2l(max, true) - point) * scaleFactor]; // Keep track of the lower error bound which isn't negative!\n\n      if (min > 0) {\n        var lower = axis.c2l(min);\n        if (!axis._lowerLogErrorBound) axis._lowerLogErrorBound = lower;\n        axis._lowerErrorBound = Math.min(axis._lowerLogErrorBound, lower);\n      }\n    } else {\n      result[i] = [-errors[0] * scaleFactor, errors[1] * scaleFactor];\n    }\n  }\n\n  return result;\n}\n\nfunction dataLength(array) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i]) return array[i].length;\n  }\n\n  return 0;\n}\n\nfunction calculateErrors(data, scaleFactor, sceneLayout) {\n  var errors = [calculateAxisErrors(data.x, data.error_x, scaleFactor[0], sceneLayout.xaxis), calculateAxisErrors(data.y, data.error_y, scaleFactor[1], sceneLayout.yaxis), calculateAxisErrors(data.z, data.error_z, scaleFactor[2], sceneLayout.zaxis)];\n  var n = dataLength(errors);\n  if (n === 0) return null;\n  var errorBounds = new Array(n);\n\n  for (var i = 0; i < n; i++) {\n    var bound = [[0, 0, 0], [0, 0, 0]];\n\n    for (var j = 0; j < 3; j++) {\n      if (errors[j]) {\n        for (var k = 0; k < 2; k++) {\n          bound[k][j] = errors[j][i][k];\n        }\n      }\n    }\n\n    errorBounds[i] = bound;\n  }\n\n  return errorBounds;\n}\n\nmodule.exports = calculateErrors;","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/scatter3d/calc_errors.js"],"names":["Registry","require","calculateAxisErrors","data","params","scaleFactor","axis","visible","computeError","getComponentMethod","result","Array","length","i","errors","type","point","c2l","min","max","lower","_lowerLogErrorBound","_lowerErrorBound","Math","dataLength","array","calculateErrors","sceneLayout","x","error_x","xaxis","y","error_y","yaxis","z","error_z","zaxis","n","errorBounds","bound","j","k","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\n\nfunction calculateAxisErrors(data, params, scaleFactor, axis) {\n    if(!params || !params.visible) return null;\n\n    var computeError = Registry.getComponentMethod('errorbars', 'makeComputeError')(params);\n    var result = new Array(data.length);\n\n    for(var i = 0; i < data.length; i++) {\n        var errors = computeError(+data[i], i);\n\n        if(axis.type === 'log') {\n            var point = axis.c2l(data[i]);\n            var min = data[i] - errors[0];\n            var max = data[i] + errors[1];\n\n            result[i] = [\n                (axis.c2l(min, true) - point) * scaleFactor,\n                (axis.c2l(max, true) - point) * scaleFactor\n            ];\n\n            // Keep track of the lower error bound which isn't negative!\n            if(min > 0) {\n                var lower = axis.c2l(min);\n                if(!axis._lowerLogErrorBound) axis._lowerLogErrorBound = lower;\n                axis._lowerErrorBound = Math.min(axis._lowerLogErrorBound, lower);\n            }\n        } else {\n            result[i] = [\n                -errors[0] * scaleFactor,\n                errors[1] * scaleFactor\n            ];\n        }\n    }\n\n    return result;\n}\n\nfunction dataLength(array) {\n    for(var i = 0; i < array.length; i++) {\n        if(array[i]) return array[i].length;\n    }\n    return 0;\n}\n\nfunction calculateErrors(data, scaleFactor, sceneLayout) {\n    var errors = [\n        calculateAxisErrors(data.x, data.error_x, scaleFactor[0], sceneLayout.xaxis),\n        calculateAxisErrors(data.y, data.error_y, scaleFactor[1], sceneLayout.yaxis),\n        calculateAxisErrors(data.z, data.error_z, scaleFactor[2], sceneLayout.zaxis)\n    ];\n\n    var n = dataLength(errors);\n    if(n === 0) return null;\n\n    var errorBounds = new Array(n);\n\n    for(var i = 0; i < n; i++) {\n        var bound = [[0, 0, 0], [0, 0, 0]];\n\n        for(var j = 0; j < 3; j++) {\n            if(errors[j]) {\n                for(var k = 0; k < 2; k++) {\n                    bound[k][j] = errors[j][i][k];\n                }\n            }\n        }\n\n        errorBounds[i] = bound;\n    }\n\n    return errorBounds;\n}\n\nmodule.exports = calculateErrors;\n"]},"metadata":{},"sourceType":"script"}