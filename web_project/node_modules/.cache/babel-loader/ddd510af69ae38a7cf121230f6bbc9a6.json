{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict'; // Requirements\n// ============\n\nvar wrap = require('../../lib/gup').wrap;\n\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\n\nvar colorscaleCalc = require('../../components/colorscale/calc');\n\nvar filterUnique = require('../../lib/filter_unique.js');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\n\n\nmodule.exports = function calc(gd, trace) {\n  var visibleDims = Lib.filterVisible(trace.dimensions);\n  if (visibleDims.length === 0) return [];\n  var uniqueInfoDims = visibleDims.map(function (dim) {\n    var categoryValues;\n\n    if (dim.categoryorder === 'trace') {\n      // Use order of first occurrence in trace\n      categoryValues = null;\n    } else if (dim.categoryorder === 'array') {\n      // Use categories specified in `categoryarray` first,\n      // then add extra to the end in trace order\n      categoryValues = dim.categoryarray;\n    } else {\n      // Get all categories up front so we can order them\n      // Should we check for numbers as sort numerically?\n      categoryValues = filterUnique(dim.values).sort();\n\n      if (dim.categoryorder === 'category descending') {\n        categoryValues = categoryValues.reverse();\n      }\n    }\n\n    return getUniqueInfo(dim.values, categoryValues);\n  });\n  var counts, count, totalCount;\n\n  if (Lib.isArrayOrTypedArray(trace.counts)) {\n    counts = trace.counts;\n  } else {\n    counts = [trace.counts];\n  }\n\n  validateDimensionDisplayInds(visibleDims);\n  visibleDims.forEach(function (dim, dimInd) {\n    validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n  }); // Handle path colors\n  // ------------------\n\n  var line = trace.line;\n  var markerColorscale; // Process colorscale\n\n  if (line) {\n    if (hasColorscale(trace, 'line')) {\n      colorscaleCalc(gd, trace, {\n        vals: trace.line.color,\n        containerStr: 'line',\n        cLetter: 'c'\n      });\n    }\n\n    markerColorscale = Drawing.tryColorscale(line);\n  } else {\n    markerColorscale = Lib.identity;\n  } // Build color generation function\n\n\n  function getMarkerColorInfo(index) {\n    var value, rawColor;\n\n    if (Lib.isArrayOrTypedArray(line.color)) {\n      value = line.color[index % line.color.length];\n      rawColor = value;\n    } else {\n      value = line.color;\n    }\n\n    return {\n      color: markerColorscale(value),\n      rawColor: rawColor\n    };\n  } // Number of values and counts\n  // ---------------------------\n\n\n  var numValues = visibleDims[0].values.length; // Build path info\n  // ---------------\n  // Mapping from category inds to PathModel objects\n\n  var pathModels = {}; // Category inds array for each dimension\n\n  var categoryIndsDims = uniqueInfoDims.map(function (di) {\n    return di.inds;\n  }); // Initialize total count\n\n  totalCount = 0;\n  var valueInd;\n  var d;\n\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    // Category inds for this input value across dimensions\n    var categoryIndsPath = [];\n\n    for (d = 0; d < categoryIndsDims.length; d++) {\n      categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n    } // Count\n\n\n    count = counts[valueInd % counts.length]; // Update total count\n\n    totalCount += count; // Path color\n\n    var pathColorInfo = getMarkerColorInfo(valueInd); // path key\n\n    var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor; // Create / Update PathModel\n\n    if (pathModels[pathKey] === undefined) {\n      pathModels[pathKey] = createPathModel(categoryIndsPath, pathColorInfo.color, pathColorInfo.rawColor);\n    }\n\n    updatePathModel(pathModels[pathKey], valueInd, count);\n  }\n\n  var dimensionModels = visibleDims.map(function (di, i) {\n    return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n  });\n\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    count = counts[valueInd % counts.length];\n\n    for (d = 0; d < dimensionModels.length; d++) {\n      var containerInd = dimensionModels[d].containerInd;\n      var catInd = uniqueInfoDims[d].inds[valueInd];\n      var cats = dimensionModels[d].categories;\n\n      if (cats[catInd] === undefined) {\n        var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n        var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n        cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n      }\n\n      updateCategoryModel(cats[catInd], valueInd, count);\n    }\n  } // Compute unique\n\n\n  return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n}; // Models\n// ======\n// Parcats Model\n// -------------\n\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\n\n\nfunction createParcatsModel(dimensions, paths, count) {\n  var maxCats = dimensions.map(function (d) {\n    return d.categories.length;\n  }).reduce(function (v1, v2) {\n    return Math.max(v1, v2);\n  });\n  return {\n    dimensions: dimensions,\n    paths: paths,\n    trace: undefined,\n    maxCats: maxCats,\n    count: count\n  };\n} // Dimension Model\n// ---------------\n\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\n\n\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n  return {\n    dimensionInd: dimensionInd,\n    containerInd: containerInd,\n    displayInd: displayInd,\n    dimensionLabel: dimensionLabel,\n    count: count,\n    categories: [],\n    dragX: null\n  };\n} // Category Model\n// --------------\n\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\n\n\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n  return {\n    dimensionInd: dimensionInd,\n    categoryInd: categoryInd,\n    categoryValue: categoryValue,\n    displayInd: categoryInd,\n    categoryLabel: categoryLabel,\n    valueInds: [],\n    count: 0,\n    dragY: null\n  };\n}\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\n\n\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n  categoryModel.valueInds.push(valueInd);\n  categoryModel.count += count;\n} // Path Model\n// ----------\n\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\n\n\nfunction createPathModel(categoryInds, color, rawColor) {\n  return {\n    categoryInds: categoryInds,\n    color: color,\n    rawColor: rawColor,\n    valueInds: [],\n    count: 0\n  };\n}\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\n\n\nfunction updatePathModel(pathModel, valueInd, count) {\n  pathModel.valueInds.push(valueInd);\n  pathModel.count += count;\n} // Unique calculations\n// ===================\n\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\n\n\nfunction getUniqueInfo(values, uniqueValues) {\n  // Initialize uniqueValues if not specified\n  if (uniqueValues === undefined || uniqueValues === null) {\n    uniqueValues = [];\n  } else {\n    // Shallow copy so append below doesn't alter input array\n    uniqueValues = uniqueValues.map(function (e) {\n      return e;\n    });\n  } // Initialize Variables\n\n\n  var uniqueValueCounts = {};\n  var uniqueValueInds = {};\n  var inds = []; // Initialize uniqueValueCounts and\n\n  uniqueValues.forEach(function (uniqueVal, valInd) {\n    uniqueValueCounts[uniqueVal] = 0;\n    uniqueValueInds[uniqueVal] = valInd;\n  }); // Compute the necessary unique info in a single pass\n\n  for (var i = 0; i < values.length; i++) {\n    var item = values[i];\n    var itemInd;\n\n    if (uniqueValueCounts[item] === undefined) {\n      // This item has a previously unseen value\n      uniqueValueCounts[item] = 1;\n      itemInd = uniqueValues.push(item) - 1;\n      uniqueValueInds[item] = itemInd;\n    } else {\n      // Increment count for this item\n      uniqueValueCounts[item]++;\n      itemInd = uniqueValueInds[item];\n    }\n\n    inds.push(itemInd);\n  } // Build UniqueInfo\n\n\n  var uniqueCounts = uniqueValues.map(function (v) {\n    return uniqueValueCounts[v];\n  });\n  return {\n    uniqueValues: uniqueValues,\n    uniqueCounts: uniqueCounts,\n    inds: inds\n  };\n}\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\n\n\nfunction validateDimensionDisplayInds(visibleDims) {\n  var displayInds = visibleDims.map(function (d) {\n    return d.displayindex;\n  });\n  var i;\n\n  if (isRangePermutation(displayInds)) {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = visibleDims[i].displayindex;\n    }\n  } else {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = i;\n    }\n  }\n}\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\n\n\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n  // Update categoryarray\n  dim._categoryarray = uniqueInfoDim.uniqueValues; // Handle ticktext\n\n  if (dim.ticktext === null || dim.ticktext === undefined) {\n    dim._ticktext = [];\n  } else {\n    // Shallow copy to avoid modifying input array\n    dim._ticktext = dim.ticktext.slice();\n  } // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n\n\n  for (var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n    dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n  }\n}\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\n\n\nfunction isRangePermutation(inds) {\n  var indsSpecified = new Array(inds.length);\n\n  for (var i = 0; i < inds.length; i++) {\n    // Check for out of bounds\n    if (inds[i] < 0 || inds[i] >= inds.length) {\n      return false;\n    } // Check for collisions with already specified index\n\n\n    if (indsSpecified[inds[i]] !== undefined) {\n      return false;\n    }\n\n    indsSpecified[inds[i]] = true;\n  } // Nothing out of bounds and no collisions. We have a permutation\n\n\n  return true;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/parcats/calc.js"],"names":["wrap","require","hasColorscale","colorscaleCalc","filterUnique","Drawing","Lib","module","exports","calc","gd","trace","visibleDims","filterVisible","dimensions","length","uniqueInfoDims","map","dim","categoryValues","categoryorder","categoryarray","values","sort","reverse","getUniqueInfo","counts","count","totalCount","isArrayOrTypedArray","validateDimensionDisplayInds","forEach","dimInd","validateCategoryProperties","line","markerColorscale","vals","color","containerStr","cLetter","tryColorscale","identity","getMarkerColorInfo","index","value","rawColor","numValues","pathModels","categoryIndsDims","di","inds","valueInd","d","categoryIndsPath","push","pathColorInfo","pathKey","undefined","createPathModel","updatePathModel","dimensionModels","i","createDimensionModel","_index","_displayindex","label","containerInd","catInd","cats","categories","catValue","_categoryarray","catLabel","_ticktext","createCategoryModel","updateCategoryModel","createParcatsModel","paths","maxCats","reduce","v1","v2","Math","max","dimensionInd","displayInd","dimensionLabel","dragX","categoryInd","categoryValue","categoryLabel","valueInds","dragY","categoryModel","categoryInds","pathModel","uniqueValues","e","uniqueValueCounts","uniqueValueInds","uniqueVal","valInd","item","itemInd","uniqueCounts","v","displayInds","displayindex","isRangePermutation","uniqueInfoDim","ticktext","slice","indsSpecified","Array"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// Requirements\n// ============\nvar wrap = require('../../lib/gup').wrap;\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar filterUnique = require('../../lib/filter_unique.js');\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\n\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\nmodule.exports = function calc(gd, trace) {\n    var visibleDims = Lib.filterVisible(trace.dimensions);\n\n    if(visibleDims.length === 0) return [];\n\n    var uniqueInfoDims = visibleDims.map(function(dim) {\n        var categoryValues;\n        if(dim.categoryorder === 'trace') {\n            // Use order of first occurrence in trace\n            categoryValues = null;\n        } else if(dim.categoryorder === 'array') {\n            // Use categories specified in `categoryarray` first,\n            // then add extra to the end in trace order\n            categoryValues = dim.categoryarray;\n        } else {\n            // Get all categories up front so we can order them\n            // Should we check for numbers as sort numerically?\n            categoryValues = filterUnique(dim.values).sort();\n            if(dim.categoryorder === 'category descending') {\n                categoryValues = categoryValues.reverse();\n            }\n        }\n        return getUniqueInfo(dim.values, categoryValues);\n    });\n\n    var counts,\n        count,\n        totalCount;\n    if(Lib.isArrayOrTypedArray(trace.counts)) {\n        counts = trace.counts;\n    } else {\n        counts = [trace.counts];\n    }\n\n    validateDimensionDisplayInds(visibleDims);\n\n    visibleDims.forEach(function(dim, dimInd) {\n        validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n    });\n\n    // Handle path colors\n    // ------------------\n    var line = trace.line;\n    var markerColorscale;\n\n    // Process colorscale\n    if(line) {\n        if(hasColorscale(trace, 'line')) {\n            colorscaleCalc(gd, trace, {\n                vals: trace.line.color,\n                containerStr: 'line',\n                cLetter: 'c'\n            });\n        }\n        markerColorscale = Drawing.tryColorscale(line);\n    } else {\n        markerColorscale = Lib.identity;\n    }\n\n    // Build color generation function\n    function getMarkerColorInfo(index) {\n        var value, rawColor;\n        if(Lib.isArrayOrTypedArray(line.color)) {\n            value = line.color[index % line.color.length];\n            rawColor = value;\n        } else {\n            value = line.color;\n        }\n\n        return {color: markerColorscale(value), rawColor: rawColor};\n    }\n\n    // Number of values and counts\n    // ---------------------------\n    var numValues = visibleDims[0].values.length;\n\n    // Build path info\n    // ---------------\n    // Mapping from category inds to PathModel objects\n    var pathModels = {};\n\n    // Category inds array for each dimension\n    var categoryIndsDims = uniqueInfoDims.map(function(di) {return di.inds;});\n\n    // Initialize total count\n    totalCount = 0;\n    var valueInd;\n    var d;\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n        // Category inds for this input value across dimensions\n        var categoryIndsPath = [];\n        for(d = 0; d < categoryIndsDims.length; d++) {\n            categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n        }\n\n        // Count\n        count = counts[valueInd % counts.length];\n\n        // Update total count\n        totalCount += count;\n\n        // Path color\n        var pathColorInfo = getMarkerColorInfo(valueInd);\n\n        // path key\n        var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor;\n\n        // Create / Update PathModel\n        if(pathModels[pathKey] === undefined) {\n            pathModels[pathKey] = createPathModel(categoryIndsPath,\n                pathColorInfo.color,\n                pathColorInfo.rawColor);\n        }\n        updatePathModel(pathModels[pathKey], valueInd, count);\n    }\n\n    var dimensionModels = visibleDims.map(function(di, i) {\n        return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n    });\n\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n        count = counts[valueInd % counts.length];\n\n        for(d = 0; d < dimensionModels.length; d++) {\n            var containerInd = dimensionModels[d].containerInd;\n            var catInd = uniqueInfoDims[d].inds[valueInd];\n            var cats = dimensionModels[d].categories;\n\n            if(cats[catInd] === undefined) {\n                var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n                var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n                cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n            }\n\n            updateCategoryModel(cats[catInd], valueInd, count);\n        }\n    }\n\n    // Compute unique\n    return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n};\n\n// Models\n// ======\n\n// Parcats Model\n// -------------\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\nfunction createParcatsModel(dimensions, paths, count) {\n    var maxCats = dimensions\n        .map(function(d) {return d.categories.length;})\n        .reduce(function(v1, v2) {return Math.max(v1, v2);});\n    return {dimensions: dimensions, paths: paths, trace: undefined, maxCats: maxCats, count: count};\n}\n\n// Dimension Model\n// ---------------\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n    return {\n        dimensionInd: dimensionInd,\n        containerInd: containerInd,\n        displayInd: displayInd,\n        dimensionLabel: dimensionLabel,\n        count: count,\n        categories: [],\n        dragX: null\n    };\n}\n\n// Category Model\n// --------------\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n    return {\n        dimensionInd: dimensionInd,\n        categoryInd: categoryInd,\n        categoryValue: categoryValue,\n        displayInd: categoryInd,\n        categoryLabel: categoryLabel,\n        valueInds: [],\n        count: 0,\n        dragY: null\n    };\n}\n\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n    categoryModel.valueInds.push(valueInd);\n    categoryModel.count += count;\n}\n\n\n// Path Model\n// ----------\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\nfunction createPathModel(categoryInds, color, rawColor) {\n    return {\n        categoryInds: categoryInds,\n        color: color,\n        rawColor: rawColor,\n        valueInds: [],\n        count: 0\n    };\n}\n\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updatePathModel(pathModel, valueInd, count) {\n    pathModel.valueInds.push(valueInd);\n    pathModel.count += count;\n}\n\n// Unique calculations\n// ===================\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\nfunction getUniqueInfo(values, uniqueValues) {\n    // Initialize uniqueValues if not specified\n    if(uniqueValues === undefined || uniqueValues === null) {\n        uniqueValues = [];\n    } else {\n        // Shallow copy so append below doesn't alter input array\n        uniqueValues = uniqueValues.map(function(e) {return e;});\n    }\n\n    // Initialize Variables\n    var uniqueValueCounts = {};\n    var uniqueValueInds = {};\n    var inds = [];\n\n    // Initialize uniqueValueCounts and\n    uniqueValues.forEach(function(uniqueVal, valInd) {\n        uniqueValueCounts[uniqueVal] = 0;\n        uniqueValueInds[uniqueVal] = valInd;\n    });\n\n    // Compute the necessary unique info in a single pass\n    for(var i = 0; i < values.length; i++) {\n        var item = values[i];\n        var itemInd;\n\n        if(uniqueValueCounts[item] === undefined) {\n            // This item has a previously unseen value\n            uniqueValueCounts[item] = 1;\n            itemInd = uniqueValues.push(item) - 1;\n            uniqueValueInds[item] = itemInd;\n        } else {\n            // Increment count for this item\n            uniqueValueCounts[item]++;\n            itemInd = uniqueValueInds[item];\n        }\n        inds.push(itemInd);\n    }\n\n    // Build UniqueInfo\n    var uniqueCounts = uniqueValues.map(function(v) { return uniqueValueCounts[v]; });\n\n    return {\n        uniqueValues: uniqueValues,\n        uniqueCounts: uniqueCounts,\n        inds: inds\n    };\n}\n\n\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\nfunction validateDimensionDisplayInds(visibleDims) {\n    var displayInds = visibleDims.map(function(d) { return d.displayindex; });\n    var i;\n\n    if(isRangePermutation(displayInds)) {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = visibleDims[i].displayindex;\n        }\n    } else {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = i;\n        }\n    }\n}\n\n\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n    // Update categoryarray\n    dim._categoryarray = uniqueInfoDim.uniqueValues;\n\n    // Handle ticktext\n    if(dim.ticktext === null || dim.ticktext === undefined) {\n        dim._ticktext = [];\n    } else {\n        // Shallow copy to avoid modifying input array\n        dim._ticktext = dim.ticktext.slice();\n    }\n\n    // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n    for(var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n        dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n    }\n}\n\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\nfunction isRangePermutation(inds) {\n    var indsSpecified = new Array(inds.length);\n\n    for(var i = 0; i < inds.length; i++) {\n        // Check for out of bounds\n        if(inds[i] < 0 || inds[i] >= inds.length) {\n            return false;\n        }\n\n        // Check for collisions with already specified index\n        if(indsSpecified[inds[i]] !== undefined) {\n            return false;\n        }\n\n        indsSpecified[inds[i]] = true;\n    }\n\n    // Nothing out of bounds and no collisions. We have a permutation\n    return true;\n}\n"]},"metadata":{},"sourceType":"script"}