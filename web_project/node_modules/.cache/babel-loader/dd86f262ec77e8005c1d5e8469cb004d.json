{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function calcAutorange(gd) {\n  var fullLayout = gd._fullLayout;\n  var shapeList = Lib.filterVisible(fullLayout.shapes);\n  if (!shapeList.length || !gd._fullData.length) return;\n\n  for (var i = 0; i < shapeList.length; i++) {\n    var shape = shapeList[i];\n    shape._extremes = {};\n    var ax, bounds;\n\n    if (shape.xref !== 'paper') {\n      var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;\n      var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;\n      ax = Axes.getFromId(gd, shape.xref);\n      bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);\n\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n      }\n    }\n\n    if (shape.yref !== 'paper') {\n      var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;\n      var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;\n      ax = Axes.getFromId(gd, shape.yref);\n      bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);\n\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n      }\n    }\n  }\n};\n\nfunction calcXPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\n\nfunction calcYPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\n\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n  var ppad = lineWidth / 2;\n  var axisDirectionReverted = isYAxis;\n\n  if (sizeMode === 'pixel') {\n    var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];\n    var maxValue = Lib.aggNums(Math.max, null, coords);\n    var minValue = Lib.aggNums(Math.min, null, coords);\n    var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n    var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n    return {\n      ppad: ppad,\n      ppadplus: axisDirectionReverted ? beforePad : afterPad,\n      ppadminus: axisDirectionReverted ? afterPad : beforePad\n    };\n  } else {\n    return {\n      ppad: ppad\n    };\n  }\n}\n\nfunction shapeBounds(ax, v0, v1, path, paramsToUse) {\n  var convertVal = ax.type === 'category' || ax.type === 'multicategory' ? ax.r2c : ax.d2c;\n  if (v0 !== undefined) return [convertVal(v0), convertVal(v1)];\n  if (!path) return;\n  var min = Infinity;\n  var max = -Infinity;\n  var segments = path.match(constants.segmentRE);\n  var i;\n  var segment;\n  var drawnParam;\n  var params;\n  var val;\n  if (ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n\n  for (i = 0; i < segments.length; i++) {\n    segment = segments[i];\n    drawnParam = paramsToUse[segment.charAt(0)].drawn;\n    if (drawnParam === undefined) continue;\n    params = segments[i].substr(1).match(constants.paramRE);\n    if (!params || params.length < drawnParam) continue;\n    val = convertVal(params[drawnParam]);\n    if (val < min) min = val;\n    if (val > max) max = val;\n  }\n\n  if (max >= min) return [min, max];\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/components/shapes/calc_autorange.js"],"names":["Lib","require","Axes","constants","helpers","module","exports","calcAutorange","gd","fullLayout","_fullLayout","shapeList","filterVisible","shapes","length","_fullData","i","shape","_extremes","ax","bounds","xref","vx0","xsizemode","xanchor","x0","vx1","x1","getFromId","shapeBounds","path","paramIsX","_id","findExtremes","calcXPaddingOptions","yref","vy0","ysizemode","yanchor","y0","vy1","y1","paramIsY","calcYPaddingOptions","calcPaddingOptions","line","width","lineWidth","sizeMode","v0","v1","isYAxis","ppad","axisDirectionReverted","coords","extractPathCoords","maxValue","aggNums","Math","max","minValue","min","beforePad","abs","afterPad","ppadplus","ppadminus","paramsToUse","convertVal","type","r2c","d2c","undefined","Infinity","segments","match","segmentRE","segment","drawnParam","params","val","decodeDate","charAt","drawn","substr","paramRE"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n\nmodule.exports = function calcAutorange(gd) {\n    var fullLayout = gd._fullLayout;\n    var shapeList = Lib.filterVisible(fullLayout.shapes);\n\n    if(!shapeList.length || !gd._fullData.length) return;\n\n    for(var i = 0; i < shapeList.length; i++) {\n        var shape = shapeList[i];\n        shape._extremes = {};\n\n        var ax, bounds;\n\n        if(shape.xref !== 'paper') {\n            var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;\n            var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;\n            ax = Axes.getFromId(gd, shape.xref);\n\n            bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n            }\n        }\n\n        if(shape.yref !== 'paper') {\n            var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;\n            var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;\n            ax = Axes.getFromId(gd, shape.yref);\n\n            bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n            }\n        }\n    }\n};\n\nfunction calcXPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\n\nfunction calcYPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\n\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n    var ppad = lineWidth / 2;\n    var axisDirectionReverted = isYAxis;\n\n    if(sizeMode === 'pixel') {\n        var coords = path ?\n            helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) :\n            [v0, v1];\n        var maxValue = Lib.aggNums(Math.max, null, coords);\n        var minValue = Lib.aggNums(Math.min, null, coords);\n        var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n        var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n\n        return {\n            ppad: ppad,\n            ppadplus: axisDirectionReverted ? beforePad : afterPad,\n            ppadminus: axisDirectionReverted ? afterPad : beforePad\n        };\n    } else {\n        return {ppad: ppad};\n    }\n}\n\nfunction shapeBounds(ax, v0, v1, path, paramsToUse) {\n    var convertVal = (ax.type === 'category' || ax.type === 'multicategory') ? ax.r2c : ax.d2c;\n\n    if(v0 !== undefined) return [convertVal(v0), convertVal(v1)];\n    if(!path) return;\n\n    var min = Infinity;\n    var max = -Infinity;\n    var segments = path.match(constants.segmentRE);\n    var i;\n    var segment;\n    var drawnParam;\n    var params;\n    var val;\n\n    if(ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n\n    for(i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        drawnParam = paramsToUse[segment.charAt(0)].drawn;\n        if(drawnParam === undefined) continue;\n\n        params = segments[i].substr(1).match(constants.paramRE);\n        if(!params || params.length < drawnParam) continue;\n\n        val = convertVal(params[drawnParam]);\n        if(val < min) min = val;\n        if(val > max) max = val;\n    }\n    if(max >= min) return [min, max];\n}\n"]},"metadata":{},"sourceType":"script"}