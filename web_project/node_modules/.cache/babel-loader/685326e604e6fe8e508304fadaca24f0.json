{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib'); // special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V2.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\n\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\n\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\n\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\n\nexports.extractPathCoords = function (path, paramsToUse) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n  });\n  return extractedCoordinates;\n};\n\nexports.getDataToPixel = function (gd, axis, isVertical) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n\n  if (axis) {\n    var d2r = exports.shapePositionToRange(axis);\n\n    dataToPixel = function (v) {\n      return axis._offset + axis.r2p(d2r(v, true));\n    };\n\n    if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n  } else if (isVertical) {\n    dataToPixel = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  return dataToPixel;\n};\n\nexports.getPixelToData = function (gd, axis, isVertical) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n\n  if (axis) {\n    var r2d = exports.rangeToShapePosition(axis);\n\n    pixelToData = function (p) {\n      return r2d(axis.p2r(p - axis._offset));\n    };\n  } else if (isVertical) {\n    pixelToData = function (p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function (p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n\n  return pixelToData;\n};\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\n\n\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.shapes[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n\n  plotinfo.xsizemode = options.xsizemode;\n  plotinfo.ysizemode = options.ysizemode;\n  plotinfo.xanchor = options.xanchor;\n  plotinfo.yanchor = options.yanchor;\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/components/shapes/helpers.js"],"names":["constants","require","Lib","exports","rangeToShapePosition","ax","type","r2d","v","shapePositionToRange","d2r","decodeDate","convertToPx","replace","encodeDate","convertToDate","extractPathCoords","path","paramsToUse","extractedCoordinates","segments","match","segmentRE","forEach","segment","relevantParamIdx","charAt","drawn","undefined","params","substr","paramRE","length","push","cleanNumber","getDataToPixel","gd","axis","isVertical","gs","_fullLayout","_size","dataToPixel","_offset","r2p","t","h","l","w","getPixelToData","pixelToData","p","p2r","roundPositionForSharpStrokeRendering","pos","strokeWidth","strokeWidthIsOdd","Math","round","posValAsInt","makeOptionsAndPlotinfo","index","options","shapes","plotinfo","_plots","xref","yref","hasPlotinfo","_hadPlotinfo","xaxis","yaxis","xsizemode","ysizemode","xanchor","yanchor"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V2.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function(ax) {\n    return (ax.type === 'log') ? ax.r2d : function(v) { return v; };\n};\n\nexports.shapePositionToRange = function(ax) {\n    return (ax.type === 'log') ? ax.d2r : function(v) { return v; };\n};\n\nexports.decodeDate = function(convertToPx) {\n    return function(v) {\n        if(v.replace) v = v.replace('_', ' ');\n        return convertToPx(v);\n    };\n};\n\nexports.encodeDate = function(convertToDate) {\n    return function(v) { return convertToDate(v).replace(' ', '_'); };\n};\n\nexports.extractPathCoords = function(path, paramsToUse) {\n    var extractedCoordinates = [];\n\n    var segments = path.match(constants.segmentRE);\n    segments.forEach(function(segment) {\n        var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n        if(relevantParamIdx === undefined) return;\n\n        var params = segment.substr(1).match(constants.paramRE);\n        if(!params || params.length < relevantParamIdx) return;\n\n        extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n    });\n\n    return extractedCoordinates;\n};\n\nexports.getDataToPixel = function(gd, axis, isVertical) {\n    var gs = gd._fullLayout._size;\n    var dataToPixel;\n\n    if(axis) {\n        var d2r = exports.shapePositionToRange(axis);\n\n        dataToPixel = function(v) {\n            return axis._offset + axis.r2p(d2r(v, true));\n        };\n\n        if(axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n    } else if(isVertical) {\n        dataToPixel = function(v) { return gs.t + gs.h * (1 - v); };\n    } else {\n        dataToPixel = function(v) { return gs.l + gs.w * v; };\n    }\n\n    return dataToPixel;\n};\n\nexports.getPixelToData = function(gd, axis, isVertical) {\n    var gs = gd._fullLayout._size;\n    var pixelToData;\n\n    if(axis) {\n        var r2d = exports.rangeToShapePosition(axis);\n        pixelToData = function(p) { return r2d(axis.p2r(p - axis._offset)); };\n    } else if(isVertical) {\n        pixelToData = function(p) { return 1 - (p - gs.t) / gs.h; };\n    } else {\n        pixelToData = function(p) { return (p - gs.l) / gs.w; };\n    }\n\n    return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {\n    var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n    var posValAsInt = Math.round(pos);\n\n    return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeOptionsAndPlotinfo = function(gd, index) {\n    var options = gd._fullLayout.shapes[index] || {};\n\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n    var hasPlotinfo = !!plotinfo;\n    if(hasPlotinfo) {\n        plotinfo._hadPlotinfo = true;\n    } else {\n        plotinfo = {};\n        if(options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n        if(options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n    }\n\n    plotinfo.xsizemode = options.xsizemode;\n    plotinfo.ysizemode = options.ysizemode;\n    plotinfo.xanchor = options.xanchor;\n    plotinfo.yanchor = options.yanchor;\n\n    return {\n        options: options,\n        plotinfo: plotinfo\n    };\n};\n"]},"metadata":{},"sourceType":"script"}