{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\n\nvar Plots = require('../../plots/plots');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar Fx = require('../fx');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar dragElement = require('../dragelement');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar drawArrowHead = require('./draw_arrow_head'); // Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  drawRaw: drawRaw\n};\n/*\n * draw: draw all annotations without any new modifications\n */\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  fullLayout._infolayer.selectAll('.annotation').remove();\n\n  for (var i = 0; i < fullLayout.annotations.length; i++) {\n    if (fullLayout.annotations[i].visible) {\n      drawOne(gd, i);\n    }\n  }\n\n  return Plots.previousPromises(gd);\n}\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\n\n\nfunction drawOne(gd, index) {\n  var fullLayout = gd._fullLayout;\n  var options = fullLayout.annotations[index] || {};\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  if (xa) xa.setScale();\n  if (ya) ya.setScale();\n  drawRaw(gd, options, index, false, xa, ya);\n}\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\n\n\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n  var fullLayout = gd._fullLayout;\n  var gs = gd._fullLayout._size;\n  var edits = gd._context.edits;\n  var className, containerStr;\n\n  if (subplotId) {\n    className = 'annotation-' + subplotId;\n    containerStr = subplotId + '.annotations';\n  } else {\n    className = 'annotation';\n    containerStr = 'annotations';\n  }\n\n  var editHelpers = arrayEditor(gd.layout, containerStr, options);\n  var modifyBase = editHelpers.modifyBase;\n  var modifyItem = editHelpers.modifyItem;\n  var getUpdateObj = editHelpers.getUpdateObj; // remove the existing annotation if there is one\n\n  fullLayout._infolayer.selectAll('.' + className + '[data-index=\"' + index + '\"]').remove();\n\n  var annClipID = 'clip' + fullLayout._uid + '_ann' + index; // this annotation is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n\n  if (!options._input || options.visible === false) {\n    d3.selectAll('#' + annClipID).remove();\n    return;\n  } // calculated pixel positions\n  // x & y each will get text, head, and tail as appropriate\n\n\n  var annPosPx = {\n    x: {},\n    y: {}\n  };\n  var textangle = +options.textangle || 0; // create the components\n  // made a single group to contain all, so opacity can work right\n  // with border/arrow together this could handle a whole bunch of\n  // cleanup at this point, but works for now\n\n  var annGroup = fullLayout._infolayer.append('g').classed(className, true).attr('data-index', String(index)).style('opacity', options.opacity); // another group for text+background so that they can rotate together\n\n\n  var annTextGroup = annGroup.append('g').classed('annotation-text-g', true);\n  var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n  var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n\n  function makeEventData(initialEvent) {\n    var eventData = {\n      index: index,\n      annotation: options._input,\n      fullAnnotation: options,\n      event: initialEvent\n    };\n\n    if (subplotId) {\n      eventData.subplotId = subplotId;\n    }\n\n    return eventData;\n  }\n\n  var annTextGroupInner = annTextGroup.append('g').style('pointer-events', textEvents ? 'all' : null).call(setCursor, 'pointer').on('click', function () {\n    gd._dragging = false;\n    gd.emit('plotly_clickannotation', makeEventData(d3.event));\n  });\n\n  if (options.hovertext) {\n    annTextGroupInner.on('mouseover', function () {\n      var hoverOptions = options.hoverlabel;\n      var hoverFont = hoverOptions.font;\n      var bBox = this.getBoundingClientRect();\n      var bBoxRef = gd.getBoundingClientRect();\n      Fx.loneHover({\n        x0: bBox.left - bBoxRef.left,\n        x1: bBox.right - bBoxRef.left,\n        y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n        text: options.hovertext,\n        color: hoverOptions.bgcolor,\n        borderColor: hoverOptions.bordercolor,\n        fontFamily: hoverFont.family,\n        fontSize: hoverFont.size,\n        fontColor: hoverFont.color\n      }, {\n        container: fullLayout._hoverlayer.node(),\n        outerContainer: fullLayout._paper.node(),\n        gd: gd\n      });\n    }).on('mouseout', function () {\n      Fx.loneUnhover(fullLayout._hoverlayer.node());\n    });\n  }\n\n  var borderwidth = options.borderwidth;\n  var borderpad = options.borderpad;\n  var borderfull = borderwidth + borderpad;\n  var annTextBG = annTextGroupInner.append('rect').attr('class', 'bg').style('stroke-width', borderwidth + 'px').call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);\n  var isSizeConstrained = options.width || options.height;\n\n  var annTextClip = fullLayout._topclips.selectAll('#' + annClipID).data(isSizeConstrained ? [0] : []);\n\n  annTextClip.enter().append('clipPath').classed('annclip', true).attr('id', annClipID).append('rect');\n  annTextClip.exit().remove();\n  var font = options.font;\n  var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;\n  var annText = annTextGroupInner.append('text').classed('annotation-text', true).text(text);\n\n  function textLayout(s) {\n    s.call(Drawing.font, font).attr({\n      'text-anchor': {\n        left: 'start',\n        right: 'end'\n      }[options.align] || 'middle'\n    });\n    svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n    return s;\n  }\n\n  function drawGraphicalElements() {\n    // if the text has *only* a link, make the whole box into a link\n    var anchor3 = annText.selectAll('a');\n\n    if (anchor3.size() === 1 && anchor3.text() === annText.text()) {\n      var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n        'xlink:xlink:href': anchor3.attr('xlink:href'),\n        'xlink:xlink:show': anchor3.attr('xlink:show')\n      }).style({\n        cursor: 'pointer'\n      });\n      wholeLink.node().appendChild(annTextBG.node());\n    }\n\n    var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n    var hasMathjax = !mathjaxGroup.empty();\n    var anntextBB = Drawing.bBox((hasMathjax ? mathjaxGroup : annText).node());\n    var textWidth = anntextBB.width;\n    var textHeight = anntextBB.height;\n    var annWidth = options.width || textWidth;\n    var annHeight = options.height || textHeight;\n    var outerWidth = Math.round(annWidth + 2 * borderfull);\n    var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n    function shiftFraction(v, anchor) {\n      if (anchor === 'auto') {\n        if (v < 1 / 3) anchor = 'left';else if (v > 2 / 3) anchor = 'right';else anchor = 'center';\n      }\n\n      return {\n        center: 0,\n        middle: 0,\n        left: 0.5,\n        bottom: -0.5,\n        right: -0.5,\n        top: 0.5\n      }[anchor];\n    }\n\n    var annotationIsOffscreen = false;\n    var letters = ['x', 'y'];\n\n    for (var i = 0; i < letters.length; i++) {\n      var axLetter = letters[i];\n      var axRef = options[axLetter + 'ref'] || axLetter;\n      var tailRef = options['a' + axLetter + 'ref'];\n      var ax = {\n        x: xa,\n        y: ya\n      }[axLetter];\n      var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180; // note that these two can be either positive or negative\n\n      var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n      var annSizeFromHeight = outerHeight * Math.sin(dimAngle); // but this one is the positive total size\n\n      var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n      var anchor = options[axLetter + 'anchor'];\n      var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n      var posPx = annPosPx[axLetter];\n      var basePx;\n      var textPadShift;\n      var alignPosition;\n      var autoAlignFraction;\n      var textShift;\n      /*\n       * calculate the *primary* pixel position\n       * which is the arrowhead if there is one,\n       * otherwise the text anchor point\n       */\n\n      if (ax) {\n        // check if annotation is off screen, to bypass DOM manipulations\n        var posFraction = ax.r2fraction(options[axLetter]);\n\n        if (posFraction < 0 || posFraction > 1) {\n          if (tailRef === axRef) {\n            posFraction = ax.r2fraction(options['a' + axLetter]);\n\n            if (posFraction < 0 || posFraction > 1) {\n              annotationIsOffscreen = true;\n            }\n          } else {\n            annotationIsOffscreen = true;\n          }\n        }\n\n        basePx = ax._offset + ax.r2p(options[axLetter]);\n        autoAlignFraction = 0.5;\n      } else {\n        if (axLetter === 'x') {\n          alignPosition = options[axLetter];\n          basePx = gs.l + gs.w * alignPosition;\n        } else {\n          alignPosition = 1 - options[axLetter];\n          basePx = gs.t + gs.h * alignPosition;\n        }\n\n        autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n      } // now translate this into pixel positions of head, tail, and text\n      // as well as paddings for autorange\n\n\n      if (options.showarrow) {\n        posPx.head = basePx;\n        var arrowLength = options['a' + axLetter]; // with an arrow, the text rotates around the anchor point\n\n        textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n        if (tailRef === axRef) {\n          posPx.tail = ax._offset + ax.r2p(arrowLength); // tail is data-referenced: autorange pads the text in px from the tail\n\n          textPadShift = textShift;\n        } else {\n          posPx.tail = basePx + arrowLength; // tail is specified in px from head, so autorange also pads vs head\n\n          textPadShift = textShift + arrowLength;\n        }\n\n        posPx.text = posPx.tail + textShift; // constrain pixel/paper referenced so the draggers are at least\n        // partially visible\n\n        var maxPx = fullLayout[axLetter === 'x' ? 'width' : 'height'];\n\n        if (axRef === 'paper') {\n          posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n        }\n\n        if (tailRef === 'pixel') {\n          var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n          var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n\n          if (shiftPlus > 0) {\n            posPx.tail += shiftPlus;\n            posPx.text += shiftPlus;\n          } else if (shiftMinus > 0) {\n            posPx.tail -= shiftMinus;\n            posPx.text -= shiftMinus;\n          }\n        }\n\n        posPx.tail += overallShift;\n        posPx.head += overallShift;\n      } else {\n        // with no arrow, the text rotates and *then* we put the anchor\n        // relative to the new bounding box\n        textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n        textPadShift = textShift;\n        posPx.text = basePx + textShift;\n      }\n\n      posPx.text += overallShift;\n      textShift += overallShift;\n      textPadShift += overallShift; // padplus/minus are used by autorange\n\n      options['_' + axLetter + 'padplus'] = annSize / 2 + textPadShift;\n      options['_' + axLetter + 'padminus'] = annSize / 2 - textPadShift; // size/shift are used during dragging\n\n      options['_' + axLetter + 'size'] = annSize;\n      options['_' + axLetter + 'shift'] = textShift;\n    }\n\n    if (annotationIsOffscreen) {\n      annTextGroupInner.remove();\n      return;\n    }\n\n    var xShift = 0;\n    var yShift = 0;\n\n    if (options.align !== 'left') {\n      xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n    }\n\n    if (options.valign !== 'top') {\n      yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n    }\n\n    if (hasMathjax) {\n      mathjaxGroup.select('svg').attr({\n        x: borderfull + xShift - 1,\n        y: borderfull + yShift\n      }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    } else {\n      var texty = borderfull + yShift - anntextBB.top;\n      var textx = borderfull + xShift - anntextBB.left;\n      annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    }\n\n    annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull, annWidth, annHeight);\n    annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2, outerWidth - borderwidth, outerHeight - borderwidth);\n    annTextGroupInner.call(Drawing.setTranslate, Math.round(annPosPx.x.text - outerWidth / 2), Math.round(annPosPx.y.text - outerHeight / 2));\n    /*\n     * rotate text and background\n     * we already calculated the text center position *as rotated*\n     * because we needed that for autoranging anyway, so now whether\n     * we have an arrow or not, we rotate about the text center.\n     */\n\n    annTextGroup.attr({\n      transform: 'rotate(' + textangle + ',' + annPosPx.x.text + ',' + annPosPx.y.text + ')'\n    });\n    /*\n     * add the arrow\n     * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n     * dx and dy are normally zero, but when you are dragging the textbox\n     * while the head stays put, dx and dy are the pixel offsets\n     */\n\n    var drawArrow = function (dx, dy) {\n      annGroup.selectAll('.annotation-arrow-g').remove();\n      var headX = annPosPx.x.head;\n      var headY = annPosPx.y.head;\n      var tailX = annPosPx.x.tail + dx;\n      var tailY = annPosPx.y.tail + dy;\n      var textX = annPosPx.x.text + dx;\n      var textY = annPosPx.y.text + dy; // find the edge of the text box, where we'll start the arrow:\n      // create transform matrix to rotate the text box corners\n\n      var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n      var applyTransform = Lib.apply2DTransform(transform);\n      var applyTransform2 = Lib.apply2DTransform2(transform); // calculate and transform bounding box\n\n      var width = +annTextBG.attr('width');\n      var height = +annTextBG.attr('height');\n      var xLeft = textX - 0.5 * width;\n      var xRight = xLeft + width;\n      var yTop = textY - 0.5 * height;\n      var yBottom = yTop + height;\n      var edges = [[xLeft, yTop, xLeft, yBottom], [xLeft, yBottom, xRight, yBottom], [xRight, yBottom, xRight, yTop], [xRight, yTop, xLeft, yTop]].map(applyTransform2); // Remove the line if it ends inside the box.  Use ray\n      // casting for rotated boxes: see which edges intersect a\n      // line from the arrowhead to far away and reduce with xor\n      // to get the parity of the number of intersections.\n\n      if (edges.reduce(function (a, x) {\n        return a ^ !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6, x[0], x[1], x[2], x[3]);\n      }, false)) {\n        // no line or arrow - so quit drawArrow now\n        return;\n      }\n\n      edges.forEach(function (x) {\n        var p = Lib.segmentsIntersect(tailX, tailY, headX, headY, x[0], x[1], x[2], x[3]);\n\n        if (p) {\n          tailX = p.x;\n          tailY = p.y;\n        }\n      });\n      var strokewidth = options.arrowwidth;\n      var arrowColor = options.arrowcolor;\n      var arrowSide = options.arrowside;\n      var arrowGroup = annGroup.append('g').style({\n        opacity: Color.opacity(arrowColor)\n      }).classed('annotation-arrow-g', true);\n      var arrow = arrowGroup.append('path').attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY).style('stroke-width', strokewidth + 'px').call(Color.stroke, Color.rgb(arrowColor));\n      drawArrowHead(arrow, arrowSide, options); // the arrow dragger is a small square right at the head, then a line to the tail,\n      // all expanded by a stroke width of 6px plus the arrow line width\n\n      if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n        var arrowDragHeadX = headX;\n        var arrowDragHeadY = headY;\n\n        if (options.standoff) {\n          var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n          arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n          arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n        }\n\n        var arrowDrag = arrowGroup.append('path').classed('annotation-arrow', true).classed('anndrag', true).classed('cursor-move', true).attr({\n          d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n          transform: 'translate(' + arrowDragHeadX + ',' + arrowDragHeadY + ')'\n        }).style('stroke-width', strokewidth + 6 + 'px').call(Color.stroke, 'rgba(0,0,0,0)').call(Color.fill, 'rgba(0,0,0,0)');\n        var annx0, anny0; // dragger for the arrow & head: translates the whole thing\n        // (head/tail/text) all together\n\n        dragElement.init({\n          element: arrowDrag.node(),\n          gd: gd,\n          prepFn: function () {\n            var pos = Drawing.getTranslate(annTextGroupInner);\n            annx0 = pos.x;\n            anny0 = pos.y;\n\n            if (xa && xa.autorange) {\n              modifyBase(xa._name + '.autorange', true);\n            }\n\n            if (ya && ya.autorange) {\n              modifyBase(ya._name + '.autorange', true);\n            }\n          },\n          moveFn: function (dx, dy) {\n            var annxy0 = applyTransform(annx0, anny0);\n            var xcenter = annxy0[0] + dx;\n            var ycenter = annxy0[1] + dy;\n            annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n            modifyItem('x', xa ? xa.p2r(xa.r2p(options.x) + dx) : options.x + dx / gs.w);\n            modifyItem('y', ya ? ya.p2r(ya.r2p(options.y) + dy) : options.y - dy / gs.h);\n\n            if (options.axref === options.xref) {\n              modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n            }\n\n            if (options.ayref === options.yref) {\n              modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n            }\n\n            arrowGroup.attr('transform', 'translate(' + dx + ',' + dy + ')');\n            annTextGroup.attr({\n              transform: 'rotate(' + textangle + ',' + xcenter + ',' + ycenter + ')'\n            });\n          },\n          doneFn: function () {\n            Registry.call('_guiRelayout', gd, getUpdateObj());\n            var notesBox = document.querySelector('.js-notes-box-panel');\n            if (notesBox) notesBox.redraw(notesBox.selectedObj);\n          }\n        });\n      }\n    };\n\n    if (options.showarrow) drawArrow(0, 0); // user dragging the annotation (text, not arrow)\n\n    if (editTextPosition) {\n      var baseTextTransform; // dragger for the textbox: if there's an arrow, just drag the\n      // textbox and tail, leave the head untouched\n\n      dragElement.init({\n        element: annTextGroupInner.node(),\n        gd: gd,\n        prepFn: function () {\n          baseTextTransform = annTextGroup.attr('transform');\n        },\n        moveFn: function (dx, dy) {\n          var csr = 'pointer';\n\n          if (options.showarrow) {\n            if (options.axref === options.xref) {\n              modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n            } else {\n              modifyItem('ax', options.ax + dx);\n            }\n\n            if (options.ayref === options.yref) {\n              modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n            } else {\n              modifyItem('ay', options.ay + dy);\n            }\n\n            drawArrow(dx, dy);\n          } else if (!subplotId) {\n            var xUpdate, yUpdate;\n\n            if (xa) {\n              xUpdate = xa.p2r(xa.r2p(options.x) + dx);\n            } else {\n              var widthFraction = options._xsize / gs.w;\n              var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n              xUpdate = dragElement.align(xLeft + dx / gs.w, widthFraction, 0, 1, options.xanchor);\n            }\n\n            if (ya) {\n              yUpdate = ya.p2r(ya.r2p(options.y) + dy);\n            } else {\n              var heightFraction = options._ysize / gs.h;\n              var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n              yUpdate = dragElement.align(yBottom - dy / gs.h, heightFraction, 0, 1, options.yanchor);\n            }\n\n            modifyItem('x', xUpdate);\n            modifyItem('y', yUpdate);\n\n            if (!xa || !ya) {\n              csr = dragElement.getCursor(xa ? 0.5 : xUpdate, ya ? 0.5 : yUpdate, options.xanchor, options.yanchor);\n            }\n          } else return;\n\n          annTextGroup.attr({\n            transform: 'translate(' + dx + ',' + dy + ')' + baseTextTransform\n          });\n          setCursor(annTextGroupInner, csr);\n        },\n        clickFn: function (_, initialEvent) {\n          if (options.captureevents) {\n            gd.emit('plotly_clickannotation', makeEventData(initialEvent));\n          }\n        },\n        doneFn: function () {\n          setCursor(annTextGroupInner);\n          Registry.call('_guiRelayout', gd, getUpdateObj());\n          var notesBox = document.querySelector('.js-notes-box-panel');\n          if (notesBox) notesBox.redraw(notesBox.selectedObj);\n        }\n      });\n    }\n  }\n\n  if (edits.annotationText) {\n    annText.call(svgTextUtils.makeEditable, {\n      delegate: annTextGroupInner,\n      gd: gd\n    }).call(textLayout).on('edit', function (_text) {\n      options.text = _text;\n      this.call(textLayout);\n      modifyItem('text', _text);\n\n      if (xa && xa.autorange) {\n        modifyBase(xa._name + '.autorange', true);\n      }\n\n      if (ya && ya.autorange) {\n        modifyBase(ya._name + '.autorange', true);\n      }\n\n      Registry.call('_guiRelayout', gd, getUpdateObj());\n    });\n  } else annText.call(textLayout);\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/components/annotations/draw.js"],"names":["d3","require","Registry","Plots","Lib","Axes","Color","Drawing","Fx","svgTextUtils","setCursor","dragElement","arrayEditor","drawArrowHead","module","exports","draw","drawOne","drawRaw","gd","fullLayout","_fullLayout","_infolayer","selectAll","remove","i","annotations","length","visible","previousPromises","index","options","xa","getFromId","xref","ya","yref","setScale","subplotId","gs","_size","edits","_context","className","containerStr","editHelpers","layout","modifyBase","modifyItem","getUpdateObj","annClipID","_uid","_input","annPosPx","x","y","textangle","annGroup","append","classed","attr","String","style","opacity","annTextGroup","editTextPosition","showarrow","textEvents","captureevents","annotationText","makeEventData","initialEvent","eventData","annotation","fullAnnotation","event","annTextGroupInner","call","on","_dragging","emit","hovertext","hoverOptions","hoverlabel","hoverFont","font","bBox","getBoundingClientRect","bBoxRef","loneHover","x0","left","x1","right","top","bottom","text","color","bgcolor","borderColor","bordercolor","fontFamily","family","fontSize","size","fontColor","container","_hoverlayer","node","outerContainer","_paper","loneUnhover","borderwidth","borderpad","borderfull","annTextBG","stroke","fill","isSizeConstrained","width","height","annTextClip","_topclips","data","enter","exit","_meta","templateString","annText","textLayout","s","align","convertToTspans","drawGraphicalElements","anchor3","wholeLink","insert","cursor","appendChild","mathjaxGroup","select","hasMathjax","empty","anntextBB","textWidth","textHeight","annWidth","annHeight","outerWidth","Math","round","outerHeight","shiftFraction","v","anchor","center","middle","annotationIsOffscreen","letters","axLetter","axRef","tailRef","ax","dimAngle","PI","annSizeFromWidth","cos","annSizeFromHeight","sin","annSize","abs","overallShift","posPx","basePx","textPadShift","alignPosition","autoAlignFraction","textShift","posFraction","r2fraction","_offset","r2p","l","w","t","h","head","arrowLength","xanchor","yanchor","tail","maxPx","constrain","shiftPlus","max","shiftMinus","min","xShift","yShift","valign","setClipUrl","texty","textx","positionText","setRect","setTranslate","transform","drawArrow","dx","dy","headX","headY","tailX","tailY","textX","textY","rotationXYMatrix","applyTransform","apply2DTransform","applyTransform2","apply2DTransform2","xLeft","xRight","yTop","yBottom","edges","map","reduce","a","segmentsIntersect","forEach","p","strokewidth","arrowwidth","arrowColor","arrowcolor","arrowSide","arrowside","arrowGroup","arrow","rgb","annotationPosition","parentNode","arrowDragHeadX","arrowDragHeadY","standoff","sqrt","pow","arrowDrag","d","annx0","anny0","init","element","prepFn","pos","getTranslate","autorange","_name","moveFn","annxy0","xcenter","ycenter","p2r","axref","ayref","ay","doneFn","notesBox","document","querySelector","redraw","selectedObj","baseTextTransform","csr","xUpdate","yUpdate","widthFraction","_xsize","_xshift","xshift","heightFraction","_ysize","_yshift","yshift","getCursor","clickFn","_","makeEditable","delegate","_text"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Fx = require('../fx');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../dragelement');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar drawArrowHead = require('./draw_arrow_head');\n\n// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne,\n    drawRaw: drawRaw\n};\n\n/*\n * draw: draw all annotations without any new modifications\n */\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    fullLayout._infolayer.selectAll('.annotation').remove();\n\n    for(var i = 0; i < fullLayout.annotations.length; i++) {\n        if(fullLayout.annotations[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    return Plots.previousPromises(gd);\n}\n\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\nfunction drawOne(gd, index) {\n    var fullLayout = gd._fullLayout;\n    var options = fullLayout.annotations[index] || {};\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n\n    if(xa) xa.setScale();\n    if(ya) ya.setScale();\n\n    drawRaw(gd, options, index, false, xa, ya);\n}\n\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n    var fullLayout = gd._fullLayout;\n    var gs = gd._fullLayout._size;\n    var edits = gd._context.edits;\n\n    var className, containerStr;\n\n    if(subplotId) {\n        className = 'annotation-' + subplotId;\n        containerStr = subplotId + '.annotations';\n    } else {\n        className = 'annotation';\n        containerStr = 'annotations';\n    }\n\n    var editHelpers = arrayEditor(gd.layout, containerStr, options);\n    var modifyBase = editHelpers.modifyBase;\n    var modifyItem = editHelpers.modifyItem;\n    var getUpdateObj = editHelpers.getUpdateObj;\n\n    // remove the existing annotation if there is one\n    fullLayout._infolayer\n        .selectAll('.' + className + '[data-index=\"' + index + '\"]')\n        .remove();\n\n    var annClipID = 'clip' + fullLayout._uid + '_ann' + index;\n\n    // this annotation is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible === false) {\n        d3.selectAll('#' + annClipID).remove();\n        return;\n    }\n\n    // calculated pixel positions\n    // x & y each will get text, head, and tail as appropriate\n    var annPosPx = {x: {}, y: {}};\n    var textangle = +options.textangle || 0;\n\n    // create the components\n    // made a single group to contain all, so opacity can work right\n    // with border/arrow together this could handle a whole bunch of\n    // cleanup at this point, but works for now\n    var annGroup = fullLayout._infolayer.append('g')\n        .classed(className, true)\n        .attr('data-index', String(index))\n        .style('opacity', options.opacity);\n\n    // another group for text+background so that they can rotate together\n    var annTextGroup = annGroup.append('g')\n        .classed('annotation-text-g', true);\n\n    var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n    var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n\n    function makeEventData(initialEvent) {\n        var eventData = {\n            index: index,\n            annotation: options._input,\n            fullAnnotation: options,\n            event: initialEvent\n        };\n        if(subplotId) {\n            eventData.subplotId = subplotId;\n        }\n        return eventData;\n    }\n\n    var annTextGroupInner = annTextGroup.append('g')\n        .style('pointer-events', textEvents ? 'all' : null)\n        .call(setCursor, 'pointer')\n        .on('click', function() {\n            gd._dragging = false;\n            gd.emit('plotly_clickannotation', makeEventData(d3.event));\n        });\n\n    if(options.hovertext) {\n        annTextGroupInner\n        .on('mouseover', function() {\n            var hoverOptions = options.hoverlabel;\n            var hoverFont = hoverOptions.font;\n            var bBox = this.getBoundingClientRect();\n            var bBoxRef = gd.getBoundingClientRect();\n\n            Fx.loneHover({\n                x0: bBox.left - bBoxRef.left,\n                x1: bBox.right - bBoxRef.left,\n                y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n                text: options.hovertext,\n                color: hoverOptions.bgcolor,\n                borderColor: hoverOptions.bordercolor,\n                fontFamily: hoverFont.family,\n                fontSize: hoverFont.size,\n                fontColor: hoverFont.color\n            }, {\n                container: fullLayout._hoverlayer.node(),\n                outerContainer: fullLayout._paper.node(),\n                gd: gd\n            });\n        })\n        .on('mouseout', function() {\n            Fx.loneUnhover(fullLayout._hoverlayer.node());\n        });\n    }\n\n    var borderwidth = options.borderwidth;\n    var borderpad = options.borderpad;\n    var borderfull = borderwidth + borderpad;\n\n    var annTextBG = annTextGroupInner.append('rect')\n        .attr('class', 'bg')\n        .style('stroke-width', borderwidth + 'px')\n        .call(Color.stroke, options.bordercolor)\n        .call(Color.fill, options.bgcolor);\n\n    var isSizeConstrained = options.width || options.height;\n\n    var annTextClip = fullLayout._topclips\n        .selectAll('#' + annClipID)\n        .data(isSizeConstrained ? [0] : []);\n\n    annTextClip.enter().append('clipPath')\n        .classed('annclip', true)\n        .attr('id', annClipID)\n      .append('rect');\n    annTextClip.exit().remove();\n\n    var font = options.font;\n\n    var text = fullLayout._meta ?\n        Lib.templateString(options.text, fullLayout._meta) :\n        options.text;\n\n    var annText = annTextGroupInner.append('text')\n        .classed('annotation-text', true)\n        .text(text);\n\n    function textLayout(s) {\n        s.call(Drawing.font, font)\n        .attr({\n            'text-anchor': {\n                left: 'start',\n                right: 'end'\n            }[options.align] || 'middle'\n        });\n\n        svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n        return s;\n    }\n\n    function drawGraphicalElements() {\n        // if the text has *only* a link, make the whole box into a link\n        var anchor3 = annText.selectAll('a');\n        if(anchor3.size() === 1 && anchor3.text() === annText.text()) {\n            var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n                'xlink:xlink:href': anchor3.attr('xlink:href'),\n                'xlink:xlink:show': anchor3.attr('xlink:show')\n            })\n            .style({cursor: 'pointer'});\n\n            wholeLink.node().appendChild(annTextBG.node());\n        }\n\n        var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n        var hasMathjax = !mathjaxGroup.empty();\n        var anntextBB = Drawing.bBox(\n                (hasMathjax ? mathjaxGroup : annText).node());\n        var textWidth = anntextBB.width;\n        var textHeight = anntextBB.height;\n        var annWidth = options.width || textWidth;\n        var annHeight = options.height || textHeight;\n        var outerWidth = Math.round(annWidth + 2 * borderfull);\n        var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n        function shiftFraction(v, anchor) {\n            if(anchor === 'auto') {\n                if(v < 1 / 3) anchor = 'left';\n                else if(v > 2 / 3) anchor = 'right';\n                else anchor = 'center';\n            }\n            return {\n                center: 0,\n                middle: 0,\n                left: 0.5,\n                bottom: -0.5,\n                right: -0.5,\n                top: 0.5\n            }[anchor];\n        }\n\n        var annotationIsOffscreen = false;\n        var letters = ['x', 'y'];\n\n        for(var i = 0; i < letters.length; i++) {\n            var axLetter = letters[i];\n            var axRef = options[axLetter + 'ref'] || axLetter;\n            var tailRef = options['a' + axLetter + 'ref'];\n            var ax = {x: xa, y: ya}[axLetter];\n            var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;\n            // note that these two can be either positive or negative\n            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);\n            // but this one is the positive total size\n            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n            var anchor = options[axLetter + 'anchor'];\n            var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n            var posPx = annPosPx[axLetter];\n            var basePx;\n            var textPadShift;\n            var alignPosition;\n            var autoAlignFraction;\n            var textShift;\n\n            /*\n             * calculate the *primary* pixel position\n             * which is the arrowhead if there is one,\n             * otherwise the text anchor point\n             */\n            if(ax) {\n                // check if annotation is off screen, to bypass DOM manipulations\n                var posFraction = ax.r2fraction(options[axLetter]);\n                if(posFraction < 0 || posFraction > 1) {\n                    if(tailRef === axRef) {\n                        posFraction = ax.r2fraction(options['a' + axLetter]);\n                        if(posFraction < 0 || posFraction > 1) {\n                            annotationIsOffscreen = true;\n                        }\n                    } else {\n                        annotationIsOffscreen = true;\n                    }\n                }\n                basePx = ax._offset + ax.r2p(options[axLetter]);\n                autoAlignFraction = 0.5;\n            } else {\n                if(axLetter === 'x') {\n                    alignPosition = options[axLetter];\n                    basePx = gs.l + gs.w * alignPosition;\n                } else {\n                    alignPosition = 1 - options[axLetter];\n                    basePx = gs.t + gs.h * alignPosition;\n                }\n                autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n            }\n\n            // now translate this into pixel positions of head, tail, and text\n            // as well as paddings for autorange\n            if(options.showarrow) {\n                posPx.head = basePx;\n\n                var arrowLength = options['a' + axLetter];\n\n                // with an arrow, the text rotates around the anchor point\n                textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) -\n                    annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n                if(tailRef === axRef) {\n                    posPx.tail = ax._offset + ax.r2p(arrowLength);\n                    // tail is data-referenced: autorange pads the text in px from the tail\n                    textPadShift = textShift;\n                } else {\n                    posPx.tail = basePx + arrowLength;\n                    // tail is specified in px from head, so autorange also pads vs head\n                    textPadShift = textShift + arrowLength;\n                }\n\n                posPx.text = posPx.tail + textShift;\n\n                // constrain pixel/paper referenced so the draggers are at least\n                // partially visible\n                var maxPx = fullLayout[(axLetter === 'x') ? 'width' : 'height'];\n                if(axRef === 'paper') {\n                    posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n                }\n                if(tailRef === 'pixel') {\n                    var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n                    var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n                    if(shiftPlus > 0) {\n                        posPx.tail += shiftPlus;\n                        posPx.text += shiftPlus;\n                    } else if(shiftMinus > 0) {\n                        posPx.tail -= shiftMinus;\n                        posPx.text -= shiftMinus;\n                    }\n                }\n\n                posPx.tail += overallShift;\n                posPx.head += overallShift;\n            } else {\n                // with no arrow, the text rotates and *then* we put the anchor\n                // relative to the new bounding box\n                textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n                textPadShift = textShift;\n                posPx.text = basePx + textShift;\n            }\n\n            posPx.text += overallShift;\n            textShift += overallShift;\n            textPadShift += overallShift;\n\n            // padplus/minus are used by autorange\n            options['_' + axLetter + 'padplus'] = (annSize / 2) + textPadShift;\n            options['_' + axLetter + 'padminus'] = (annSize / 2) - textPadShift;\n\n            // size/shift are used during dragging\n            options['_' + axLetter + 'size'] = annSize;\n            options['_' + axLetter + 'shift'] = textShift;\n        }\n\n        if(annotationIsOffscreen) {\n            annTextGroupInner.remove();\n            return;\n        }\n\n        var xShift = 0;\n        var yShift = 0;\n\n        if(options.align !== 'left') {\n            xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n        }\n        if(options.valign !== 'top') {\n            yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n        }\n\n        if(hasMathjax) {\n            mathjaxGroup.select('svg').attr({\n                x: borderfull + xShift - 1,\n                y: borderfull + yShift\n            })\n            .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        } else {\n            var texty = borderfull + yShift - anntextBB.top;\n            var textx = borderfull + xShift - anntextBB.left;\n\n            annText.call(svgTextUtils.positionText, textx, texty)\n                .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        }\n\n        annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull,\n            annWidth, annHeight);\n\n        annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2,\n            outerWidth - borderwidth, outerHeight - borderwidth);\n\n        annTextGroupInner.call(Drawing.setTranslate,\n            Math.round(annPosPx.x.text - outerWidth / 2),\n            Math.round(annPosPx.y.text - outerHeight / 2));\n\n        /*\n         * rotate text and background\n         * we already calculated the text center position *as rotated*\n         * because we needed that for autoranging anyway, so now whether\n         * we have an arrow or not, we rotate about the text center.\n         */\n        annTextGroup.attr({transform: 'rotate(' + textangle + ',' +\n                            annPosPx.x.text + ',' + annPosPx.y.text + ')'});\n\n        /*\n         * add the arrow\n         * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n         * dx and dy are normally zero, but when you are dragging the textbox\n         * while the head stays put, dx and dy are the pixel offsets\n         */\n        var drawArrow = function(dx, dy) {\n            annGroup\n                .selectAll('.annotation-arrow-g')\n                .remove();\n\n            var headX = annPosPx.x.head;\n            var headY = annPosPx.y.head;\n            var tailX = annPosPx.x.tail + dx;\n            var tailY = annPosPx.y.tail + dy;\n            var textX = annPosPx.x.text + dx;\n            var textY = annPosPx.y.text + dy;\n\n            // find the edge of the text box, where we'll start the arrow:\n            // create transform matrix to rotate the text box corners\n            var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n            var applyTransform = Lib.apply2DTransform(transform);\n            var applyTransform2 = Lib.apply2DTransform2(transform);\n\n            // calculate and transform bounding box\n            var width = +annTextBG.attr('width');\n            var height = +annTextBG.attr('height');\n            var xLeft = textX - 0.5 * width;\n            var xRight = xLeft + width;\n            var yTop = textY - 0.5 * height;\n            var yBottom = yTop + height;\n            var edges = [\n                [xLeft, yTop, xLeft, yBottom],\n                [xLeft, yBottom, xRight, yBottom],\n                [xRight, yBottom, xRight, yTop],\n                [xRight, yTop, xLeft, yTop]\n            ].map(applyTransform2);\n\n            // Remove the line if it ends inside the box.  Use ray\n            // casting for rotated boxes: see which edges intersect a\n            // line from the arrowhead to far away and reduce with xor\n            // to get the parity of the number of intersections.\n            if(edges.reduce(function(a, x) {\n                return a ^\n                    !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6,\n                            x[0], x[1], x[2], x[3]);\n            }, false)) {\n                // no line or arrow - so quit drawArrow now\n                return;\n            }\n\n            edges.forEach(function(x) {\n                var p = Lib.segmentsIntersect(tailX, tailY, headX, headY,\n                            x[0], x[1], x[2], x[3]);\n                if(p) {\n                    tailX = p.x;\n                    tailY = p.y;\n                }\n            });\n\n            var strokewidth = options.arrowwidth;\n            var arrowColor = options.arrowcolor;\n            var arrowSide = options.arrowside;\n\n            var arrowGroup = annGroup.append('g')\n                .style({opacity: Color.opacity(arrowColor)})\n                .classed('annotation-arrow-g', true);\n\n            var arrow = arrowGroup.append('path')\n                .attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY)\n                .style('stroke-width', strokewidth + 'px')\n                .call(Color.stroke, Color.rgb(arrowColor));\n\n            drawArrowHead(arrow, arrowSide, options);\n\n            // the arrow dragger is a small square right at the head, then a line to the tail,\n            // all expanded by a stroke width of 6px plus the arrow line width\n            if(edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n                var arrowDragHeadX = headX;\n                var arrowDragHeadY = headY;\n                if(options.standoff) {\n                    var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n                    arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n                    arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n                }\n                var arrowDrag = arrowGroup.append('path')\n                    .classed('annotation-arrow', true)\n                    .classed('anndrag', true)\n                    .classed('cursor-move', true)\n                    .attr({\n                        d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n                        transform: 'translate(' + arrowDragHeadX + ',' + arrowDragHeadY + ')'\n                    })\n                    .style('stroke-width', (strokewidth + 6) + 'px')\n                    .call(Color.stroke, 'rgba(0,0,0,0)')\n                    .call(Color.fill, 'rgba(0,0,0,0)');\n\n                var annx0, anny0;\n\n                // dragger for the arrow & head: translates the whole thing\n                // (head/tail/text) all together\n                dragElement.init({\n                    element: arrowDrag.node(),\n                    gd: gd,\n                    prepFn: function() {\n                        var pos = Drawing.getTranslate(annTextGroupInner);\n\n                        annx0 = pos.x;\n                        anny0 = pos.y;\n                        if(xa && xa.autorange) {\n                            modifyBase(xa._name + '.autorange', true);\n                        }\n                        if(ya && ya.autorange) {\n                            modifyBase(ya._name + '.autorange', true);\n                        }\n                    },\n                    moveFn: function(dx, dy) {\n                        var annxy0 = applyTransform(annx0, anny0);\n                        var xcenter = annxy0[0] + dx;\n                        var ycenter = annxy0[1] + dy;\n                        annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n\n                        modifyItem('x', xa ?\n                            xa.p2r(xa.r2p(options.x) + dx) :\n                            (options.x + (dx / gs.w)));\n                        modifyItem('y', ya ?\n                            ya.p2r(ya.r2p(options.y) + dy) :\n                            (options.y - (dy / gs.h)));\n\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n                        }\n\n                        arrowGroup.attr('transform', 'translate(' + dx + ',' + dy + ')');\n                        annTextGroup.attr({\n                            transform: 'rotate(' + textangle + ',' +\n                                   xcenter + ',' + ycenter + ')'\n                        });\n                    },\n                    doneFn: function() {\n                        Registry.call('_guiRelayout', gd, getUpdateObj());\n                        var notesBox = document.querySelector('.js-notes-box-panel');\n                        if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                    }\n                });\n            }\n        };\n\n        if(options.showarrow) drawArrow(0, 0);\n\n        // user dragging the annotation (text, not arrow)\n        if(editTextPosition) {\n            var baseTextTransform;\n\n            // dragger for the textbox: if there's an arrow, just drag the\n            // textbox and tail, leave the head untouched\n            dragElement.init({\n                element: annTextGroupInner.node(),\n                gd: gd,\n                prepFn: function() {\n                    baseTextTransform = annTextGroup.attr('transform');\n                },\n                moveFn: function(dx, dy) {\n                    var csr = 'pointer';\n                    if(options.showarrow) {\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n                        } else {\n                            modifyItem('ax', options.ax + dx);\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n                        } else {\n                            modifyItem('ay', options.ay + dy);\n                        }\n\n                        drawArrow(dx, dy);\n                    } else if(!subplotId) {\n                        var xUpdate, yUpdate;\n                        if(xa) {\n                            xUpdate = xa.p2r(xa.r2p(options.x) + dx);\n                        } else {\n                            var widthFraction = options._xsize / gs.w;\n                            var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n\n                            xUpdate = dragElement.align(xLeft + dx / gs.w,\n                                widthFraction, 0, 1, options.xanchor);\n                        }\n\n                        if(ya) {\n                            yUpdate = ya.p2r(ya.r2p(options.y) + dy);\n                        } else {\n                            var heightFraction = options._ysize / gs.h;\n                            var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n\n                            yUpdate = dragElement.align(yBottom - dy / gs.h,\n                                heightFraction, 0, 1, options.yanchor);\n                        }\n                        modifyItem('x', xUpdate);\n                        modifyItem('y', yUpdate);\n                        if(!xa || !ya) {\n                            csr = dragElement.getCursor(\n                                xa ? 0.5 : xUpdate,\n                                ya ? 0.5 : yUpdate,\n                                options.xanchor, options.yanchor\n                            );\n                        }\n                    } else return;\n\n                    annTextGroup.attr({\n                        transform: 'translate(' + dx + ',' + dy + ')' + baseTextTransform\n                    });\n\n                    setCursor(annTextGroupInner, csr);\n                },\n                clickFn: function(_, initialEvent) {\n                    if(options.captureevents) {\n                        gd.emit('plotly_clickannotation', makeEventData(initialEvent));\n                    }\n                },\n                doneFn: function() {\n                    setCursor(annTextGroupInner);\n                    Registry.call('_guiRelayout', gd, getUpdateObj());\n                    var notesBox = document.querySelector('.js-notes-box-panel');\n                    if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                }\n            });\n        }\n    }\n\n    if(edits.annotationText) {\n        annText.call(svgTextUtils.makeEditable, {delegate: annTextGroupInner, gd: gd})\n            .call(textLayout)\n            .on('edit', function(_text) {\n                options.text = _text;\n\n                this.call(textLayout);\n\n                modifyItem('text', _text);\n\n                if(xa && xa.autorange) {\n                    modifyBase(xa._name + '.autorange', true);\n                }\n                if(ya && ya.autorange) {\n                    modifyBase(ya._name + '.autorange', true);\n                }\n\n                Registry.call('_guiRelayout', gd, getUpdateObj());\n            });\n    } else annText.call(textLayout);\n}\n"]},"metadata":{},"sourceType":"script"}