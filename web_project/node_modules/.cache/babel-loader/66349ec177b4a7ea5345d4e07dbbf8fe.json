{"ast":null,"code":"'use strict';\n\nmodule.exports = planarGraphToPolyline;\n\nvar e2a = require('edges-to-adjacency-list');\n\nvar planarDual = require('planar-dual');\n\nvar preprocessPolygon = require('point-in-big-polygon');\n\nvar twoProduct = require('two-product');\n\nvar robustSum = require('robust-sum');\n\nvar uniq = require('uniq');\n\nvar trimLeaves = require('./lib/trim-leaves');\n\nfunction makeArray(length, fill) {\n  var result = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = fill;\n  }\n\n  return result;\n}\n\nfunction makeArrayOfArrays(length) {\n  var result = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = [];\n  }\n\n  return result;\n}\n\nfunction planarGraphToPolyline(edges, positions) {\n  //Trim leaves\n  var result = trimLeaves(edges, positions);\n  edges = result[0];\n  positions = result[1];\n  var numVertices = positions.length;\n  var numEdges = edges.length; //Calculate adjacency list, check manifold\n\n  var adj = e2a(edges, positions.length);\n\n  for (var i = 0; i < numVertices; ++i) {\n    if (adj[i].length % 2 === 1) {\n      throw new Error('planar-graph-to-polyline: graph must be manifold');\n    }\n  } //Get faces\n\n\n  var faces = planarDual(edges, positions); //Check orientation of a polygon using exact arithmetic\n\n  function ccw(c) {\n    var n = c.length;\n    var area = [0];\n\n    for (var j = 0; j < n; ++j) {\n      var a = positions[c[j]];\n      var b = positions[c[(j + 1) % n]];\n      var t00 = twoProduct(-a[0], a[1]);\n      var t01 = twoProduct(-a[0], b[1]);\n      var t10 = twoProduct(b[0], a[1]);\n      var t11 = twoProduct(b[0], b[1]);\n      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)));\n    }\n\n    return area[area.length - 1] > 0;\n  } //Extract all clockwise faces\n\n\n  faces = faces.filter(ccw); //Detect which loops are contained in one another to handle parent-of relation\n\n  var numFaces = faces.length;\n  var parent = new Array(numFaces);\n  var containment = new Array(numFaces);\n\n  for (var i = 0; i < numFaces; ++i) {\n    parent[i] = i;\n    var row = new Array(numFaces);\n    var loopVertices = faces[i].map(function (v) {\n      return positions[v];\n    });\n    var pmc = preprocessPolygon([loopVertices]);\n    var count = 0;\n\n    outer: for (var j = 0; j < numFaces; ++j) {\n      row[j] = 0;\n\n      if (i === j) {\n        continue;\n      }\n\n      var c = faces[j];\n      var n = c.length;\n\n      for (var k = 0; k < n; ++k) {\n        var d = pmc(positions[c[k]]);\n\n        if (d !== 0) {\n          if (d < 0) {\n            row[j] = 1;\n            count += 1;\n          }\n\n          continue outer;\n        }\n      }\n\n      row[j] = 1;\n      count += 1;\n    }\n\n    containment[i] = [count, i, row];\n  }\n\n  containment.sort(function (a, b) {\n    return b[0] - a[0];\n  });\n\n  for (var i = 0; i < numFaces; ++i) {\n    var row = containment[i];\n    var idx = row[1];\n    var children = row[2];\n\n    for (var j = 0; j < numFaces; ++j) {\n      if (children[j]) {\n        parent[j] = idx;\n      }\n    }\n  } //Initialize face adjacency list\n\n\n  var fadj = makeArrayOfArrays(numFaces);\n\n  for (var i = 0; i < numFaces; ++i) {\n    fadj[i].push(parent[i]);\n    fadj[parent[i]].push(i);\n  } //Build adjacency matrix for edges\n\n\n  var edgeAdjacency = {};\n  var internalVertices = makeArray(numVertices, false);\n\n  for (var i = 0; i < numFaces; ++i) {\n    var c = faces[i];\n    var n = c.length;\n\n    for (var j = 0; j < n; ++j) {\n      var a = c[j];\n      var b = c[(j + 1) % n];\n      var key = Math.min(a, b) + \":\" + Math.max(a, b);\n\n      if (key in edgeAdjacency) {\n        var neighbor = edgeAdjacency[key];\n        fadj[neighbor].push(i);\n        fadj[i].push(neighbor);\n        internalVertices[a] = internalVertices[b] = true;\n      } else {\n        edgeAdjacency[key] = i;\n      }\n    }\n  }\n\n  function sharedBoundary(c) {\n    var n = c.length;\n\n    for (var i = 0; i < n; ++i) {\n      if (!internalVertices[c[i]]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  var toVisit = [];\n  var parity = makeArray(numFaces, -1);\n\n  for (var i = 0; i < numFaces; ++i) {\n    if (parent[i] === i && !sharedBoundary(faces[i])) {\n      toVisit.push(i);\n      parity[i] = 0;\n    } else {\n      parity[i] = -1;\n    }\n  } //Using face adjacency, classify faces as in/out\n\n\n  var result = [];\n\n  while (toVisit.length > 0) {\n    var top = toVisit.pop();\n    var nbhd = fadj[top];\n    uniq(nbhd, function (a, b) {\n      return a - b;\n    });\n    var nnbhr = nbhd.length;\n    var p = parity[top];\n    var polyline;\n\n    if (p === 0) {\n      var c = faces[top];\n      polyline = [c];\n    }\n\n    for (var i = 0; i < nnbhr; ++i) {\n      var f = nbhd[i];\n\n      if (parity[f] >= 0) {\n        continue;\n      }\n\n      parity[f] = p ^ 1;\n      toVisit.push(f);\n\n      if (p === 0) {\n        var c = faces[f];\n\n        if (!sharedBoundary(c)) {\n          c.reverse();\n          polyline.push(c);\n        }\n      }\n    }\n\n    if (p === 0) {\n      result.push(polyline);\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/planar-graph-to-polyline/pg2pl.js"],"names":["module","exports","planarGraphToPolyline","e2a","require","planarDual","preprocessPolygon","twoProduct","robustSum","uniq","trimLeaves","makeArray","length","fill","result","Array","i","makeArrayOfArrays","edges","positions","numVertices","numEdges","adj","Error","faces","ccw","c","n","area","j","a","b","t00","t01","t10","t11","filter","numFaces","parent","containment","row","loopVertices","map","v","pmc","count","outer","k","d","sort","idx","children","fadj","push","edgeAdjacency","internalVertices","key","Math","min","max","neighbor","sharedBoundary","toVisit","parity","top","pop","nbhd","nnbhr","p","polyline","f","reverse"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = planarGraphToPolyline\n\nvar e2a = require('edges-to-adjacency-list')\nvar planarDual = require('planar-dual')\nvar preprocessPolygon = require('point-in-big-polygon')\nvar twoProduct = require('two-product')\nvar robustSum = require('robust-sum')\nvar uniq = require('uniq')\nvar trimLeaves = require('./lib/trim-leaves')\n\nfunction makeArray(length, fill) {\n  var result = new Array(length)\n  for(var i=0; i<length; ++i) {\n    result[i] = fill\n  }\n  return result\n}\n\nfunction makeArrayOfArrays(length) {\n  var result = new Array(length)\n  for(var i=0; i<length; ++i) {\n    result[i] = []\n  }\n  return result\n}\n\n\nfunction planarGraphToPolyline(edges, positions) {\n\n  //Trim leaves\n  var result = trimLeaves(edges, positions)\n  edges = result[0]\n  positions = result[1]\n\n  var numVertices = positions.length\n  var numEdges = edges.length\n\n  //Calculate adjacency list, check manifold\n  var adj = e2a(edges, positions.length)\n  for(var i=0; i<numVertices; ++i) {\n    if(adj[i].length % 2 === 1) {\n      throw new Error('planar-graph-to-polyline: graph must be manifold')\n    }\n  }\n\n  //Get faces\n  var faces = planarDual(edges, positions)\n\n  //Check orientation of a polygon using exact arithmetic\n  function ccw(c) {\n    var n = c.length\n    var area = [0]\n    for(var j=0; j<n; ++j) {\n      var a = positions[c[j]]\n      var b = positions[c[(j+1)%n]]\n      var t00 = twoProduct(-a[0], a[1])\n      var t01 = twoProduct(-a[0], b[1])\n      var t10 = twoProduct( b[0], a[1])\n      var t11 = twoProduct( b[0], b[1])\n      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)))\n    }\n    return area[area.length-1] > 0\n  }\n\n  //Extract all clockwise faces\n  faces = faces.filter(ccw)\n\n  //Detect which loops are contained in one another to handle parent-of relation\n  var numFaces = faces.length\n  var parent = new Array(numFaces)\n  var containment = new Array(numFaces)\n  for(var i=0; i<numFaces; ++i) {\n    parent[i] = i\n    var row = new Array(numFaces)\n    var loopVertices = faces[i].map(function(v) {\n      return positions[v]\n    })\n    var pmc = preprocessPolygon([loopVertices])\n    var count = 0\n    outer:\n    for(var j=0; j<numFaces; ++j) {\n      row[j] = 0\n      if(i === j) {\n        continue\n      }\n      var c = faces[j]\n      var n = c.length\n      for(var k=0; k<n; ++k) {\n        var d = pmc(positions[c[k]])\n        if(d !== 0) {\n          if(d < 0) {\n            row[j] = 1\n            count += 1\n          }\n          continue outer\n        }\n      }\n      row[j] = 1\n      count += 1\n    }\n    containment[i] = [count, i, row]\n  }\n  containment.sort(function(a,b) {\n    return b[0] - a[0]\n  })\n  for(var i=0; i<numFaces; ++i) {\n    var row = containment[i]\n    var idx = row[1]\n    var children = row[2]\n    for(var j=0; j<numFaces; ++j) {\n      if(children[j]) {\n        parent[j] = idx\n      }\n    }\n  }\n\n  //Initialize face adjacency list\n  var fadj = makeArrayOfArrays(numFaces)\n  for(var i=0; i<numFaces; ++i) {\n    fadj[i].push(parent[i])\n    fadj[parent[i]].push(i)\n  }\n\n  //Build adjacency matrix for edges\n  var edgeAdjacency = {}\n  var internalVertices = makeArray(numVertices, false)\n  for(var i=0; i<numFaces; ++i) {\n    var c = faces[i]\n    var n = c.length\n    for(var j=0; j<n; ++j) {\n      var a = c[j]\n      var b = c[(j+1)%n]\n      var key = Math.min(a,b) + \":\" + Math.max(a,b)\n      if(key in edgeAdjacency) {\n        var neighbor = edgeAdjacency[key]\n        fadj[neighbor].push(i)\n        fadj[i].push(neighbor)\n        internalVertices[a] = internalVertices[b] = true\n      } else {\n        edgeAdjacency[key] = i\n      }\n    }\n  }\n\n  function sharedBoundary(c) {\n    var n = c.length\n    for(var i=0; i<n; ++i) {\n      if(!internalVertices[c[i]]) {\n        return false\n      }\n    }\n    return true\n  }\n\n  var toVisit = []\n  var parity = makeArray(numFaces, -1)\n  for(var i=0; i<numFaces; ++i) {\n    if(parent[i] === i && !sharedBoundary(faces[i])) {\n      toVisit.push(i)\n      parity[i] = 0\n    } else {\n      parity[i] = -1\n    }\n  }\n\n  //Using face adjacency, classify faces as in/out\n  var result = []\n  while(toVisit.length > 0) {\n    var top = toVisit.pop()\n    var nbhd = fadj[top]\n    uniq(nbhd, function(a,b) {\n      return a-b\n    })\n    var nnbhr = nbhd.length\n    var p = parity[top]\n    var polyline\n    if(p === 0) {\n      var c = faces[top]\n      polyline = [c]\n    }\n    for(var i=0; i<nnbhr; ++i) {\n      var f = nbhd[i]\n      if(parity[f] >= 0) {\n        continue\n      }\n      parity[f] = p^1\n      toVisit.push(f)\n      if(p === 0) {\n        var c = faces[f]\n        if(!sharedBoundary(c)) {\n          c.reverse()\n          polyline.push(c)\n        }\n      }\n    }\n    if(p === 0) {\n      result.push(polyline)\n    }\n  }\n\n  return result\n}"]},"metadata":{},"sourceType":"script"}