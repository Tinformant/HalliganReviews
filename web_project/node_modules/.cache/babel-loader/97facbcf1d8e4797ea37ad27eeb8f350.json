{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar createScatter = require('regl-scatter2d');\n\nvar createLine = require('regl-line2d');\n\nvar createError = require('regl-error2d');\n\nvar Text = require('gl-text');\n\nvar Lib = require('../../lib');\n\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\n\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar linkTraces = require('../scatter/link_traces');\n\nvar styleTextSelection = require('./edit_style').styleTextSelection;\n\nfunction getViewport(fullLayout, xaxis, yaxis) {\n  var gs = fullLayout._size;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  return [gs.l + xaxis.domain[0] * gs.w, gs.b + yaxis.domain[0] * gs.h, width - gs.r - (1 - xaxis.domain[1]) * gs.w, height - gs.t - (1 - yaxis.domain[1]) * gs.h];\n}\n\nmodule.exports = function plot(gd, subplot, cdata) {\n  if (!cdata.length) return;\n  var fullLayout = gd._fullLayout;\n  var scene = subplot._scene;\n  var xaxis = subplot.xaxis;\n  var yaxis = subplot.yaxis;\n  var i, j; // we may have more subplots than initialized data due to Axes.getSubplots method\n\n  if (!scene) return;\n  var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n\n  if (!success) {\n    scene.init();\n    return;\n  }\n\n  var count = scene.count;\n\n  var regl = fullLayout._glcanvas.data()[0].regl; // that is needed for fills\n\n\n  linkTraces(gd, subplot, cdata);\n\n  if (scene.dirty) {\n    // make sure scenes are created\n    if (scene.error2d === true) {\n      scene.error2d = createError(regl);\n    }\n\n    if (scene.line2d === true) {\n      scene.line2d = createLine(regl);\n    }\n\n    if (scene.scatter2d === true) {\n      scene.scatter2d = createScatter(regl);\n    }\n\n    if (scene.fill2d === true) {\n      scene.fill2d = createLine(regl);\n    }\n\n    if (scene.glText === true) {\n      scene.glText = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i] = new Text(regl);\n      }\n    } // update main marker options\n\n\n    if (scene.glText) {\n      if (count > scene.glText.length) {\n        // add gl text marker\n        var textsToAdd = count - scene.glText.length;\n\n        for (i = 0; i < textsToAdd; i++) {\n          scene.glText.push(new Text(regl));\n        }\n      } else if (count < scene.glText.length) {\n        // remove gl text marker\n        var textsToRemove = scene.glText.length - count;\n        var removedTexts = scene.glText.splice(count, textsToRemove);\n        removedTexts.forEach(function (text) {\n          text.destroy();\n        });\n      }\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i].update(scene.textOptions[i]);\n      }\n    }\n\n    if (scene.line2d) {\n      scene.line2d.update(scene.lineOptions);\n      scene.lineOptions = scene.lineOptions.map(function (lineOptions) {\n        if (lineOptions && lineOptions.positions) {\n          var srcPos = lineOptions.positions;\n          var firstptdef = 0;\n\n          while (firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n            firstptdef += 2;\n          }\n\n          var lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n            lastptdef -= 2;\n          }\n\n          lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n        }\n\n        return lineOptions;\n      });\n      scene.line2d.update(scene.lineOptions);\n    }\n\n    if (scene.error2d) {\n      var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n      scene.error2d.update(errorBatch);\n    }\n\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    } // fill requires linked traces, so we generate it's positions here\n\n\n    scene.fillOrder = Lib.repeat(null, count);\n\n    if (scene.fill2d) {\n      scene.fillOptions = scene.fillOptions.map(function (fillOptions, i) {\n        var cdscatter = cdata[i];\n        if (!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n        var cd = cdscatter[0];\n        var trace = cd.trace;\n        var stash = cd.t;\n        var lineOptions = scene.lineOptions[i];\n        var last, j;\n        var fillData = [];\n        if (trace._ownfill) fillData.push(i);\n        if (trace._nexttrace) fillData.push(i + 1);\n        if (fillData.length) scene.fillOrder[i] = fillData;\n        var pos = [];\n        var srcPos = lineOptions && lineOptions.positions || stash.positions;\n        var firstptdef, lastptdef;\n\n        if (trace.fill === 'tozeroy') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef + 1] !== 0) {\n            pos = [srcPos[firstptdef], 0];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef + 1] !== 0) {\n            pos = pos.concat([srcPos[lastptdef], 0]);\n          }\n        } else if (trace.fill === 'tozerox') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef] !== 0) {\n            pos = [0, srcPos[firstptdef + 1]];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef] !== 0) {\n            pos = pos.concat([0, srcPos[lastptdef + 1]]);\n          }\n        } else if (trace.fill === 'toself' || trace.fill === 'tonext') {\n          pos = [];\n          last = 0;\n\n          for (j = 0; j < srcPos.length; j += 2) {\n            if (isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n              pos = pos.concat(srcPos.slice(last, j));\n              pos.push(srcPos[last], srcPos[last + 1]);\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(srcPos.slice(last));\n\n          if (last) {\n            pos.push(srcPos[last], srcPos[last + 1]);\n          }\n        } else {\n          var nextTrace = trace._nexttrace;\n\n          if (nextTrace) {\n            var nextOptions = scene.lineOptions[i + 1];\n\n            if (nextOptions) {\n              var nextPos = nextOptions.positions;\n\n              if (trace.fill === 'tonexty') {\n                pos = srcPos.slice();\n\n                for (i = Math.floor(nextPos.length / 2); i--;) {\n                  var xx = nextPos[i * 2];\n                  var yy = nextPos[i * 2 + 1];\n                  if (isNaN(xx) || isNaN(yy)) continue;\n                  pos.push(xx, yy);\n                }\n\n                fillOptions.fill = nextTrace.fillcolor;\n              }\n            }\n          }\n        } // detect prev trace positions to exclude from current fill\n\n\n        if (trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n          var prevLinePos = scene.lineOptions[i - 1].positions; // FIXME: likely this logic should be tested better\n\n          var offset = pos.length / 2;\n          last = offset;\n          var hole = [last];\n\n          for (j = 0; j < prevLinePos.length; j += 2) {\n            if (isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n              hole.push(j / 2 + offset + 1);\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(prevLinePos);\n          fillOptions.hole = hole;\n        }\n\n        fillOptions.fillmode = trace.fill;\n        fillOptions.opacity = trace.opacity;\n        fillOptions.positions = pos;\n        return fillOptions;\n      });\n      scene.fill2d.update(scene.fillOptions);\n    }\n  } // form batch arrays, and check for selected points\n\n\n  var dragmode = fullLayout.dragmode;\n  var isSelectMode = selectMode(dragmode);\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n  for (i = 0; i < count; i++) {\n    var cd0 = cdata[i][0];\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var index = stash.index;\n    var len = trace._length;\n    var x = stash.x;\n    var y = stash.y;\n\n    if (trace.selectedpoints || isSelectMode || clickSelectEnabled) {\n      if (!isSelectMode) isSelectMode = true; // regenerate scene batch, if traces number changed during selection\n\n      if (trace.selectedpoints) {\n        var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n        var selDict = {};\n\n        for (j = 0; j < selPts.length; j++) {\n          selDict[selPts[j]] = 1;\n        }\n\n        var unselPts = [];\n\n        for (j = 0; j < len; j++) {\n          if (!selDict[j]) unselPts.push(j);\n        }\n\n        scene.unselectBatch[index] = unselPts;\n      } // precalculate px coords since we are not going to pan during select\n      // TODO, could do better here e.g.\n      // - spin that in a webworker\n      // - compute selection from polygons in data coordinates\n      //   (maybe just for linear axes)\n\n\n      var xpx = stash.xpx = new Array(len);\n      var ypx = stash.ypx = new Array(len);\n\n      for (j = 0; j < len; j++) {\n        xpx[j] = xaxis.c2p(x[j]);\n        ypx[j] = yaxis.c2p(y[j]);\n      }\n    } else {\n      stash.xpx = stash.ypx = null;\n    }\n  }\n\n  if (isSelectMode) {\n    // create scatter instance by cloning scatter2d\n    if (!scene.select2d) {\n      scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n    } // use unselected styles on 'context' canvas\n\n\n    if (scene.scatter2d) {\n      var unselOpts = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ? scene.markerUnselectedOptions[i] : {};\n      }\n\n      scene.scatter2d.update(unselOpts);\n    } // use selected style on 'focus' canvas\n\n\n    if (scene.select2d) {\n      scene.select2d.update(scene.markerOptions);\n      scene.select2d.update(scene.markerSelectedOptions);\n    }\n\n    if (scene.glText) {\n      cdata.forEach(function (cdscatter) {\n        var trace = ((cdscatter || [])[0] || {}).trace || {};\n\n        if (subTypes.hasText(trace)) {\n          styleTextSelection(cdscatter);\n        }\n      });\n    }\n  } else {\n    // reset 'context' scatter2d opts to base opts,\n    // thus unsetting markerUnselectedOptions from selection\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    }\n  } // provide viewport and range\n\n\n  var vpRange0 = {\n    viewport: getViewport(fullLayout, xaxis, yaxis),\n    // TODO do we need those fallbacks?\n    range: [(xaxis._rl || xaxis.range)[0], (yaxis._rl || yaxis.range)[0], (xaxis._rl || xaxis.range)[1], (yaxis._rl || yaxis.range)[1]]\n  };\n  var vpRange = Lib.repeat(vpRange0, scene.count); // upload viewport/range data to GPU\n\n  if (scene.fill2d) {\n    scene.fill2d.update(vpRange);\n  }\n\n  if (scene.line2d) {\n    scene.line2d.update(vpRange);\n  }\n\n  if (scene.error2d) {\n    scene.error2d.update(vpRange.concat(vpRange));\n  }\n\n  if (scene.scatter2d) {\n    scene.scatter2d.update(vpRange);\n  }\n\n  if (scene.select2d) {\n    scene.select2d.update(vpRange);\n  }\n\n  if (scene.glText) {\n    scene.glText.forEach(function (text) {\n      text.update(vpRange0);\n    });\n  }\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/scattergl/plot.js"],"names":["createScatter","require","createLine","createError","Text","Lib","selectMode","prepareRegl","subTypes","linkTraces","styleTextSelection","getViewport","fullLayout","xaxis","yaxis","gs","_size","width","height","l","domain","w","b","h","r","t","module","exports","plot","gd","subplot","cdata","length","_fullLayout","scene","_scene","i","j","success","init","count","regl","_glcanvas","data","dirty","error2d","line2d","scatter2d","fill2d","glText","Array","textsToAdd","push","textsToRemove","removedTexts","splice","forEach","text","destroy","update","textOptions","lineOptions","map","positions","srcPos","firstptdef","isNaN","lastptdef","slice","errorBatch","errorXOptions","concat","errorYOptions","markerOptions","fillOrder","repeat","fillOptions","cdscatter","trace","cd","stash","last","fillData","_ownfill","_nexttrace","pos","fill","nextTrace","nextOptions","nextPos","Math","floor","xx","yy","fillcolor","_prevtrace","prevLinePos","offset","hole","fillmode","opacity","dragmode","isSelectMode","clickSelectEnabled","clickmode","indexOf","cd0","index","len","_length","x","y","selectedpoints","selPts","selectBatch","selIndices2selPoints","selDict","unselPts","unselectBatch","xpx","ypx","c2p","select2d","unselOpts","markerUnselectedOptions","markerSelectedOptions","hasText","vpRange0","viewport","range","_rl","vpRange"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createScatter = require('regl-scatter2d');\nvar createLine = require('regl-line2d');\nvar createError = require('regl-error2d');\nvar Text = require('gl-text');\n\nvar Lib = require('../../lib');\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar subTypes = require('../scatter/subtypes');\nvar linkTraces = require('../scatter/link_traces');\n\nvar styleTextSelection = require('./edit_style').styleTextSelection;\n\nfunction getViewport(fullLayout, xaxis, yaxis) {\n    var gs = fullLayout._size;\n    var width = fullLayout.width;\n    var height = fullLayout.height;\n    return [\n        gs.l + xaxis.domain[0] * gs.w,\n        gs.b + yaxis.domain[0] * gs.h,\n        (width - gs.r) - (1 - xaxis.domain[1]) * gs.w,\n        (height - gs.t) - (1 - yaxis.domain[1]) * gs.h\n    ];\n}\n\nmodule.exports = function plot(gd, subplot, cdata) {\n    if(!cdata.length) return;\n\n    var fullLayout = gd._fullLayout;\n    var scene = subplot._scene;\n    var xaxis = subplot.xaxis;\n    var yaxis = subplot.yaxis;\n    var i, j;\n\n    // we may have more subplots than initialized data due to Axes.getSubplots method\n    if(!scene) return;\n\n    var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n    if(!success) {\n        scene.init();\n        return;\n    }\n\n    var count = scene.count;\n    var regl = fullLayout._glcanvas.data()[0].regl;\n\n    // that is needed for fills\n    linkTraces(gd, subplot, cdata);\n\n    if(scene.dirty) {\n        // make sure scenes are created\n        if(scene.error2d === true) {\n            scene.error2d = createError(regl);\n        }\n        if(scene.line2d === true) {\n            scene.line2d = createLine(regl);\n        }\n        if(scene.scatter2d === true) {\n            scene.scatter2d = createScatter(regl);\n        }\n        if(scene.fill2d === true) {\n            scene.fill2d = createLine(regl);\n        }\n        if(scene.glText === true) {\n            scene.glText = new Array(count);\n            for(i = 0; i < count; i++) {\n                scene.glText[i] = new Text(regl);\n            }\n        }\n\n        // update main marker options\n        if(scene.glText) {\n            if(count > scene.glText.length) {\n                // add gl text marker\n                var textsToAdd = count - scene.glText.length;\n                for(i = 0; i < textsToAdd; i++) {\n                    scene.glText.push(new Text(regl));\n                }\n            } else if(count < scene.glText.length) {\n                // remove gl text marker\n                var textsToRemove = scene.glText.length - count;\n                var removedTexts = scene.glText.splice(count, textsToRemove);\n                removedTexts.forEach(function(text) { text.destroy(); });\n            }\n\n            for(i = 0; i < count; i++) {\n                scene.glText[i].update(scene.textOptions[i]);\n            }\n        }\n        if(scene.line2d) {\n            scene.line2d.update(scene.lineOptions);\n            scene.lineOptions = scene.lineOptions.map(function(lineOptions) {\n                if(lineOptions && lineOptions.positions) {\n                    var srcPos = lineOptions.positions;\n\n                    var firstptdef = 0;\n                    while(firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n                        firstptdef += 2;\n                    }\n                    var lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n                        lastptdef -= 2;\n                    }\n                    lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n                }\n                return lineOptions;\n            });\n            scene.line2d.update(scene.lineOptions);\n        }\n        if(scene.error2d) {\n            var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n            scene.error2d.update(errorBatch);\n        }\n        if(scene.scatter2d) {\n            scene.scatter2d.update(scene.markerOptions);\n        }\n\n        // fill requires linked traces, so we generate it's positions here\n        scene.fillOrder = Lib.repeat(null, count);\n        if(scene.fill2d) {\n            scene.fillOptions = scene.fillOptions.map(function(fillOptions, i) {\n                var cdscatter = cdata[i];\n                if(!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n                var cd = cdscatter[0];\n                var trace = cd.trace;\n                var stash = cd.t;\n                var lineOptions = scene.lineOptions[i];\n                var last, j;\n\n                var fillData = [];\n                if(trace._ownfill) fillData.push(i);\n                if(trace._nexttrace) fillData.push(i + 1);\n                if(fillData.length) scene.fillOrder[i] = fillData;\n\n                var pos = [];\n                var srcPos = (lineOptions && lineOptions.positions) || stash.positions;\n                var firstptdef, lastptdef;\n\n                if(trace.fill === 'tozeroy') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef + 1] !== 0) {\n                        pos = [srcPos[firstptdef], 0];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef + 1] !== 0) {\n                        pos = pos.concat([srcPos[lastptdef], 0]);\n                    }\n                } else if(trace.fill === 'tozerox') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef] !== 0) {\n                        pos = [0, srcPos[firstptdef + 1]];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef] !== 0) {\n                        pos = pos.concat([ 0, srcPos[lastptdef + 1]]);\n                    }\n                } else if(trace.fill === 'toself' || trace.fill === 'tonext') {\n                    pos = [];\n                    last = 0;\n                    for(j = 0; j < srcPos.length; j += 2) {\n                        if(isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n                            pos = pos.concat(srcPos.slice(last, j));\n                            pos.push(srcPos[last], srcPos[last + 1]);\n                            last = j + 2;\n                        }\n                    }\n                    pos = pos.concat(srcPos.slice(last));\n                    if(last) {\n                        pos.push(srcPos[last], srcPos[last + 1]);\n                    }\n                } else {\n                    var nextTrace = trace._nexttrace;\n\n                    if(nextTrace) {\n                        var nextOptions = scene.lineOptions[i + 1];\n\n                        if(nextOptions) {\n                            var nextPos = nextOptions.positions;\n                            if(trace.fill === 'tonexty') {\n                                pos = srcPos.slice();\n\n                                for(i = Math.floor(nextPos.length / 2); i--;) {\n                                    var xx = nextPos[i * 2];\n                                    var yy = nextPos[i * 2 + 1];\n                                    if(isNaN(xx) || isNaN(yy)) continue;\n                                    pos.push(xx, yy);\n                                }\n                                fillOptions.fill = nextTrace.fillcolor;\n                            }\n                        }\n                    }\n                }\n\n                // detect prev trace positions to exclude from current fill\n                if(trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n                    var prevLinePos = scene.lineOptions[i - 1].positions;\n\n                    // FIXME: likely this logic should be tested better\n                    var offset = pos.length / 2;\n                    last = offset;\n                    var hole = [last];\n                    for(j = 0; j < prevLinePos.length; j += 2) {\n                        if(isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n                            hole.push(j / 2 + offset + 1);\n                            last = j + 2;\n                        }\n                    }\n\n                    pos = pos.concat(prevLinePos);\n                    fillOptions.hole = hole;\n                }\n                fillOptions.fillmode = trace.fill;\n                fillOptions.opacity = trace.opacity;\n                fillOptions.positions = pos;\n\n                return fillOptions;\n            });\n\n            scene.fill2d.update(scene.fillOptions);\n        }\n    }\n\n    // form batch arrays, and check for selected points\n    var dragmode = fullLayout.dragmode;\n    var isSelectMode = selectMode(dragmode);\n    var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n    for(i = 0; i < count; i++) {\n        var cd0 = cdata[i][0];\n        var trace = cd0.trace;\n        var stash = cd0.t;\n        var index = stash.index;\n        var len = trace._length;\n        var x = stash.x;\n        var y = stash.y;\n\n        if(trace.selectedpoints || isSelectMode || clickSelectEnabled) {\n            if(!isSelectMode) isSelectMode = true;\n\n            // regenerate scene batch, if traces number changed during selection\n            if(trace.selectedpoints) {\n                var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n\n                var selDict = {};\n                for(j = 0; j < selPts.length; j++) {\n                    selDict[selPts[j]] = 1;\n                }\n                var unselPts = [];\n                for(j = 0; j < len; j++) {\n                    if(!selDict[j]) unselPts.push(j);\n                }\n                scene.unselectBatch[index] = unselPts;\n            }\n\n            // precalculate px coords since we are not going to pan during select\n            // TODO, could do better here e.g.\n            // - spin that in a webworker\n            // - compute selection from polygons in data coordinates\n            //   (maybe just for linear axes)\n            var xpx = stash.xpx = new Array(len);\n            var ypx = stash.ypx = new Array(len);\n            for(j = 0; j < len; j++) {\n                xpx[j] = xaxis.c2p(x[j]);\n                ypx[j] = yaxis.c2p(y[j]);\n            }\n        } else {\n            stash.xpx = stash.ypx = null;\n        }\n    }\n\n    if(isSelectMode) {\n        // create scatter instance by cloning scatter2d\n        if(!scene.select2d) {\n            scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n        }\n\n        // use unselected styles on 'context' canvas\n        if(scene.scatter2d) {\n            var unselOpts = new Array(count);\n            for(i = 0; i < count; i++) {\n                unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ?\n                    scene.markerUnselectedOptions[i] :\n                    {};\n            }\n            scene.scatter2d.update(unselOpts);\n        }\n\n        // use selected style on 'focus' canvas\n        if(scene.select2d) {\n            scene.select2d.update(scene.markerOptions);\n            scene.select2d.update(scene.markerSelectedOptions);\n        }\n\n        if(scene.glText) {\n            cdata.forEach(function(cdscatter) {\n                var trace = ((cdscatter || [])[0] || {}).trace || {};\n                if(subTypes.hasText(trace)) {\n                    styleTextSelection(cdscatter);\n                }\n            });\n        }\n    } else {\n        // reset 'context' scatter2d opts to base opts,\n        // thus unsetting markerUnselectedOptions from selection\n        if(scene.scatter2d) {\n            scene.scatter2d.update(scene.markerOptions);\n        }\n    }\n\n    // provide viewport and range\n    var vpRange0 = {\n        viewport: getViewport(fullLayout, xaxis, yaxis),\n        // TODO do we need those fallbacks?\n        range: [\n            (xaxis._rl || xaxis.range)[0],\n            (yaxis._rl || yaxis.range)[0],\n            (xaxis._rl || xaxis.range)[1],\n            (yaxis._rl || yaxis.range)[1]\n        ]\n    };\n    var vpRange = Lib.repeat(vpRange0, scene.count);\n\n    // upload viewport/range data to GPU\n    if(scene.fill2d) {\n        scene.fill2d.update(vpRange);\n    }\n    if(scene.line2d) {\n        scene.line2d.update(vpRange);\n    }\n    if(scene.error2d) {\n        scene.error2d.update(vpRange.concat(vpRange));\n    }\n    if(scene.scatter2d) {\n        scene.scatter2d.update(vpRange);\n    }\n    if(scene.select2d) {\n        scene.select2d.update(vpRange);\n    }\n    if(scene.glText) {\n        scene.glText.forEach(function(text) { text.update(vpRange0); });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}