{"ast":null,"code":"var tarjan = require('strongly-connected-components');\n\nmodule.exports = function findCircuits(edges, cb) {\n  var circuits = []; // Output\n\n  var stack = [];\n  var blocked = [];\n  var B = {};\n  var Ak = [];\n  var s;\n\n  function unblock(u) {\n    blocked[u] = false;\n\n    if (B.hasOwnProperty(u)) {\n      Object.keys(B[u]).forEach(function (w) {\n        delete B[u][w];\n\n        if (blocked[w]) {\n          unblock(w);\n        }\n      });\n    }\n  }\n\n  function circuit(v) {\n    var found = false;\n    stack.push(v);\n    blocked[v] = true; // L1\n\n    var i;\n    var w;\n\n    for (i = 0; i < Ak[v].length; i++) {\n      w = Ak[v][i];\n\n      if (w === s) {\n        output(s, stack);\n        found = true;\n      } else if (!blocked[w]) {\n        found = circuit(w);\n      }\n    } // L2\n\n\n    if (found) {\n      unblock(v);\n    } else {\n      for (i = 0; i < Ak[v].length; i++) {\n        w = Ak[v][i];\n        var entry = B[w];\n\n        if (!entry) {\n          entry = {};\n          B[w] = entry;\n        }\n\n        entry[w] = true;\n      }\n    }\n\n    stack.pop();\n    return found;\n  }\n\n  function output(start, stack) {\n    var cycle = [].concat(stack).concat(start);\n\n    if (cb) {\n      cb(circuit);\n    } else {\n      circuits.push(cycle);\n    }\n  }\n\n  function subgraph(minId) {\n    // Remove edges with indice smaller than minId\n    for (var i = 0; i < edges.length; i++) {\n      if (i < minId) edges[i] = [];\n      edges[i] = edges[i].filter(function (i) {\n        return i >= minId;\n      });\n    }\n  }\n\n  function adjacencyStructureSCC(from) {\n    // Make subgraph starting from vertex minId\n    subgraph(from);\n    var g = edges; // Find strongly connected components using Tarjan algorithm\n\n    var sccs = tarjan(g); // Filter out trivial connected components (ie. made of one node)\n\n    var ccs = sccs.components.filter(function (scc) {\n      return scc.length > 1;\n    }); // Find least vertex\n\n    var leastVertex = Infinity;\n    var leastVertexComponent;\n\n    for (var i = 0; i < ccs.length; i++) {\n      for (var j = 0; j < ccs[i].length; j++) {\n        if (ccs[i][j] < leastVertex) {\n          leastVertex = ccs[i][j];\n          leastVertexComponent = i;\n        }\n      }\n    }\n\n    var cc = ccs[leastVertexComponent];\n    if (!cc) return false; // Return the adjacency list of first component\n\n    var adjList = edges.map(function (l, index) {\n      if (cc.indexOf(index) === -1) return [];\n      return l.filter(function (i) {\n        return cc.indexOf(i) !== -1;\n      });\n    });\n    return {\n      leastVertex: leastVertex,\n      adjList: adjList\n    };\n  }\n\n  s = 0;\n  var n = edges.length;\n\n  while (s < n) {\n    // find strong component with least vertex in\n    // subgraph starting from vertex `s`\n    var p = adjacencyStructureSCC(s); // Its least vertex\n\n    s = p.leastVertex; // Its adjacency list\n\n    Ak = p.adjList;\n\n    if (Ak) {\n      for (var i = 0; i < Ak.length; i++) {\n        for (var j = 0; j < Ak[i].length; j++) {\n          var vertexId = Ak[i][j];\n          blocked[+vertexId] = false;\n          B[vertexId] = {};\n        }\n      }\n\n      circuit(s);\n      s = s + 1;\n    } else {\n      s = n;\n    }\n  }\n\n  if (cb) {\n    return;\n  } else {\n    return circuits;\n  }\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/elementary-circuits-directed-graph/johnson.js"],"names":["tarjan","require","module","exports","findCircuits","edges","cb","circuits","stack","blocked","B","Ak","s","unblock","u","hasOwnProperty","Object","keys","forEach","w","circuit","v","found","push","i","length","output","entry","pop","start","cycle","concat","subgraph","minId","filter","adjacencyStructureSCC","from","g","sccs","ccs","components","scc","leastVertex","Infinity","leastVertexComponent","j","cc","adjList","map","l","index","indexOf","n","p","vertexId"],"mappings":"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","sourcesContent":["var tarjan = require('strongly-connected-components');\n\nmodule.exports = function findCircuits(edges, cb) {\n    var circuits = []; // Output\n\n    var stack = [];\n    var blocked = [];\n    var B = {};\n    var Ak = [];\n    var s;\n\n    function unblock(u) {\n        blocked[u] = false;\n        if(B.hasOwnProperty(u)) {\n            Object.keys(B[u]).forEach(function(w) {\n                delete B[u][w];\n                if(blocked[w]) {unblock(w);}\n            });\n        }\n    }\n\n    function circuit(v) {\n        var found = false;\n\n        stack.push(v);\n        blocked[v] = true;\n\n        // L1\n        var i;\n        var w;\n        for(i = 0; i < Ak[v].length; i++) {\n            w = Ak[v][i];\n            if(w === s) {\n                output(s, stack);\n                found = true;\n            } else if(!blocked[w]) {\n                found = circuit(w);\n            }\n        }\n\n        // L2\n        if(found) {\n            unblock(v);\n        } else {\n            for(i = 0; i < Ak[v].length; i++) {\n                w = Ak[v][i];\n                var entry = B[w];\n\n                if(!entry) {\n                    entry = {};\n                    B[w] = entry;\n                }\n\n                entry[w] = true;\n            }\n        }\n        stack.pop();\n        return found;\n    }\n\n    function output(start, stack) {\n        var cycle = [].concat(stack).concat(start);\n        if(cb) {\n            cb(circuit);\n        } else {\n            circuits.push(cycle);\n        }\n    }\n\n    function subgraph(minId) {\n      // Remove edges with indice smaller than minId\n        for(var i = 0; i < edges.length; i++) {\n            if(i < minId) edges[i] = [];\n            edges[i] = edges[i].filter(function(i) {\n                return i >= minId;\n            });\n        }\n    }\n\n    function adjacencyStructureSCC(from) {\n        // Make subgraph starting from vertex minId\n        subgraph(from);\n        var g = edges;\n\n        // Find strongly connected components using Tarjan algorithm\n        var sccs = tarjan(g);\n\n        // Filter out trivial connected components (ie. made of one node)\n        var ccs = sccs.components.filter(function(scc) {\n            return scc.length > 1;\n        });\n\n        // Find least vertex\n        var leastVertex = Infinity;\n        var leastVertexComponent;\n        for(var i = 0; i < ccs.length; i++) {\n            for(var j = 0; j < ccs[i].length; j++) {\n                if(ccs[i][j] < leastVertex) {\n                    leastVertex = ccs[i][j];\n                    leastVertexComponent = i;\n                }\n            }\n        }\n\n        var cc = ccs[leastVertexComponent];\n\n        if(!cc) return false;\n\n        // Return the adjacency list of first component\n        var adjList = edges.map(function(l, index) {\n            if(cc.indexOf(index) === -1) return [];\n            return l.filter(function(i) {\n                return cc.indexOf(i) !== -1;\n            });\n        });\n\n        return {\n            leastVertex: leastVertex,\n            adjList: adjList\n        };\n    }\n\n    s = 0;\n    var n = edges.length;\n    while(s < n) {\n        // find strong component with least vertex in\n        // subgraph starting from vertex `s`\n        var p = adjacencyStructureSCC(s);\n\n        // Its least vertex\n        s = p.leastVertex;\n        // Its adjacency list\n        Ak = p.adjList;\n\n        if(Ak) {\n            for(var i = 0; i < Ak.length; i++) {\n                for(var j = 0; j < Ak[i].length; j++) {\n                    var vertexId = Ak[i][j];\n                    blocked[+vertexId] = false;\n                    B[vertexId] = {};\n                }\n            }\n            circuit(s);\n            s = s + 1;\n        } else {\n            s = n;\n        }\n\n    }\n\n    if(cb) {\n        return;\n    } else {\n        return circuits;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}