{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing'); // constants for dynamic jitter (ie less jitter for sparser points)\n\n\nvar JITTERCOUNT = 5; // points either side of this to include\n\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(boxLayer, cdbox, 'trace boxes').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace; // whisker width\n\n    t.wdPos = t.bdPos * trace.whiskerwidth;\n\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n\n    var posAxis, valAxis;\n\n    if (trace.orientation === 'h') {\n      posAxis = ya;\n      valAxis = xa;\n    } else {\n      posAxis = xa;\n      valAxis = ya;\n    }\n\n    plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t);\n    plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n    plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t);\n  });\n}\n\nfunction plotBoxAndWhiskers(sel, axes, trace, t) {\n  var isHorizontal = trace.orientation === 'h';\n  var valAxis = axes.val;\n  var posAxis = axes.pos;\n  var posHasRangeBreaks = !!posAxis.rangebreaks;\n  var bPos = t.bPos;\n  var wdPos = t.wdPos || 0;\n  var bPosPxOffset = t.bPosPxOffset || 0;\n  var whiskerWidth = trace.whiskerwidth || 0;\n  var notched = trace.notched || false;\n  var nw = notched ? 1 - 2 * trace.notchwidth : 1; // to support for one-sided box\n\n  var bdPos0;\n  var bdPos1;\n\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n\n  var paths = sel.selectAll('path.box').data(trace.type !== 'violin' || trace.box.visible ? Lib.identity : []);\n  paths.enter().append('path').style('vector-effect', 'non-scaling-stroke').attr('class', 'box');\n  paths.exit().remove();\n  paths.each(function (d) {\n    if (d.empty) return 'M0,0Z';\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n    var r = trace.whiskerwidth;\n    var posw0 = posHasRangeBreaks ? pos0 * r + (1 - r) * posc : posAxis.l2p(lcenter - wdPos) + bPosPxOffset;\n    var posw1 = posHasRangeBreaks ? pos1 * r + (1 - r) * posc : posAxis.l2p(lcenter + wdPos) + bPosPxOffset;\n    var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;\n    var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;\n    var q1 = valAxis.c2p(d.q1, true);\n    var q3 = valAxis.c2p(d.q3, true); // make sure median isn't identical to either of the\n    // quartiles, so we can see it\n\n    var m = Lib.constrain(valAxis.c2p(d.med, true), Math.min(q1, q3) + 1, Math.max(q1, q3) - 1); // for compatibility with box, violin, and candlestick\n    // perhaps we should put this into cd0.t instead so it's more explicit,\n    // but what we have now is:\n    // - box always has d.lf, but boxpoints can be anything\n    // - violin has d.lf and should always use it (boxpoints is undefined)\n    // - candlestick has only min/max\n\n    var useExtremes = d.lf === undefined || trace.boxpoints === false;\n    var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n    var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n    var ln = valAxis.c2p(d.ln, true);\n    var un = valAxis.c2p(d.un, true);\n\n    if (isHorizontal) {\n      d3.select(this).attr('d', 'M' + m + ',' + posm0 + 'V' + posm1 + // median line\n      'M' + q1 + ',' + pos0 + 'V' + pos1 + ( // left edge\n      notched ? 'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 : '') + // top notched edge\n      'H' + q3 + // end of the top edge\n      'V' + pos0 + ( // right edge\n      notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') + // bottom notched edge\n      'Z' + // end of the box\n      'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + ( // whiskers\n      whiskerWidth === 0 ? '' : // whisker caps\n      'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1));\n    } else {\n      d3.select(this).attr('d', 'M' + posm0 + ',' + m + 'H' + posm1 + // median line\n      'M' + pos0 + ',' + q1 + 'H' + pos1 + ( // top of the box\n      notched ? 'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un : '') + // notched right edge\n      'V' + q3 + // end of the right edge\n      'H' + pos0 + ( // bottom of the box\n      notched ? 'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln : '') + // notched left edge\n      'Z' + // end of the box\n      'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + ( // whiskers\n      whiskerWidth === 0 ? '' : // whisker caps\n      'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1));\n    }\n  });\n}\n\nfunction plotPoints(sel, axes, trace, t) {\n  var xa = axes.x;\n  var ya = axes.y;\n  var bdPos = t.bdPos;\n  var bPos = t.bPos; // to support violin points\n\n  var mode = trace.boxpoints || trace.points; // repeatable pseudo-random number generator\n\n  Lib.seedPseudoRandom(); // since box plot points get an extra level of nesting, each\n  // box needs the trace styling info\n\n  var fn = function (d) {\n    d.forEach(function (v) {\n      v.t = t;\n      v.trace = trace;\n    });\n    return d;\n  };\n\n  var gPoints = sel.selectAll('g.points').data(mode ? fn : []);\n  gPoints.enter().append('g').attr('class', 'points');\n  gPoints.exit().remove();\n  var paths = gPoints.selectAll('path').data(function (d) {\n    var i;\n    var pts = d.pts2; // normally use IQR, but if this is 0 or too small, use max-min\n\n    var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n    var minSpread = typicalSpread * 1e-9;\n    var spreadLimit = typicalSpread * JITTERSPREAD;\n    var jitterFactors = [];\n    var maxJitterFactor = 0;\n    var newJitter; // dynamic jitter\n\n    if (trace.jitter) {\n      if (typicalSpread === 0) {\n        // edge case of no spread at all: fall back to max jitter\n        maxJitterFactor = 1;\n        jitterFactors = new Array(pts.length);\n\n        for (i = 0; i < pts.length; i++) {\n          jitterFactors[i] = 1;\n        }\n      } else {\n        for (i = 0; i < pts.length; i++) {\n          var i0 = Math.max(0, i - JITTERCOUNT);\n          var pmin = pts[i0].v;\n          var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n          var pmax = pts[i1].v;\n\n          if (mode !== 'all') {\n            if (pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);else pmin = Math.max(pmin, d.uf);\n          }\n\n          var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n          jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n          jitterFactors.push(jitterFactor);\n          maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n        }\n      }\n\n      newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n    } // fills in 'x' and 'y' in calcdata 'pts' item\n\n\n    for (i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var v = pt.v;\n      var jitterOffset = trace.jitter ? newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5) : 0;\n      var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n\n      if (trace.orientation === 'h') {\n        pt.y = posPx;\n        pt.x = v;\n      } else {\n        pt.x = posPx;\n        pt.y = v;\n      } // tag suspected outliers\n\n\n      if (mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n        pt.so = true;\n      }\n    }\n\n    return pts;\n  });\n  paths.enter().append('path').classed('point', true);\n  paths.exit().remove();\n  paths.call(Drawing.translatePoints, xa, ya);\n}\n\nfunction plotBoxMean(sel, axes, trace, t) {\n  var valAxis = axes.val;\n  var posAxis = axes.pos;\n  var posHasRangeBreaks = !!posAxis.rangebreaks;\n  var bPos = t.bPos;\n  var bPosPxOffset = t.bPosPxOffset || 0; // to support violin mean lines\n\n  var mode = trace.boxmean || (trace.meanline || {}).visible; // to support for one-sided box\n\n  var bdPos0;\n  var bdPos1;\n\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n\n  var paths = sel.selectAll('path.mean').data(trace.type === 'box' && trace.boxmean || trace.type === 'violin' && trace.box.visible && trace.meanline.visible ? Lib.identity : []);\n  paths.enter().append('path').attr('class', 'mean').style({\n    fill: 'none',\n    'vector-effect': 'non-scaling-stroke'\n  });\n  paths.exit().remove();\n  paths.each(function (d) {\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n    var m = valAxis.c2p(d.mean, true);\n    var sl = valAxis.c2p(d.mean - d.sd, true);\n    var sh = valAxis.c2p(d.mean + d.sd, true);\n\n    if (trace.orientation === 'h') {\n      d3.select(this).attr('d', 'M' + m + ',' + pos0 + 'V' + pos1 + (mode === 'sd' ? 'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' : ''));\n    } else {\n      d3.select(this).attr('d', 'M' + pos0 + ',' + m + 'H' + pos1 + (mode === 'sd' ? 'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' : ''));\n    }\n  });\n}\n\nmodule.exports = {\n  plot: plot,\n  plotBoxAndWhiskers: plotBoxAndWhiskers,\n  plotPoints: plotPoints,\n  plotBoxMean: plotBoxMean\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/box/plot.js"],"names":["d3","require","Lib","Drawing","JITTERCOUNT","JITTERSPREAD","plot","gd","plotinfo","cdbox","boxLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","plotGroup","select","cd0","t","trace","wdPos","bdPos","whiskerwidth","visible","empty","remove","posAxis","valAxis","orientation","plotBoxAndWhiskers","pos","val","plotPoints","x","y","plotBoxMean","sel","axes","isHorizontal","posHasRangeBreaks","rangebreaks","bPos","bPosPxOffset","whiskerWidth","notched","nw","notchwidth","bdPos0","bdPos1","Array","isArray","paths","selectAll","data","type","box","identity","enter","append","style","attr","exit","d","lcenter","c2l","pos0","l2p","pos1","posc","r","posw0","posw1","posm0","posm1","q1","c2p","q3","m","constrain","med","Math","min","max","useExtremes","lf","undefined","boxpoints","uf","ln","un","mode","points","seedPseudoRandom","fn","forEach","v","gPoints","i","pts","pts2","typicalSpread","minSpread","spreadLimit","jitterFactors","maxJitterFactor","newJitter","jitter","length","i0","pmin","i1","pmax","jitterFactor","sqrt","abs","push","pt","jitterOffset","pseudoRandom","posPx","pointpos","uo","lo","so","classed","call","translatePoints","boxmean","meanline","fill","mean","sl","sd","sh","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\n// constants for dynamic jitter (ie less jitter for sparser points)\nvar JITTERCOUNT = 5; // points either side of this to include\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(boxLayer, cdbox, 'trace boxes').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n\n        // whisker width\n        t.wdPos = t.bdPos * trace.whiskerwidth;\n\n        if(trace.visible !== true || t.empty) {\n            plotGroup.remove();\n            return;\n        }\n\n        var posAxis, valAxis;\n\n        if(trace.orientation === 'h') {\n            posAxis = ya;\n            valAxis = xa;\n        } else {\n            posAxis = xa;\n            valAxis = ya;\n        }\n\n        plotBoxAndWhiskers(plotGroup, {pos: posAxis, val: valAxis}, trace, t);\n        plotPoints(plotGroup, {x: xa, y: ya}, trace, t);\n        plotBoxMean(plotGroup, {pos: posAxis, val: valAxis}, trace, t);\n    });\n}\n\nfunction plotBoxAndWhiskers(sel, axes, trace, t) {\n    var isHorizontal = trace.orientation === 'h';\n    var valAxis = axes.val;\n    var posAxis = axes.pos;\n    var posHasRangeBreaks = !!posAxis.rangebreaks;\n\n    var bPos = t.bPos;\n    var wdPos = t.wdPos || 0;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n    var whiskerWidth = trace.whiskerwidth || 0;\n    var notched = trace.notched || false;\n    var nw = notched ? 1 - 2 * trace.notchwidth : 1;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.box').data((\n        trace.type !== 'violin' ||\n        trace.box.visible\n    ) ? Lib.identity : []);\n\n    paths.enter().append('path')\n        .style('vector-effect', 'non-scaling-stroke')\n        .attr('class', 'box');\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        if(d.empty) return 'M0,0Z';\n\n        var lcenter = posAxis.c2l(d.pos + bPos, true);\n\n        var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n        var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n        var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n\n        var r = trace.whiskerwidth;\n        var posw0 = posHasRangeBreaks ? pos0 * r + (1 - r) * posc : posAxis.l2p(lcenter - wdPos) + bPosPxOffset;\n        var posw1 = posHasRangeBreaks ? pos1 * r + (1 - r) * posc : posAxis.l2p(lcenter + wdPos) + bPosPxOffset;\n\n        var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;\n        var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;\n        var q1 = valAxis.c2p(d.q1, true);\n        var q3 = valAxis.c2p(d.q3, true);\n        // make sure median isn't identical to either of the\n        // quartiles, so we can see it\n        var m = Lib.constrain(\n            valAxis.c2p(d.med, true),\n            Math.min(q1, q3) + 1, Math.max(q1, q3) - 1\n        );\n\n        // for compatibility with box, violin, and candlestick\n        // perhaps we should put this into cd0.t instead so it's more explicit,\n        // but what we have now is:\n        // - box always has d.lf, but boxpoints can be anything\n        // - violin has d.lf and should always use it (boxpoints is undefined)\n        // - candlestick has only min/max\n        var useExtremes = (d.lf === undefined) || (trace.boxpoints === false);\n        var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n        var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n        var ln = valAxis.c2p(d.ln, true);\n        var un = valAxis.c2p(d.un, true);\n\n        if(isHorizontal) {\n            d3.select(this).attr('d',\n                'M' + m + ',' + posm0 + 'V' + posm1 + // median line\n                'M' + q1 + ',' + pos0 + 'V' + pos1 + // left edge\n                (notched ?\n                    'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 :\n                    ''\n                ) + // top notched edge\n                'H' + q3 + // end of the top edge\n                'V' + pos0 + // right edge\n                (notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') + // bottom notched edge\n                'Z' + // end of the box\n                'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + // whiskers\n                (whiskerWidth === 0 ?\n                    '' : // whisker caps\n                    'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1\n                )\n            );\n        } else {\n            d3.select(this).attr('d',\n                'M' + posm0 + ',' + m + 'H' + posm1 + // median line\n                'M' + pos0 + ',' + q1 + 'H' + pos1 + // top of the box\n                (notched ?\n                    'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un :\n                    ''\n                ) + // notched right edge\n                'V' + q3 + // end of the right edge\n                'H' + pos0 + // bottom of the box\n                (notched ?\n                    'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln :\n                    ''\n                ) + // notched left edge\n                'Z' + // end of the box\n                'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + // whiskers\n                (whiskerWidth === 0 ?\n                    '' : // whisker caps\n                    'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1\n                )\n            );\n        }\n    });\n}\n\nfunction plotPoints(sel, axes, trace, t) {\n    var xa = axes.x;\n    var ya = axes.y;\n    var bdPos = t.bdPos;\n    var bPos = t.bPos;\n\n    // to support violin points\n    var mode = trace.boxpoints || trace.points;\n\n    // repeatable pseudo-random number generator\n    Lib.seedPseudoRandom();\n\n    // since box plot points get an extra level of nesting, each\n    // box needs the trace styling info\n    var fn = function(d) {\n        d.forEach(function(v) {\n            v.t = t;\n            v.trace = trace;\n        });\n        return d;\n    };\n\n    var gPoints = sel.selectAll('g.points')\n        .data(mode ? fn : []);\n\n    gPoints.enter().append('g')\n        .attr('class', 'points');\n\n    gPoints.exit().remove();\n\n    var paths = gPoints.selectAll('path')\n        .data(function(d) {\n            var i;\n            var pts = d.pts2;\n\n            // normally use IQR, but if this is 0 or too small, use max-min\n            var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n            var minSpread = typicalSpread * 1e-9;\n            var spreadLimit = typicalSpread * JITTERSPREAD;\n            var jitterFactors = [];\n            var maxJitterFactor = 0;\n            var newJitter;\n\n            // dynamic jitter\n            if(trace.jitter) {\n                if(typicalSpread === 0) {\n                    // edge case of no spread at all: fall back to max jitter\n                    maxJitterFactor = 1;\n                    jitterFactors = new Array(pts.length);\n                    for(i = 0; i < pts.length; i++) {\n                        jitterFactors[i] = 1;\n                    }\n                } else {\n                    for(i = 0; i < pts.length; i++) {\n                        var i0 = Math.max(0, i - JITTERCOUNT);\n                        var pmin = pts[i0].v;\n                        var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n                        var pmax = pts[i1].v;\n\n                        if(mode !== 'all') {\n                            if(pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);\n                            else pmin = Math.max(pmin, d.uf);\n                        }\n\n                        var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n                        jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n\n                        jitterFactors.push(jitterFactor);\n                        maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n                    }\n                }\n                newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n            }\n\n            // fills in 'x' and 'y' in calcdata 'pts' item\n            for(i = 0; i < pts.length; i++) {\n                var pt = pts[i];\n                var v = pt.v;\n\n                var jitterOffset = trace.jitter ?\n                    (newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5)) :\n                    0;\n\n                var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n\n                if(trace.orientation === 'h') {\n                    pt.y = posPx;\n                    pt.x = v;\n                } else {\n                    pt.x = posPx;\n                    pt.y = v;\n                }\n\n                // tag suspected outliers\n                if(mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n                    pt.so = true;\n                }\n            }\n\n            return pts;\n        });\n\n    paths.enter().append('path')\n        .classed('point', true);\n\n    paths.exit().remove();\n\n    paths.call(Drawing.translatePoints, xa, ya);\n}\n\nfunction plotBoxMean(sel, axes, trace, t) {\n    var valAxis = axes.val;\n    var posAxis = axes.pos;\n    var posHasRangeBreaks = !!posAxis.rangebreaks;\n\n    var bPos = t.bPos;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n\n    // to support violin mean lines\n    var mode = trace.boxmean || (trace.meanline || {}).visible;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.mean').data((\n        (trace.type === 'box' && trace.boxmean) ||\n        (trace.type === 'violin' && trace.box.visible && trace.meanline.visible)\n    ) ? Lib.identity : []);\n\n    paths.enter().append('path')\n        .attr('class', 'mean')\n        .style({\n            fill: 'none',\n            'vector-effect': 'non-scaling-stroke'\n        });\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        var lcenter = posAxis.c2l(d.pos + bPos, true);\n\n        var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n        var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n        var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n\n        var m = valAxis.c2p(d.mean, true);\n        var sl = valAxis.c2p(d.mean - d.sd, true);\n        var sh = valAxis.c2p(d.mean + d.sd, true);\n\n        if(trace.orientation === 'h') {\n            d3.select(this).attr('d',\n                'M' + m + ',' + pos0 + 'V' + pos1 +\n                (mode === 'sd' ?\n                    'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' :\n                    '')\n            );\n        } else {\n            d3.select(this).attr('d',\n                'M' + pos0 + ',' + m + 'H' + pos1 +\n                (mode === 'sd' ?\n                    'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' :\n                    '')\n            );\n        }\n    });\n}\n\nmodule.exports = {\n    plot: plot,\n    plotBoxAndWhiskers: plotBoxAndWhiskers,\n    plotPoints: plotPoints,\n    plotBoxMean: plotBoxMean\n};\n"]},"metadata":{},"sourceType":"script"}