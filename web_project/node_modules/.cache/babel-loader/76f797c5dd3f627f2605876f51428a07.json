{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar constraintMapping = require('./constraint_mapping');\n\nvar endPlus = require('./end_plus');\n\nmodule.exports = function emptyPathinfo(contours, plotinfo, cd0) {\n  var contoursFinal = contours.type === 'constraint' ? constraintMapping[contours._operation](contours.value) : contours;\n  var cs = contoursFinal.size;\n  var pathinfo = [];\n  var end = endPlus(contoursFinal);\n  var carpet = cd0.trace._carpetTrace;\n  var basePathinfo = carpet ? {\n    // store axes so we can convert to px\n    xaxis: carpet.aaxis,\n    yaxis: carpet.baxis,\n    // full data arrays to use for interpolation\n    x: cd0.a,\n    y: cd0.b\n  } : {\n    xaxis: plotinfo.xaxis,\n    yaxis: plotinfo.yaxis,\n    x: cd0.x,\n    y: cd0.y\n  };\n\n  for (var ci = contoursFinal.start; ci < end; ci += cs) {\n    pathinfo.push(Lib.extendFlat({\n      level: ci,\n      // all the cells with nontrivial marching index\n      crossings: {},\n      // starting points on the edges of the lattice for each contour\n      starts: [],\n      // all unclosed paths (may have less items than starts,\n      // if a path is closed by rounding)\n      edgepaths: [],\n      // all closed paths\n      paths: [],\n      z: cd0.z,\n      smoothing: cd0.trace.line.smoothing\n    }, basePathinfo));\n\n    if (pathinfo.length > 1000) {\n      Lib.warn('Too many contours, clipping at 1000', contours);\n      break;\n    }\n  }\n\n  return pathinfo;\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/contour/empty_pathinfo.js"],"names":["Lib","require","constraintMapping","endPlus","module","exports","emptyPathinfo","contours","plotinfo","cd0","contoursFinal","type","_operation","value","cs","size","pathinfo","end","carpet","trace","_carpetTrace","basePathinfo","xaxis","aaxis","yaxis","baxis","x","a","y","b","ci","start","push","extendFlat","level","crossings","starts","edgepaths","paths","z","smoothing","line","length","warn"],"mappings":"AAAA;;;;;;;AAQA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIC,iBAAiB,GAAGD,OAAO,CAAC,sBAAD,CAA/B;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAD,CAArB;;AAEAG,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAuBC,QAAvB,EAAiCC,QAAjC,EAA2CC,GAA3C,EAAgD;AAC7D,MAAIC,aAAa,GAAIH,QAAQ,CAACI,IAAT,KAAkB,YAAnB,GAChBT,iBAAiB,CAACK,QAAQ,CAACK,UAAV,CAAjB,CAAuCL,QAAQ,CAACM,KAAhD,CADgB,GAEhBN,QAFJ;AAIA,MAAIO,EAAE,GAAGJ,aAAa,CAACK,IAAvB;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,GAAG,GAAGd,OAAO,CAACO,aAAD,CAAjB;AAEA,MAAIQ,MAAM,GAAGT,GAAG,CAACU,KAAJ,CAAUC,YAAvB;AAEA,MAAIC,YAAY,GAAGH,MAAM,GAAG;AACxB;AACAI,IAAAA,KAAK,EAAEJ,MAAM,CAACK,KAFU;AAGxBC,IAAAA,KAAK,EAAEN,MAAM,CAACO,KAHU;AAIxB;AACAC,IAAAA,CAAC,EAAEjB,GAAG,CAACkB,CALiB;AAMxBC,IAAAA,CAAC,EAAEnB,GAAG,CAACoB;AANiB,GAAH,GAOrB;AACAP,IAAAA,KAAK,EAAEd,QAAQ,CAACc,KADhB;AAEAE,IAAAA,KAAK,EAAEhB,QAAQ,CAACgB,KAFhB;AAGAE,IAAAA,CAAC,EAAEjB,GAAG,CAACiB,CAHP;AAIAE,IAAAA,CAAC,EAAEnB,GAAG,CAACmB;AAJP,GAPJ;;AAcA,OAAI,IAAIE,EAAE,GAAGpB,aAAa,CAACqB,KAA3B,EAAkCD,EAAE,GAAGb,GAAvC,EAA4Ca,EAAE,IAAIhB,EAAlD,EAAsD;AAClDE,IAAAA,QAAQ,CAACgB,IAAT,CAAchC,GAAG,CAACiC,UAAJ,CAAe;AACzBC,MAAAA,KAAK,EAAEJ,EADkB;AAEzB;AACAK,MAAAA,SAAS,EAAE,EAHc;AAIzB;AACAC,MAAAA,MAAM,EAAE,EALiB;AAMzB;AACA;AACAC,MAAAA,SAAS,EAAE,EARc;AASzB;AACAC,MAAAA,KAAK,EAAE,EAVkB;AAWzBC,MAAAA,CAAC,EAAE9B,GAAG,CAAC8B,CAXkB;AAYzBC,MAAAA,SAAS,EAAE/B,GAAG,CAACU,KAAJ,CAAUsB,IAAV,CAAeD;AAZD,KAAf,EAaXnB,YAbW,CAAd;;AAeA,QAAGL,QAAQ,CAAC0B,MAAT,GAAkB,IAArB,EAA2B;AACvB1C,MAAAA,GAAG,CAAC2C,IAAJ,CAAS,qCAAT,EAAgDpC,QAAhD;AACA;AACH;AACJ;;AACD,SAAOS,QAAP;AACH,CA/CD","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar constraintMapping = require('./constraint_mapping');\nvar endPlus = require('./end_plus');\n\nmodule.exports = function emptyPathinfo(contours, plotinfo, cd0) {\n    var contoursFinal = (contours.type === 'constraint') ?\n        constraintMapping[contours._operation](contours.value) :\n        contours;\n\n    var cs = contoursFinal.size;\n    var pathinfo = [];\n    var end = endPlus(contoursFinal);\n\n    var carpet = cd0.trace._carpetTrace;\n\n    var basePathinfo = carpet ? {\n        // store axes so we can convert to px\n        xaxis: carpet.aaxis,\n        yaxis: carpet.baxis,\n        // full data arrays to use for interpolation\n        x: cd0.a,\n        y: cd0.b\n    } : {\n        xaxis: plotinfo.xaxis,\n        yaxis: plotinfo.yaxis,\n        x: cd0.x,\n        y: cd0.y\n    };\n\n    for(var ci = contoursFinal.start; ci < end; ci += cs) {\n        pathinfo.push(Lib.extendFlat({\n            level: ci,\n            // all the cells with nontrivial marching index\n            crossings: {},\n            // starting points on the edges of the lattice for each contour\n            starts: [],\n            // all unclosed paths (may have less items than starts,\n            // if a path is closed by rounding)\n            edgepaths: [],\n            // all closed paths\n            paths: [],\n            z: cd0.z,\n            smoothing: cd0.trace.line.smoothing\n        }, basePathinfo));\n\n        if(pathinfo.length > 1000) {\n            Lib.warn('Too many contours, clipping at 1000', contours);\n            break;\n        }\n    }\n    return pathinfo;\n};\n"]},"metadata":{},"sourceType":"script"}