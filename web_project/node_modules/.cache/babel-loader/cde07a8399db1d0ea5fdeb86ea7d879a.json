{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\n\nvar getSubplotData = require('../get_data').getSubplotData;\n\nvar handleTickValueDefaults = require('../cartesian/tick_value_defaults');\n\nvar handleTickMarkDefaults = require('../cartesian/tick_mark_defaults');\n\nvar handleTickLabelDefaults = require('../cartesian/tick_label_defaults');\n\nvar handleCategoryOrderDefaults = require('../cartesian/category_order_defaults');\n\nvar handleLineGridDefaults = require('../cartesian/line_grid_defaults');\n\nvar autoType = require('../cartesian/axis_autotype');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar setConvert = require('./set_convert');\n\nvar constants = require('./constants');\n\nvar axisNames = constants.axisNames;\n\nfunction handleDefaults(contIn, contOut, coerce, opts) {\n  var bgColor = coerce('bgcolor');\n  opts.bgColor = Color.combine(bgColor, opts.paper_bgcolor);\n  var sector = coerce('sector');\n  coerce('hole'); // could optimize, subplotData is not always needed!\n\n  var subplotData = getSubplotData(opts.fullData, constants.name, opts.id);\n  var layoutOut = opts.layoutOut;\n  var axName;\n\n  function coerceAxis(attr, dflt) {\n    return coerce(axName + '.' + attr, dflt);\n  }\n\n  for (var i = 0; i < axisNames.length; i++) {\n    axName = axisNames[i];\n\n    if (!Lib.isPlainObject(contIn[axName])) {\n      contIn[axName] = {};\n    }\n\n    var axIn = contIn[axName];\n    var axOut = Template.newContainer(contOut, axName);\n    axOut._id = axOut._name = axName;\n    axOut._attr = opts.id + '.' + axName;\n    axOut._traceIndices = subplotData.map(function (t) {\n      return t._expandedIndex;\n    });\n    var dataAttr = constants.axisName2dataArray[axName];\n    var axType = handleAxisTypeDefaults(axIn, axOut, coerceAxis, subplotData, dataAttr);\n    handleCategoryOrderDefaults(axIn, axOut, coerceAxis, {\n      axData: subplotData,\n      dataAttr: dataAttr\n    });\n    var visible = coerceAxis('visible');\n    setConvert(axOut, contOut, layoutOut);\n    coerceAxis('uirevision', contOut.uirevision);\n    var dfltColor;\n    var dfltFontColor;\n\n    if (visible) {\n      dfltColor = coerceAxis('color');\n      dfltFontColor = dfltColor === axIn.color ? dfltColor : opts.font.color;\n    } // We don't want to make downstream code call ax.setScale,\n    // as both radial and angular axes don't have a set domain.\n    // Furthermore, angular axes don't have a set range.\n    //\n    // Mocked domains and ranges are set by the polar subplot instances,\n    // but Axes.findExtremes uses the sign of _m to determine which padding value\n    // to use.\n    //\n    // By setting, _m to 1 here, we make Axes.findExtremes think that\n    // range[1] > range[0], and vice-versa for `autorange: 'reversed'` below.\n\n\n    axOut._m = 1;\n\n    switch (axName) {\n      case 'radialaxis':\n        var autoRange = coerceAxis('autorange', !axOut.isValidRange(axIn.range));\n        axIn.autorange = autoRange;\n        if (autoRange && (axType === 'linear' || axType === '-')) coerceAxis('rangemode');\n        if (autoRange === 'reversed') axOut._m = -1;\n        coerceAxis('range');\n        axOut.cleanRange('range', {\n          dfltRange: [0, 1]\n        });\n\n        if (visible) {\n          coerceAxis('side');\n          coerceAxis('angle', sector[0]);\n          coerceAxis('title.text');\n          Lib.coerceFont(coerceAxis, 'title.font', {\n            family: opts.font.family,\n            size: Math.round(opts.font.size * 1.2),\n            color: dfltFontColor\n          });\n        }\n\n        break;\n\n      case 'angularaxis':\n        // We do not support 'true' date angular axes yet,\n        // users can still plot dates on angular axes by setting\n        // `angularaxis.type: 'category'`.\n        //\n        // Here, if a date angular axes is detected, we make\n        // all its corresponding traces invisible, so that\n        // when we do add support for data angular axes, the new\n        // behavior won't conflict with existing behavior\n        if (axType === 'date') {\n          Lib.log('Polar plots do not support date angular axes yet.');\n\n          for (var j = 0; j < subplotData.length; j++) {\n            subplotData[j].visible = false;\n          } // turn this into a 'dummy' linear axis so that\n          // the subplot still renders ok\n\n\n          axType = axIn.type = axOut.type = 'linear';\n        }\n\n        if (axType === 'linear') {\n          coerceAxis('thetaunit');\n        } else {\n          coerceAxis('period');\n        }\n\n        var direction = coerceAxis('direction');\n        coerceAxis('rotation', {\n          counterclockwise: 0,\n          clockwise: 90\n        }[direction]);\n        break;\n    }\n\n    if (visible) {\n      handleTickValueDefaults(axIn, axOut, coerceAxis, axOut.type);\n      handleTickLabelDefaults(axIn, axOut, coerceAxis, axOut.type, {\n        tickSuffixDflt: axOut.thetaunit === 'degrees' ? '°' : undefined\n      });\n      handleTickMarkDefaults(axIn, axOut, coerceAxis, {\n        outerTicks: true\n      });\n      var showTickLabels = coerceAxis('showticklabels');\n\n      if (showTickLabels) {\n        Lib.coerceFont(coerceAxis, 'tickfont', {\n          family: opts.font.family,\n          size: opts.font.size,\n          color: dfltFontColor\n        });\n        coerceAxis('tickangle');\n        coerceAxis('tickformat');\n      }\n\n      handleLineGridDefaults(axIn, axOut, coerceAxis, {\n        dfltColor: dfltColor,\n        bgColor: opts.bgColor,\n        // default grid color is darker here (60%, vs cartesian default ~91%)\n        // because the grid is not square so the eye needs heavier cues to follow\n        blend: 60,\n        showLine: true,\n        showGrid: true,\n        noZeroLine: true,\n        attributes: layoutAttributes[axName]\n      });\n      coerceAxis('layer');\n    }\n\n    if (axType !== 'category') coerceAxis('hoverformat');\n    axOut._input = axIn;\n  }\n\n  if (contOut.angularaxis.type === 'category') {\n    coerce('gridshape');\n  }\n}\n\nfunction handleAxisTypeDefaults(axIn, axOut, coerce, subplotData, dataAttr) {\n  var axType = coerce('type');\n\n  if (axType === '-') {\n    var trace;\n\n    for (var i = 0; i < subplotData.length; i++) {\n      if (subplotData[i].visible) {\n        trace = subplotData[i];\n        break;\n      }\n    }\n\n    if (trace && trace[dataAttr]) {\n      axOut.type = autoType(trace[dataAttr], 'gregorian');\n    }\n\n    if (axOut.type === '-') {\n      axOut.type = 'linear';\n    } else {\n      // copy autoType back to input axis\n      // note that if this object didn't exist\n      // in the input layout, we have to put it in\n      // this happens in the main supplyDefaults function\n      axIn.type = axOut.type;\n    }\n  }\n\n  return axOut.type;\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: constants.name,\n    attributes: layoutAttributes,\n    handleDefaults: handleDefaults,\n    font: layoutOut.font,\n    paper_bgcolor: layoutOut.paper_bgcolor,\n    fullData: fullData,\n    layoutOut: layoutOut\n  });\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/plots/polar/layout_defaults.js"],"names":["Lib","require","Color","Template","handleSubplotDefaults","getSubplotData","handleTickValueDefaults","handleTickMarkDefaults","handleTickLabelDefaults","handleCategoryOrderDefaults","handleLineGridDefaults","autoType","layoutAttributes","setConvert","constants","axisNames","handleDefaults","contIn","contOut","coerce","opts","bgColor","combine","paper_bgcolor","sector","subplotData","fullData","name","id","layoutOut","axName","coerceAxis","attr","dflt","i","length","isPlainObject","axIn","axOut","newContainer","_id","_name","_attr","_traceIndices","map","t","_expandedIndex","dataAttr","axisName2dataArray","axType","handleAxisTypeDefaults","axData","visible","uirevision","dfltColor","dfltFontColor","color","font","_m","autoRange","isValidRange","range","autorange","cleanRange","dfltRange","coerceFont","family","size","Math","round","log","j","type","direction","counterclockwise","clockwise","tickSuffixDflt","thetaunit","undefined","outerTicks","showTickLabels","blend","showLine","showGrid","noZeroLine","attributes","_input","angularaxis","trace","module","exports","supplyLayoutDefaults","layoutIn"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Template = require('../../plot_api/plot_template');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar getSubplotData = require('../get_data').getSubplotData;\n\nvar handleTickValueDefaults = require('../cartesian/tick_value_defaults');\nvar handleTickMarkDefaults = require('../cartesian/tick_mark_defaults');\nvar handleTickLabelDefaults = require('../cartesian/tick_label_defaults');\nvar handleCategoryOrderDefaults = require('../cartesian/category_order_defaults');\nvar handleLineGridDefaults = require('../cartesian/line_grid_defaults');\nvar autoType = require('../cartesian/axis_autotype');\n\nvar layoutAttributes = require('./layout_attributes');\nvar setConvert = require('./set_convert');\nvar constants = require('./constants');\nvar axisNames = constants.axisNames;\n\nfunction handleDefaults(contIn, contOut, coerce, opts) {\n    var bgColor = coerce('bgcolor');\n    opts.bgColor = Color.combine(bgColor, opts.paper_bgcolor);\n\n    var sector = coerce('sector');\n    coerce('hole');\n\n    // could optimize, subplotData is not always needed!\n    var subplotData = getSubplotData(opts.fullData, constants.name, opts.id);\n    var layoutOut = opts.layoutOut;\n    var axName;\n\n    function coerceAxis(attr, dflt) {\n        return coerce(axName + '.' + attr, dflt);\n    }\n\n    for(var i = 0; i < axisNames.length; i++) {\n        axName = axisNames[i];\n\n        if(!Lib.isPlainObject(contIn[axName])) {\n            contIn[axName] = {};\n        }\n\n        var axIn = contIn[axName];\n        var axOut = Template.newContainer(contOut, axName);\n        axOut._id = axOut._name = axName;\n        axOut._attr = opts.id + '.' + axName;\n        axOut._traceIndices = subplotData.map(function(t) { return t._expandedIndex; });\n\n        var dataAttr = constants.axisName2dataArray[axName];\n        var axType = handleAxisTypeDefaults(axIn, axOut, coerceAxis, subplotData, dataAttr);\n\n        handleCategoryOrderDefaults(axIn, axOut, coerceAxis, {\n            axData: subplotData,\n            dataAttr: dataAttr\n        });\n\n        var visible = coerceAxis('visible');\n        setConvert(axOut, contOut, layoutOut);\n\n        coerceAxis('uirevision', contOut.uirevision);\n\n        var dfltColor;\n        var dfltFontColor;\n\n        if(visible) {\n            dfltColor = coerceAxis('color');\n            dfltFontColor = (dfltColor === axIn.color) ? dfltColor : opts.font.color;\n        }\n\n        // We don't want to make downstream code call ax.setScale,\n        // as both radial and angular axes don't have a set domain.\n        // Furthermore, angular axes don't have a set range.\n        //\n        // Mocked domains and ranges are set by the polar subplot instances,\n        // but Axes.findExtremes uses the sign of _m to determine which padding value\n        // to use.\n        //\n        // By setting, _m to 1 here, we make Axes.findExtremes think that\n        // range[1] > range[0], and vice-versa for `autorange: 'reversed'` below.\n        axOut._m = 1;\n\n        switch(axName) {\n            case 'radialaxis':\n                var autoRange = coerceAxis('autorange', !axOut.isValidRange(axIn.range));\n                axIn.autorange = autoRange;\n                if(autoRange && (axType === 'linear' || axType === '-')) coerceAxis('rangemode');\n                if(autoRange === 'reversed') axOut._m = -1;\n\n                coerceAxis('range');\n                axOut.cleanRange('range', {dfltRange: [0, 1]});\n\n                if(visible) {\n                    coerceAxis('side');\n                    coerceAxis('angle', sector[0]);\n\n                    coerceAxis('title.text');\n                    Lib.coerceFont(coerceAxis, 'title.font', {\n                        family: opts.font.family,\n                        size: Math.round(opts.font.size * 1.2),\n                        color: dfltFontColor\n                    });\n                }\n                break;\n\n            case 'angularaxis':\n                // We do not support 'true' date angular axes yet,\n                // users can still plot dates on angular axes by setting\n                // `angularaxis.type: 'category'`.\n                //\n                // Here, if a date angular axes is detected, we make\n                // all its corresponding traces invisible, so that\n                // when we do add support for data angular axes, the new\n                // behavior won't conflict with existing behavior\n                if(axType === 'date') {\n                    Lib.log('Polar plots do not support date angular axes yet.');\n\n                    for(var j = 0; j < subplotData.length; j++) {\n                        subplotData[j].visible = false;\n                    }\n\n                    // turn this into a 'dummy' linear axis so that\n                    // the subplot still renders ok\n                    axType = axIn.type = axOut.type = 'linear';\n                }\n\n                if(axType === 'linear') {\n                    coerceAxis('thetaunit');\n                } else {\n                    coerceAxis('period');\n                }\n\n                var direction = coerceAxis('direction');\n                coerceAxis('rotation', {counterclockwise: 0, clockwise: 90}[direction]);\n                break;\n        }\n\n        if(visible) {\n            handleTickValueDefaults(axIn, axOut, coerceAxis, axOut.type);\n            handleTickLabelDefaults(axIn, axOut, coerceAxis, axOut.type, {\n                tickSuffixDflt: axOut.thetaunit === 'degrees' ? '°' : undefined\n            });\n            handleTickMarkDefaults(axIn, axOut, coerceAxis, {outerTicks: true});\n\n            var showTickLabels = coerceAxis('showticklabels');\n            if(showTickLabels) {\n                Lib.coerceFont(coerceAxis, 'tickfont', {\n                    family: opts.font.family,\n                    size: opts.font.size,\n                    color: dfltFontColor\n                });\n                coerceAxis('tickangle');\n                coerceAxis('tickformat');\n            }\n\n            handleLineGridDefaults(axIn, axOut, coerceAxis, {\n                dfltColor: dfltColor,\n                bgColor: opts.bgColor,\n                // default grid color is darker here (60%, vs cartesian default ~91%)\n                // because the grid is not square so the eye needs heavier cues to follow\n                blend: 60,\n                showLine: true,\n                showGrid: true,\n                noZeroLine: true,\n                attributes: layoutAttributes[axName]\n            });\n\n            coerceAxis('layer');\n        }\n\n        if(axType !== 'category') coerceAxis('hoverformat');\n\n        axOut._input = axIn;\n    }\n\n    if(contOut.angularaxis.type === 'category') {\n        coerce('gridshape');\n    }\n}\n\nfunction handleAxisTypeDefaults(axIn, axOut, coerce, subplotData, dataAttr) {\n    var axType = coerce('type');\n\n    if(axType === '-') {\n        var trace;\n\n        for(var i = 0; i < subplotData.length; i++) {\n            if(subplotData[i].visible) {\n                trace = subplotData[i];\n                break;\n            }\n        }\n\n        if(trace && trace[dataAttr]) {\n            axOut.type = autoType(trace[dataAttr], 'gregorian');\n        }\n\n        if(axOut.type === '-') {\n            axOut.type = 'linear';\n        } else {\n            // copy autoType back to input axis\n            // note that if this object didn't exist\n            // in the input layout, we have to put it in\n            // this happens in the main supplyDefaults function\n            axIn.type = axOut.type;\n        }\n    }\n\n    return axOut.type;\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n        type: constants.name,\n        attributes: layoutAttributes,\n        handleDefaults: handleDefaults,\n        font: layoutOut.font,\n        paper_bgcolor: layoutOut.paper_bgcolor,\n        fullData: fullData,\n        layoutOut: layoutOut\n    });\n};\n"]},"metadata":{},"sourceType":"script"}