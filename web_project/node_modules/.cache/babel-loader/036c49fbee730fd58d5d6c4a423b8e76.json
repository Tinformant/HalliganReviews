{"ast":null,"code":"// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\nfunction SegmentChainer(segments, eps, buildLog) {\n  var chains = [];\n  var regions = [];\n  segments.forEach(function (seg) {\n    var pt1 = seg.start;\n    var pt2 = seg.end;\n\n    if (eps.pointsSame(pt1, pt2)) {\n      console.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' + 'probably too small or too large');\n      return;\n    }\n\n    if (buildLog) buildLog.chainStart(seg); // search for two chains that this segment matches\n\n    var first_match = {\n      index: 0,\n      matches_head: false,\n      matches_pt1: false\n    };\n    var second_match = {\n      index: 0,\n      matches_head: false,\n      matches_pt1: false\n    };\n    var next_match = first_match;\n\n    function setMatch(index, matches_head, matches_pt1) {\n      // return true if we've matched twice\n      next_match.index = index;\n      next_match.matches_head = matches_head;\n      next_match.matches_pt1 = matches_pt1;\n\n      if (next_match === first_match) {\n        next_match = second_match;\n        return false;\n      }\n\n      next_match = null;\n      return true; // we've matched twice, we're done here\n    }\n\n    for (var i = 0; i < chains.length; i++) {\n      var chain = chains[i];\n      var head = chain[0];\n      var head2 = chain[1];\n      var tail = chain[chain.length - 1];\n      var tail2 = chain[chain.length - 2];\n\n      if (eps.pointsSame(head, pt1)) {\n        if (setMatch(i, true, true)) break;\n      } else if (eps.pointsSame(head, pt2)) {\n        if (setMatch(i, true, false)) break;\n      } else if (eps.pointsSame(tail, pt1)) {\n        if (setMatch(i, false, true)) break;\n      } else if (eps.pointsSame(tail, pt2)) {\n        if (setMatch(i, false, false)) break;\n      }\n    }\n\n    if (next_match === first_match) {\n      // we didn't match anything, so create a new chain\n      chains.push([pt1, pt2]);\n      if (buildLog) buildLog.chainNew(pt1, pt2);\n      return;\n    }\n\n    if (next_match === second_match) {\n      // we matched a single chain\n      if (buildLog) buildLog.chainMatch(first_match.index); // add the other point to the apporpriate end, and check to see if we've closed the\n      // chain into a loop\n\n      var index = first_match.index;\n      var pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc\n\n      var addToHead = first_match.matches_head; // if we matched at head, then add to the head\n\n      var chain = chains[index];\n      var grow = addToHead ? chain[0] : chain[chain.length - 1];\n      var grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n      var oppo = addToHead ? chain[chain.length - 1] : chain[0];\n      var oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n      if (eps.pointsCollinear(grow2, grow, pt)) {\n        // grow isn't needed because it's directly between grow2 and pt:\n        // grow2 ---grow---> pt\n        if (addToHead) {\n          if (buildLog) buildLog.chainRemoveHead(first_match.index, pt);\n          chain.shift();\n        } else {\n          if (buildLog) buildLog.chainRemoveTail(first_match.index, pt);\n          chain.pop();\n        }\n\n        grow = grow2; // old grow is gone... new grow is what grow2 was\n      }\n\n      if (eps.pointsSame(oppo, pt)) {\n        // we're closing the loop, so remove chain from chains\n        chains.splice(index, 1);\n\n        if (eps.pointsCollinear(oppo2, oppo, grow)) {\n          // oppo isn't needed because it's directly between oppo2 and grow:\n          // oppo2 ---oppo--->grow\n          if (addToHead) {\n            if (buildLog) buildLog.chainRemoveTail(first_match.index, grow);\n            chain.pop();\n          } else {\n            if (buildLog) buildLog.chainRemoveHead(first_match.index, grow);\n            chain.shift();\n          }\n        }\n\n        if (buildLog) buildLog.chainClose(first_match.index); // we have a closed chain!\n\n        regions.push(chain);\n        return;\n      } // not closing a loop, so just add it to the apporpriate side\n\n\n      if (addToHead) {\n        if (buildLog) buildLog.chainAddHead(first_match.index, pt);\n        chain.unshift(pt);\n      } else {\n        if (buildLog) buildLog.chainAddTail(first_match.index, pt);\n        chain.push(pt);\n      }\n\n      return;\n    } // otherwise, we matched two chains, so we need to combine those chains together\n\n\n    function reverseChain(index) {\n      if (buildLog) buildLog.chainReverse(index);\n      chains[index].reverse(); // gee, that's easy\n    }\n\n    function appendChain(index1, index2) {\n      // index1 gets index2 appended to it, and index2 is removed\n      var chain1 = chains[index1];\n      var chain2 = chains[index2];\n      var tail = chain1[chain1.length - 1];\n      var tail2 = chain1[chain1.length - 2];\n      var head = chain2[0];\n      var head2 = chain2[1];\n\n      if (eps.pointsCollinear(tail2, tail, head)) {\n        // tail isn't needed because it's directly between tail2 and head\n        // tail2 ---tail---> head\n        if (buildLog) buildLog.chainRemoveTail(index1, tail);\n        chain1.pop();\n        tail = tail2; // old tail is gone... new tail is what tail2 was\n      }\n\n      if (eps.pointsCollinear(tail, head, head2)) {\n        // head isn't needed because it's directly between tail and head2\n        // tail ---head---> head2\n        if (buildLog) buildLog.chainRemoveHead(index2, head);\n        chain2.shift();\n      }\n\n      if (buildLog) buildLog.chainJoin(index1, index2);\n      chains[index1] = chain1.concat(chain2);\n      chains.splice(index2, 1);\n    }\n\n    var F = first_match.index;\n    var S = second_match.index;\n    if (buildLog) buildLog.chainConnect(F, S);\n    var reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed\n\n    if (first_match.matches_head) {\n      if (second_match.matches_head) {\n        if (reverseF) {\n          // <<<< F <<<< --- >>>> S >>>>\n          reverseChain(F); // >>>> F >>>> --- >>>> S >>>>\n\n          appendChain(F, S);\n        } else {\n          // <<<< F <<<< --- >>>> S >>>>\n          reverseChain(S); // <<<< F <<<< --- <<<< S <<<<   logically same as:\n          // >>>> S >>>> --- >>>> F >>>>\n\n          appendChain(S, F);\n        }\n      } else {\n        // <<<< F <<<< --- <<<< S <<<<   logically same as:\n        // >>>> S >>>> --- >>>> F >>>>\n        appendChain(S, F);\n      }\n    } else {\n      if (second_match.matches_head) {\n        // >>>> F >>>> --- >>>> S >>>>\n        appendChain(F, S);\n      } else {\n        if (reverseF) {\n          // >>>> F >>>> --- <<<< S <<<<\n          reverseChain(F); // <<<< F <<<< --- <<<< S <<<<   logically same as:\n          // >>>> S >>>> --- >>>> F >>>>\n\n          appendChain(S, F);\n        } else {\n          // >>>> F >>>> --- <<<< S <<<<\n          reverseChain(S); // >>>> F >>>> --- >>>> S >>>>\n\n          appendChain(F, S);\n        }\n      }\n    }\n  });\n  return regions;\n}\n\nmodule.exports = SegmentChainer;","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/polybooljs/lib/segment-chainer.js"],"names":["SegmentChainer","segments","eps","buildLog","chains","regions","forEach","seg","pt1","start","pt2","end","pointsSame","console","warn","chainStart","first_match","index","matches_head","matches_pt1","second_match","next_match","setMatch","i","length","chain","head","head2","tail","tail2","push","chainNew","chainMatch","pt","addToHead","grow","grow2","oppo","oppo2","pointsCollinear","chainRemoveHead","shift","chainRemoveTail","pop","splice","chainClose","chainAddHead","unshift","chainAddTail","reverseChain","chainReverse","reverse","appendChain","index1","index2","chain1","chain2","chainJoin","concat","F","S","chainConnect","reverseF","module","exports"],"mappings":"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","sourcesContent":["// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\n\nfunction SegmentChainer(segments, eps, buildLog){\n\tvar chains = [];\n\tvar regions = [];\n\n\tsegments.forEach(function(seg){\n\t\tvar pt1 = seg.start;\n\t\tvar pt2 = seg.end;\n\t\tif (eps.pointsSame(pt1, pt2)){\n\t\t\tconsole.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t'probably too small or too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainStart(seg);\n\n\t\t// search for two chains that this segment matches\n\t\tvar first_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar second_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar next_match = first_match;\n\t\tfunction setMatch(index, matches_head, matches_pt1){\n\t\t\t// return true if we've matched twice\n\t\t\tnext_match.index = index;\n\t\t\tnext_match.matches_head = matches_head;\n\t\t\tnext_match.matches_pt1 = matches_pt1;\n\t\t\tif (next_match === first_match){\n\t\t\t\tnext_match = second_match;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnext_match = null;\n\t\t\treturn true; // we've matched twice, we're done here\n\t\t}\n\t\tfor (var i = 0; i < chains.length; i++){\n\t\t\tvar chain = chains[i];\n\t\t\tvar head  = chain[0];\n\t\t\tvar head2 = chain[1];\n\t\t\tvar tail  = chain[chain.length - 1];\n\t\t\tvar tail2 = chain[chain.length - 2];\n\t\t\tif (eps.pointsSame(head, pt1)){\n\t\t\t\tif (setMatch(i, true, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(head, pt2)){\n\t\t\t\tif (setMatch(i, true, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt1)){\n\t\t\t\tif (setMatch(i, false, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt2)){\n\t\t\t\tif (setMatch(i, false, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (next_match === first_match){\n\t\t\t// we didn't match anything, so create a new chain\n\t\t\tchains.push([ pt1, pt2 ]);\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainNew(pt1, pt2);\n\t\t\treturn;\n\t\t}\n\n\t\tif (next_match === second_match){\n\t\t\t// we matched a single chain\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainMatch(first_match.index);\n\n\t\t\t// add the other point to the apporpriate end, and check to see if we've closed the\n\t\t\t// chain into a loop\n\n\t\t\tvar index = first_match.index;\n\t\t\tvar pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc\n\t\t\tvar addToHead = first_match.matches_head; // if we matched at head, then add to the head\n\n\t\t\tvar chain = chains[index];\n\t\t\tvar grow  = addToHead ? chain[0] : chain[chain.length - 1];\n\t\t\tvar grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n\t\t\tvar oppo  = addToHead ? chain[chain.length - 1] : chain[0];\n\t\t\tvar oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n\t\t\tif (eps.pointsCollinear(grow2, grow, pt)){\n\t\t\t\t// grow isn't needed because it's directly between grow2 and pt:\n\t\t\t\t// grow2 ---grow---> pt\n\t\t\t\tif (addToHead){\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, pt);\n\t\t\t\t\tchain.shift();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, pt);\n\t\t\t\t\tchain.pop();\n\t\t\t\t}\n\t\t\t\tgrow = grow2; // old grow is gone... new grow is what grow2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsSame(oppo, pt)){\n\t\t\t\t// we're closing the loop, so remove chain from chains\n\t\t\t\tchains.splice(index, 1);\n\n\t\t\t\tif (eps.pointsCollinear(oppo2, oppo, grow)){\n\t\t\t\t\t// oppo isn't needed because it's directly between oppo2 and grow:\n\t\t\t\t\t// oppo2 ---oppo--->grow\n\t\t\t\t\tif (addToHead){\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, grow);\n\t\t\t\t\t\tchain.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, grow);\n\t\t\t\t\t\tchain.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainClose(first_match.index);\n\n\t\t\t\t// we have a closed chain!\n\t\t\t\tregions.push(chain);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// not closing a loop, so just add it to the apporpriate side\n\t\t\tif (addToHead){\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddHead(first_match.index, pt);\n\t\t\t\tchain.unshift(pt);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddTail(first_match.index, pt);\n\t\t\t\tchain.push(pt);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise, we matched two chains, so we need to combine those chains together\n\n\t\tfunction reverseChain(index){\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainReverse(index);\n\t\t\tchains[index].reverse(); // gee, that's easy\n\t\t}\n\n\t\tfunction appendChain(index1, index2){\n\t\t\t// index1 gets index2 appended to it, and index2 is removed\n\t\t\tvar chain1 = chains[index1];\n\t\t\tvar chain2 = chains[index2];\n\t\t\tvar tail  = chain1[chain1.length - 1];\n\t\t\tvar tail2 = chain1[chain1.length - 2];\n\t\t\tvar head  = chain2[0];\n\t\t\tvar head2 = chain2[1];\n\n\t\t\tif (eps.pointsCollinear(tail2, tail, head)){\n\t\t\t\t// tail isn't needed because it's directly between tail2 and head\n\t\t\t\t// tail2 ---tail---> head\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveTail(index1, tail);\n\t\t\t\tchain1.pop();\n\t\t\t\ttail = tail2; // old tail is gone... new tail is what tail2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsCollinear(tail, head, head2)){\n\t\t\t\t// head isn't needed because it's directly between tail and head2\n\t\t\t\t// tail ---head---> head2\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveHead(index2, head);\n\t\t\t\tchain2.shift();\n\t\t\t}\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainJoin(index1, index2);\n\t\t\tchains[index1] = chain1.concat(chain2);\n\t\t\tchains.splice(index2, 1);\n\t\t}\n\n\t\tvar F = first_match.index;\n\t\tvar S = second_match.index;\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainConnect(F, S);\n\n\t\tvar reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed\n\t\tif (first_match.matches_head){\n\t\t\tif (second_match.matches_head){\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\tappendChain(S, F);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (second_match.matches_head){\n\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\tappendChain(F, S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn regions;\n}\n\nmodule.exports = SegmentChainer;\n"]},"metadata":{},"sourceType":"script"}