{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar LINKEDFILLS = {\n  tonextx: 1,\n  tonexty: 1,\n  tonext: 1\n};\n\nmodule.exports = function linkTraces(gd, plotinfo, cdscatter) {\n  var trace, i, group, prevtrace, groupIndex; // first sort traces to keep stacks & filled-together groups together\n\n  var groupIndices = {};\n  var needsSort = false;\n  var prevGroupIndex = -1;\n  var nextGroupIndex = 0;\n  var prevUnstackedGroupIndex = -1;\n\n  for (i = 0; i < cdscatter.length; i++) {\n    trace = cdscatter[i][0].trace;\n    group = trace.stackgroup || '';\n\n    if (group) {\n      if (group in groupIndices) {\n        groupIndex = groupIndices[group];\n      } else {\n        groupIndex = groupIndices[group] = nextGroupIndex;\n        nextGroupIndex++;\n      }\n    } else if (trace.fill in LINKEDFILLS && prevUnstackedGroupIndex >= 0) {\n      groupIndex = prevUnstackedGroupIndex;\n    } else {\n      groupIndex = prevUnstackedGroupIndex = nextGroupIndex;\n      nextGroupIndex++;\n    }\n\n    if (groupIndex < prevGroupIndex) needsSort = true;\n    trace._groupIndex = prevGroupIndex = groupIndex;\n  }\n\n  var cdscatterSorted = cdscatter.slice();\n\n  if (needsSort) {\n    cdscatterSorted.sort(function (a, b) {\n      var traceA = a[0].trace;\n      var traceB = b[0].trace;\n      return traceA._groupIndex - traceB._groupIndex || traceA.index - traceB.index;\n    });\n  } // now link traces to each other\n\n\n  var prevtraces = {};\n\n  for (i = 0; i < cdscatterSorted.length; i++) {\n    trace = cdscatterSorted[i][0].trace;\n    group = trace.stackgroup || ''; // Note: The check which ensures all cdscatter here are for the same axis and\n    // are either cartesian or scatterternary has been removed. This code assumes\n    // the passed scattertraces have been filtered to the proper plot types and\n    // the proper subplots.\n\n    if (trace.visible === true) {\n      trace._nexttrace = null;\n\n      if (trace.fill in LINKEDFILLS) {\n        prevtrace = prevtraces[group];\n        trace._prevtrace = prevtrace || null;\n\n        if (prevtrace) {\n          prevtrace._nexttrace = trace;\n        }\n      }\n\n      trace._ownfill = trace.fill && (trace.fill.substr(0, 6) === 'tozero' || trace.fill === 'toself' || trace.fill.substr(0, 2) === 'to' && !trace._prevtrace);\n      prevtraces[group] = trace;\n    } else {\n      trace._prevtrace = trace._nexttrace = trace._ownfill = null;\n    }\n  }\n\n  return cdscatterSorted;\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/scatter/link_traces.js"],"names":["LINKEDFILLS","tonextx","tonexty","tonext","module","exports","linkTraces","gd","plotinfo","cdscatter","trace","i","group","prevtrace","groupIndex","groupIndices","needsSort","prevGroupIndex","nextGroupIndex","prevUnstackedGroupIndex","length","stackgroup","fill","_groupIndex","cdscatterSorted","slice","sort","a","b","traceA","traceB","index","prevtraces","visible","_nexttrace","_prevtrace","_ownfill","substr"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar LINKEDFILLS = {tonextx: 1, tonexty: 1, tonext: 1};\n\nmodule.exports = function linkTraces(gd, plotinfo, cdscatter) {\n    var trace, i, group, prevtrace, groupIndex;\n\n    // first sort traces to keep stacks & filled-together groups together\n    var groupIndices = {};\n    var needsSort = false;\n    var prevGroupIndex = -1;\n    var nextGroupIndex = 0;\n    var prevUnstackedGroupIndex = -1;\n    for(i = 0; i < cdscatter.length; i++) {\n        trace = cdscatter[i][0].trace;\n        group = trace.stackgroup || '';\n        if(group) {\n            if(group in groupIndices) {\n                groupIndex = groupIndices[group];\n            } else {\n                groupIndex = groupIndices[group] = nextGroupIndex;\n                nextGroupIndex++;\n            }\n        } else if(trace.fill in LINKEDFILLS && prevUnstackedGroupIndex >= 0) {\n            groupIndex = prevUnstackedGroupIndex;\n        } else {\n            groupIndex = prevUnstackedGroupIndex = nextGroupIndex;\n            nextGroupIndex++;\n        }\n\n        if(groupIndex < prevGroupIndex) needsSort = true;\n        trace._groupIndex = prevGroupIndex = groupIndex;\n    }\n\n    var cdscatterSorted = cdscatter.slice();\n    if(needsSort) {\n        cdscatterSorted.sort(function(a, b) {\n            var traceA = a[0].trace;\n            var traceB = b[0].trace;\n            return (traceA._groupIndex - traceB._groupIndex) ||\n                (traceA.index - traceB.index);\n        });\n    }\n\n    // now link traces to each other\n    var prevtraces = {};\n    for(i = 0; i < cdscatterSorted.length; i++) {\n        trace = cdscatterSorted[i][0].trace;\n        group = trace.stackgroup || '';\n\n        // Note: The check which ensures all cdscatter here are for the same axis and\n        // are either cartesian or scatterternary has been removed. This code assumes\n        // the passed scattertraces have been filtered to the proper plot types and\n        // the proper subplots.\n        if(trace.visible === true) {\n            trace._nexttrace = null;\n\n            if(trace.fill in LINKEDFILLS) {\n                prevtrace = prevtraces[group];\n                trace._prevtrace = prevtrace || null;\n\n                if(prevtrace) {\n                    prevtrace._nexttrace = trace;\n                }\n            }\n\n            trace._ownfill = (trace.fill && (\n                trace.fill.substr(0, 6) === 'tozero' ||\n                trace.fill === 'toself' ||\n                (trace.fill.substr(0, 2) === 'to' && !trace._prevtrace)\n            ));\n\n            prevtraces[group] = trace;\n        } else {\n            trace._prevtrace = trace._nexttrace = trace._ownfill = null;\n        }\n    }\n\n    return cdscatterSorted;\n};\n"]},"metadata":{},"sourceType":"script"}