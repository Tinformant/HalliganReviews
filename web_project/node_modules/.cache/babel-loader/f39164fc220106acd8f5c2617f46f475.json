{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nmodule.exports = function makeBoundArray(trace, arrayIn, v0In, dvIn, numbricks, ax) {\n  var arrayOut = [];\n  var isContour = Registry.traceIs(trace, 'contour');\n  var isHist = Registry.traceIs(trace, 'histogram');\n  var isGL2D = Registry.traceIs(trace, 'gl2d');\n  var v0;\n  var dv;\n  var i;\n  var isArrayOfTwoItemsOrMore = isArrayOrTypedArray(arrayIn) && arrayIn.length > 1;\n\n  if (isArrayOfTwoItemsOrMore && !isHist && ax.type !== 'category') {\n    var len = arrayIn.length; // given vals are brick centers\n    // hopefully length === numbricks, but use this method even if too few are supplied\n    // and extend it linearly based on the last two points\n\n    if (len <= numbricks) {\n      // contour plots only want the centers\n      if (isContour || isGL2D) arrayOut = arrayIn.slice(0, numbricks);else if (numbricks === 1) {\n        arrayOut = [arrayIn[0] - 0.5, arrayIn[0] + 0.5];\n      } else {\n        arrayOut = [1.5 * arrayIn[0] - 0.5 * arrayIn[1]];\n\n        for (i = 1; i < len; i++) {\n          arrayOut.push((arrayIn[i - 1] + arrayIn[i]) * 0.5);\n        }\n\n        arrayOut.push(1.5 * arrayIn[len - 1] - 0.5 * arrayIn[len - 2]);\n      }\n\n      if (len < numbricks) {\n        var lastPt = arrayOut[arrayOut.length - 1];\n        var delta = lastPt - arrayOut[arrayOut.length - 2];\n\n        for (i = len; i < numbricks; i++) {\n          lastPt += delta;\n          arrayOut.push(lastPt);\n        }\n      }\n    } else {\n      // hopefully length === numbricks+1, but do something regardless:\n      // given vals are brick boundaries\n      return isContour ? arrayIn.slice(0, numbricks) : // we must be strict for contours\n      arrayIn.slice(0, numbricks + 1);\n    }\n  } else {\n    var calendar = trace[ax._id.charAt(0) + 'calendar'];\n\n    if (isHist) {\n      v0 = ax.r2c(v0In, 0, calendar);\n    } else {\n      if (isArrayOrTypedArray(arrayIn) && arrayIn.length === 1) {\n        v0 = arrayIn[0];\n      } else if (v0In === undefined) {\n        v0 = 0;\n      } else {\n        var fn = ax.type === 'log' ? ax.d2c : ax.r2c;\n        v0 = fn(v0In, 0, calendar);\n      }\n    }\n\n    dv = dvIn || 1;\n\n    for (i = isContour || isGL2D ? 0 : -0.5; i < numbricks; i++) {\n      arrayOut.push(v0 + dv * i);\n    }\n  }\n\n  return arrayOut;\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/heatmap/make_bound_array.js"],"names":["Registry","require","isArrayOrTypedArray","module","exports","makeBoundArray","trace","arrayIn","v0In","dvIn","numbricks","ax","arrayOut","isContour","traceIs","isHist","isGL2D","v0","dv","i","isArrayOfTwoItemsOrMore","length","type","len","slice","push","lastPt","delta","calendar","_id","charAt","r2c","undefined","fn","d2c"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nmodule.exports = function makeBoundArray(trace, arrayIn, v0In, dvIn, numbricks, ax) {\n    var arrayOut = [];\n    var isContour = Registry.traceIs(trace, 'contour');\n    var isHist = Registry.traceIs(trace, 'histogram');\n    var isGL2D = Registry.traceIs(trace, 'gl2d');\n    var v0;\n    var dv;\n    var i;\n\n    var isArrayOfTwoItemsOrMore = isArrayOrTypedArray(arrayIn) && arrayIn.length > 1;\n\n    if(isArrayOfTwoItemsOrMore && !isHist && (ax.type !== 'category')) {\n        var len = arrayIn.length;\n\n        // given vals are brick centers\n        // hopefully length === numbricks, but use this method even if too few are supplied\n        // and extend it linearly based on the last two points\n        if(len <= numbricks) {\n            // contour plots only want the centers\n            if(isContour || isGL2D) arrayOut = arrayIn.slice(0, numbricks);\n            else if(numbricks === 1) {\n                arrayOut = [arrayIn[0] - 0.5, arrayIn[0] + 0.5];\n            } else {\n                arrayOut = [1.5 * arrayIn[0] - 0.5 * arrayIn[1]];\n\n                for(i = 1; i < len; i++) {\n                    arrayOut.push((arrayIn[i - 1] + arrayIn[i]) * 0.5);\n                }\n\n                arrayOut.push(1.5 * arrayIn[len - 1] - 0.5 * arrayIn[len - 2]);\n            }\n\n            if(len < numbricks) {\n                var lastPt = arrayOut[arrayOut.length - 1];\n                var delta = lastPt - arrayOut[arrayOut.length - 2];\n\n                for(i = len; i < numbricks; i++) {\n                    lastPt += delta;\n                    arrayOut.push(lastPt);\n                }\n            }\n        } else {\n            // hopefully length === numbricks+1, but do something regardless:\n            // given vals are brick boundaries\n            return isContour ?\n                arrayIn.slice(0, numbricks) :  // we must be strict for contours\n                arrayIn.slice(0, numbricks + 1);\n        }\n    } else {\n        var calendar = trace[ax._id.charAt(0) + 'calendar'];\n\n        if(isHist) {\n            v0 = ax.r2c(v0In, 0, calendar);\n        } else {\n            if(isArrayOrTypedArray(arrayIn) && arrayIn.length === 1) {\n                v0 = arrayIn[0];\n            } else if(v0In === undefined) {\n                v0 = 0;\n            } else {\n                var fn = ax.type === 'log' ? ax.d2c : ax.r2c;\n                v0 = fn(v0In, 0, calendar);\n            }\n        }\n\n        dv = dvIn || 1;\n\n        for(i = (isContour || isGL2D) ? 0 : -0.5; i < numbricks; i++) {\n            arrayOut.push(v0 + dv * i);\n        }\n    }\n\n    return arrayOut;\n};\n"]},"metadata":{},"sourceType":"script"}