{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar Drawing = require('../../components/drawing');\n\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar convertTextOpts = require('../../plots/mapbox/convert_text_opts');\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar NEWLINES = require('../../lib/svg_text_utils').NEWLINES;\n\nvar BR_TAG_ALL = require('../../lib/svg_text_utils').BR_TAG_ALL;\n\nmodule.exports = function convert(gd, calcTrace) {\n  var trace = calcTrace[0].trace;\n  var isVisible = trace.visible === true && trace._length !== 0;\n  var hasFill = trace.fill !== 'none';\n  var hasLines = subTypes.hasLines(trace);\n  var hasMarkers = subTypes.hasMarkers(trace);\n  var hasText = subTypes.hasText(trace);\n  var hasCircles = hasMarkers && trace.marker.symbol === 'circle';\n  var hasSymbols = hasMarkers && trace.marker.symbol !== 'circle';\n  var fill = initContainer();\n  var line = initContainer();\n  var circle = initContainer();\n  var symbol = initContainer();\n  var opts = {\n    fill: fill,\n    line: line,\n    circle: circle,\n    symbol: symbol\n  }; // early return if not visible or placeholder\n\n  if (!isVisible) return opts; // fill layer and line layer use the same coords\n\n  var lineCoords;\n\n  if (hasFill || hasLines) {\n    lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n  }\n\n  if (hasFill) {\n    fill.geojson = geoJsonUtils.makePolygon(lineCoords);\n    fill.layout.visibility = 'visible';\n    Lib.extendFlat(fill.paint, {\n      'fill-color': trace.fillcolor\n    });\n  }\n\n  if (hasLines) {\n    line.geojson = geoJsonUtils.makeLine(lineCoords);\n    line.layout.visibility = 'visible';\n    Lib.extendFlat(line.paint, {\n      'line-width': trace.line.width,\n      'line-color': trace.line.color,\n      'line-opacity': trace.opacity\n    }); // TODO convert line.dash into line-dasharray\n  }\n\n  if (hasCircles) {\n    var circleOpts = makeCircleOpts(calcTrace);\n    circle.geojson = circleOpts.geojson;\n    circle.layout.visibility = 'visible';\n    Lib.extendFlat(circle.paint, {\n      'circle-color': circleOpts.mcc,\n      'circle-radius': circleOpts.mrc,\n      'circle-opacity': circleOpts.mo\n    });\n  }\n\n  if (hasSymbols || hasText) {\n    symbol.geojson = makeSymbolGeoJSON(calcTrace, gd);\n    Lib.extendFlat(symbol.layout, {\n      visibility: 'visible',\n      'icon-image': '{symbol}-15',\n      'text-field': '{text}'\n    });\n\n    if (hasSymbols) {\n      Lib.extendFlat(symbol.layout, {\n        'icon-size': trace.marker.size / 10\n      });\n\n      if ('angle' in trace.marker && trace.marker.angle !== 'auto') {\n        Lib.extendFlat(symbol.layout, {\n          // unfortunately cant use {angle} do to this issue:\n          // https://github.com/mapbox/mapbox-gl-js/issues/873\n          'icon-rotate': {\n            type: 'identity',\n            property: 'angle'\n          },\n          'icon-rotation-alignment': 'map'\n        });\n      }\n\n      symbol.layout['icon-allow-overlap'] = trace.marker.allowoverlap;\n      Lib.extendFlat(symbol.paint, {\n        'icon-opacity': trace.opacity * trace.marker.opacity,\n        // TODO does not work ??\n        'icon-color': trace.marker.color\n      });\n    }\n\n    if (hasText) {\n      var iconSize = (trace.marker || {}).size;\n      var textOpts = convertTextOpts(trace.textposition, iconSize); // all data-driven below !!\n\n      Lib.extendFlat(symbol.layout, {\n        'text-size': trace.textfont.size,\n        'text-anchor': textOpts.anchor,\n        'text-offset': textOpts.offset // TODO font family\n        // 'text-font': symbol.textfont.family.split(', '),\n\n      });\n      Lib.extendFlat(symbol.paint, {\n        'text-color': trace.textfont.color,\n        'text-opacity': trace.opacity\n      });\n    }\n  }\n\n  return opts;\n};\n\nfunction initContainer() {\n  return {\n    geojson: geoJsonUtils.makeBlank(),\n    layout: {\n      visibility: 'none'\n    },\n    paint: {}\n  };\n}\n\nfunction makeCircleOpts(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var marker = trace.marker;\n  var selectedpoints = trace.selectedpoints;\n  var arrayColor = Lib.isArrayOrTypedArray(marker.color);\n  var arraySize = Lib.isArrayOrTypedArray(marker.size);\n  var arrayOpacity = Lib.isArrayOrTypedArray(marker.opacity);\n  var i;\n\n  function addTraceOpacity(o) {\n    return trace.opacity * o;\n  }\n\n  function size2radius(s) {\n    return s / 2;\n  }\n\n  var colorFn;\n\n  if (arrayColor) {\n    if (Colorscale.hasColorscale(trace, 'marker')) {\n      colorFn = Colorscale.makeColorScaleFuncFromTrace(marker);\n    } else {\n      colorFn = Lib.identity;\n    }\n  }\n\n  var sizeFn;\n\n  if (arraySize) {\n    sizeFn = makeBubbleSizeFn(trace);\n  }\n\n  var opacityFn;\n\n  if (arrayOpacity) {\n    opacityFn = function (mo) {\n      var mo2 = isNumeric(mo) ? +Lib.constrain(mo, 0, 1) : 0;\n      return addTraceOpacity(mo2);\n    };\n  }\n\n  var features = [];\n\n  for (i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    var lonlat = calcPt.lonlat;\n    if (isBADNUM(lonlat)) continue;\n    var props = {};\n    if (colorFn) props.mcc = calcPt.mcc = colorFn(calcPt.mc);\n    if (sizeFn) props.mrc = calcPt.mrc = sizeFn(calcPt.ms);\n    if (opacityFn) props.mo = opacityFn(calcPt.mo);\n    if (selectedpoints) props.selected = calcPt.selected || 0;\n    features.push({\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: lonlat\n      },\n      properties: props\n    });\n  }\n\n  var fns;\n\n  if (selectedpoints) {\n    fns = Drawing.makeSelectedPointStyleFns(trace);\n\n    for (i = 0; i < features.length; i++) {\n      var d = features[i].properties;\n\n      if (fns.selectedOpacityFn) {\n        d.mo = addTraceOpacity(fns.selectedOpacityFn(d));\n      }\n\n      if (fns.selectedColorFn) {\n        d.mcc = fns.selectedColorFn(d);\n      }\n\n      if (fns.selectedSizeFn) {\n        d.mrc = fns.selectedSizeFn(d);\n      }\n    }\n  }\n\n  return {\n    geojson: {\n      type: 'FeatureCollection',\n      features: features\n    },\n    mcc: arrayColor || fns && fns.selectedColorFn ? {\n      type: 'identity',\n      property: 'mcc'\n    } : marker.color,\n    mrc: arraySize || fns && fns.selectedSizeFn ? {\n      type: 'identity',\n      property: 'mrc'\n    } : size2radius(marker.size),\n    mo: arrayOpacity || fns && fns.selectedOpacityFn ? {\n      type: 'identity',\n      property: 'mo'\n    } : addTraceOpacity(marker.opacity)\n  };\n}\n\nfunction makeSymbolGeoJSON(calcTrace, gd) {\n  var fullLayout = gd._fullLayout;\n  var trace = calcTrace[0].trace;\n  var marker = trace.marker || {};\n  var symbol = marker.symbol;\n  var angle = marker.angle;\n  var fillSymbol = symbol !== 'circle' ? getFillFunc(symbol) : blankFillFunc;\n  var fillAngle = angle !== 'auto' ? getFillFunc(angle, true) : blankFillFunc;\n  var fillText = subTypes.hasText(trace) ? getFillFunc(trace.text) : blankFillFunc;\n  var features = [];\n\n  for (var i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    if (isBADNUM(calcPt.lonlat)) continue;\n    var texttemplate = trace.texttemplate;\n    var text;\n\n    if (texttemplate) {\n      var tt = Array.isArray(texttemplate) ? texttemplate[i] || '' : texttemplate;\n\n      var labels = trace._module.formatLabels(calcPt, trace, fullLayout);\n\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, calcPt.i);\n      var meta = trace._meta || {};\n      text = Lib.texttemplateString(tt, labels, fullLayout._d3locale, pointValues, calcPt, meta);\n    } else {\n      text = fillText(i);\n    }\n\n    if (text) {\n      text = text.replace(NEWLINES, '').replace(BR_TAG_ALL, '\\n');\n    }\n\n    features.push({\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: calcPt.lonlat\n      },\n      properties: {\n        symbol: fillSymbol(i),\n        angle: fillAngle(i),\n        text: text\n      }\n    });\n  }\n\n  return {\n    type: 'FeatureCollection',\n    features: features\n  };\n}\n\nfunction getFillFunc(attr, numeric) {\n  if (Lib.isArrayOrTypedArray(attr)) {\n    if (numeric) {\n      return function (i) {\n        return isNumeric(attr[i]) ? +attr[i] : 0;\n      };\n    }\n\n    return function (i) {\n      return attr[i];\n    };\n  } else if (attr) {\n    return function () {\n      return attr;\n    };\n  } else {\n    return blankFillFunc;\n  }\n}\n\nfunction blankFillFunc() {\n  return '';\n} // only need to check lon (OR lat)\n\n\nfunction isBADNUM(lonlat) {\n  return lonlat[0] === BADNUM;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/scattermapbox/convert.js"],"names":["isNumeric","require","Lib","BADNUM","geoJsonUtils","Colorscale","Drawing","makeBubbleSizeFn","subTypes","convertTextOpts","appendArrayPointValue","NEWLINES","BR_TAG_ALL","module","exports","convert","gd","calcTrace","trace","isVisible","visible","_length","hasFill","fill","hasLines","hasMarkers","hasText","hasCircles","marker","symbol","hasSymbols","initContainer","line","circle","opts","lineCoords","calcTraceToLineCoords","geojson","makePolygon","layout","visibility","extendFlat","paint","fillcolor","makeLine","width","color","opacity","circleOpts","makeCircleOpts","mcc","mrc","mo","makeSymbolGeoJSON","size","angle","type","property","allowoverlap","iconSize","textOpts","textposition","textfont","anchor","offset","makeBlank","selectedpoints","arrayColor","isArrayOrTypedArray","arraySize","arrayOpacity","i","addTraceOpacity","o","size2radius","s","colorFn","hasColorscale","makeColorScaleFuncFromTrace","identity","sizeFn","opacityFn","mo2","constrain","features","length","calcPt","lonlat","isBADNUM","props","mc","ms","selected","push","geometry","coordinates","properties","fns","makeSelectedPointStyleFns","d","selectedOpacityFn","selectedColorFn","selectedSizeFn","fullLayout","_fullLayout","fillSymbol","getFillFunc","blankFillFunc","fillAngle","fillText","text","texttemplate","tt","Array","isArray","labels","_module","formatLabels","pointValues","meta","_meta","texttemplateString","_d3locale","replace","attr","numeric"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar Colorscale = require('../../components/colorscale');\nvar Drawing = require('../../components/drawing');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\nvar subTypes = require('../scatter/subtypes');\nvar convertTextOpts = require('../../plots/mapbox/convert_text_opts');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar NEWLINES = require('../../lib/svg_text_utils').NEWLINES;\nvar BR_TAG_ALL = require('../../lib/svg_text_utils').BR_TAG_ALL;\n\nmodule.exports = function convert(gd, calcTrace) {\n    var trace = calcTrace[0].trace;\n\n    var isVisible = (trace.visible === true && trace._length !== 0);\n    var hasFill = (trace.fill !== 'none');\n    var hasLines = subTypes.hasLines(trace);\n    var hasMarkers = subTypes.hasMarkers(trace);\n    var hasText = subTypes.hasText(trace);\n    var hasCircles = (hasMarkers && trace.marker.symbol === 'circle');\n    var hasSymbols = (hasMarkers && trace.marker.symbol !== 'circle');\n\n    var fill = initContainer();\n    var line = initContainer();\n    var circle = initContainer();\n    var symbol = initContainer();\n\n    var opts = {\n        fill: fill,\n        line: line,\n        circle: circle,\n        symbol: symbol\n    };\n\n    // early return if not visible or placeholder\n    if(!isVisible) return opts;\n\n    // fill layer and line layer use the same coords\n    var lineCoords;\n    if(hasFill || hasLines) {\n        lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n    }\n\n    if(hasFill) {\n        fill.geojson = geoJsonUtils.makePolygon(lineCoords);\n        fill.layout.visibility = 'visible';\n\n        Lib.extendFlat(fill.paint, {\n            'fill-color': trace.fillcolor\n        });\n    }\n\n    if(hasLines) {\n        line.geojson = geoJsonUtils.makeLine(lineCoords);\n        line.layout.visibility = 'visible';\n\n        Lib.extendFlat(line.paint, {\n            'line-width': trace.line.width,\n            'line-color': trace.line.color,\n            'line-opacity': trace.opacity\n        });\n\n        // TODO convert line.dash into line-dasharray\n    }\n\n    if(hasCircles) {\n        var circleOpts = makeCircleOpts(calcTrace);\n        circle.geojson = circleOpts.geojson;\n        circle.layout.visibility = 'visible';\n\n        Lib.extendFlat(circle.paint, {\n            'circle-color': circleOpts.mcc,\n            'circle-radius': circleOpts.mrc,\n            'circle-opacity': circleOpts.mo\n        });\n    }\n\n    if(hasSymbols || hasText) {\n        symbol.geojson = makeSymbolGeoJSON(calcTrace, gd);\n\n        Lib.extendFlat(symbol.layout, {\n            visibility: 'visible',\n            'icon-image': '{symbol}-15',\n            'text-field': '{text}'\n        });\n\n        if(hasSymbols) {\n            Lib.extendFlat(symbol.layout, {\n                'icon-size': trace.marker.size / 10\n            });\n\n            if('angle' in trace.marker && trace.marker.angle !== 'auto') {\n                Lib.extendFlat(symbol.layout, {\n                // unfortunately cant use {angle} do to this issue:\n                // https://github.com/mapbox/mapbox-gl-js/issues/873\n                    'icon-rotate': {\n                        type: 'identity', property: 'angle'\n                    },\n                    'icon-rotation-alignment': 'map'\n                });\n            }\n\n            symbol.layout['icon-allow-overlap'] = trace.marker.allowoverlap;\n\n            Lib.extendFlat(symbol.paint, {\n                'icon-opacity': trace.opacity * trace.marker.opacity,\n\n                // TODO does not work ??\n                'icon-color': trace.marker.color\n            });\n        }\n\n        if(hasText) {\n            var iconSize = (trace.marker || {}).size;\n            var textOpts = convertTextOpts(trace.textposition, iconSize);\n\n            // all data-driven below !!\n\n            Lib.extendFlat(symbol.layout, {\n                'text-size': trace.textfont.size,\n                'text-anchor': textOpts.anchor,\n                'text-offset': textOpts.offset\n\n                // TODO font family\n                // 'text-font': symbol.textfont.family.split(', '),\n            });\n\n            Lib.extendFlat(symbol.paint, {\n                'text-color': trace.textfont.color,\n                'text-opacity': trace.opacity\n            });\n        }\n    }\n\n    return opts;\n};\n\nfunction initContainer() {\n    return {\n        geojson: geoJsonUtils.makeBlank(),\n        layout: { visibility: 'none' },\n        paint: {}\n    };\n}\n\nfunction makeCircleOpts(calcTrace) {\n    var trace = calcTrace[0].trace;\n    var marker = trace.marker;\n    var selectedpoints = trace.selectedpoints;\n    var arrayColor = Lib.isArrayOrTypedArray(marker.color);\n    var arraySize = Lib.isArrayOrTypedArray(marker.size);\n    var arrayOpacity = Lib.isArrayOrTypedArray(marker.opacity);\n    var i;\n\n    function addTraceOpacity(o) { return trace.opacity * o; }\n\n    function size2radius(s) { return s / 2; }\n\n    var colorFn;\n    if(arrayColor) {\n        if(Colorscale.hasColorscale(trace, 'marker')) {\n            colorFn = Colorscale.makeColorScaleFuncFromTrace(marker);\n        } else {\n            colorFn = Lib.identity;\n        }\n    }\n\n    var sizeFn;\n    if(arraySize) {\n        sizeFn = makeBubbleSizeFn(trace);\n    }\n\n    var opacityFn;\n    if(arrayOpacity) {\n        opacityFn = function(mo) {\n            var mo2 = isNumeric(mo) ? +Lib.constrain(mo, 0, 1) : 0;\n            return addTraceOpacity(mo2);\n        };\n    }\n\n    var features = [];\n    for(i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i];\n        var lonlat = calcPt.lonlat;\n\n        if(isBADNUM(lonlat)) continue;\n\n        var props = {};\n        if(colorFn) props.mcc = calcPt.mcc = colorFn(calcPt.mc);\n        if(sizeFn) props.mrc = calcPt.mrc = sizeFn(calcPt.ms);\n        if(opacityFn) props.mo = opacityFn(calcPt.mo);\n        if(selectedpoints) props.selected = calcPt.selected || 0;\n\n        features.push({\n            type: 'Feature',\n            geometry: {type: 'Point', coordinates: lonlat},\n            properties: props\n        });\n    }\n\n    var fns;\n    if(selectedpoints) {\n        fns = Drawing.makeSelectedPointStyleFns(trace);\n\n        for(i = 0; i < features.length; i++) {\n            var d = features[i].properties;\n\n            if(fns.selectedOpacityFn) {\n                d.mo = addTraceOpacity(fns.selectedOpacityFn(d));\n            }\n            if(fns.selectedColorFn) {\n                d.mcc = fns.selectedColorFn(d);\n            }\n            if(fns.selectedSizeFn) {\n                d.mrc = fns.selectedSizeFn(d);\n            }\n        }\n    }\n\n    return {\n        geojson: {type: 'FeatureCollection', features: features},\n        mcc: arrayColor || (fns && fns.selectedColorFn) ?\n            {type: 'identity', property: 'mcc'} :\n            marker.color,\n        mrc: arraySize || (fns && fns.selectedSizeFn) ?\n            {type: 'identity', property: 'mrc'} :\n            size2radius(marker.size),\n        mo: arrayOpacity || (fns && fns.selectedOpacityFn) ?\n            {type: 'identity', property: 'mo'} :\n            addTraceOpacity(marker.opacity)\n    };\n}\n\nfunction makeSymbolGeoJSON(calcTrace, gd) {\n    var fullLayout = gd._fullLayout;\n    var trace = calcTrace[0].trace;\n\n    var marker = trace.marker || {};\n    var symbol = marker.symbol;\n    var angle = marker.angle;\n\n    var fillSymbol = (symbol !== 'circle') ?\n        getFillFunc(symbol) :\n        blankFillFunc;\n\n    var fillAngle = (angle !== 'auto') ?\n        getFillFunc(angle, true) :\n        blankFillFunc;\n\n    var fillText = subTypes.hasText(trace) ?\n        getFillFunc(trace.text) :\n        blankFillFunc;\n\n\n    var features = [];\n\n    for(var i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i];\n\n        if(isBADNUM(calcPt.lonlat)) continue;\n\n        var texttemplate = trace.texttemplate;\n        var text;\n\n        if(texttemplate) {\n            var tt = Array.isArray(texttemplate) ? (texttemplate[i] || '') : texttemplate;\n            var labels = trace._module.formatLabels(calcPt, trace, fullLayout);\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, calcPt.i);\n            var meta = trace._meta || {};\n            text = Lib.texttemplateString(tt, labels, fullLayout._d3locale, pointValues, calcPt, meta);\n        } else {\n            text = fillText(i);\n        }\n\n        if(text) {\n            text = text.replace(NEWLINES, '').replace(BR_TAG_ALL, '\\n');\n        }\n\n        features.push({\n            type: 'Feature',\n            geometry: {\n                type: 'Point',\n                coordinates: calcPt.lonlat\n            },\n            properties: {\n                symbol: fillSymbol(i),\n                angle: fillAngle(i),\n                text: text\n            }\n        });\n    }\n\n    return {\n        type: 'FeatureCollection',\n        features: features\n    };\n}\n\nfunction getFillFunc(attr, numeric) {\n    if(Lib.isArrayOrTypedArray(attr)) {\n        if(numeric) {\n            return function(i) { return isNumeric(attr[i]) ? +attr[i] : 0; };\n        }\n        return function(i) { return attr[i]; };\n    } else if(attr) {\n        return function() { return attr; };\n    } else {\n        return blankFillFunc;\n    }\n}\n\nfunction blankFillFunc() { return ''; }\n\n// only need to check lon (OR lat)\nfunction isBADNUM(lonlat) {\n    return lonlat[0] === BADNUM;\n}\n"]},"metadata":{},"sourceType":"script"}