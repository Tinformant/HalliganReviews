{"ast":null,"code":"\"use strict\";\n\nmodule.exports = axesProperties;\n\nvar getPlanes = require(\"extract-frustum-planes\");\n\nvar splitPoly = require(\"split-polygon\");\n\nvar cubeParams = require(\"./lib/cube.js\");\n\nvar m4mul = require(\"gl-mat4/multiply\");\n\nvar m4transpose = require(\"gl-mat4/transpose\");\n\nvar v4transformMat4 = require(\"gl-vec4/transformMat4\");\n\nvar identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nvar mvp = new Float32Array(16);\n\nfunction AxesRange3D(lo, hi, pixelsPerDataUnit) {\n  this.lo = lo;\n  this.hi = hi;\n  this.pixelsPerDataUnit = pixelsPerDataUnit;\n}\n\nvar SCRATCH_P = [0, 0, 0, 1];\nvar SCRATCH_Q = [0, 0, 0, 1];\n\nfunction gradient(result, M, v, width, height) {\n  for (var i = 0; i < 3; ++i) {\n    var p = SCRATCH_P;\n    var q = SCRATCH_Q;\n\n    for (var j = 0; j < 3; ++j) {\n      q[j] = p[j] = v[j];\n    }\n\n    q[3] = p[3] = 1;\n    q[i] += 1;\n    v4transformMat4(q, q, M);\n\n    if (q[3] < 0) {\n      result[i] = Infinity;\n    }\n\n    p[i] -= 1;\n    v4transformMat4(p, p, M);\n\n    if (p[3] < 0) {\n      result[i] = Infinity;\n    }\n\n    var dx = (p[0] / p[3] - q[0] / q[3]) * width;\n    var dy = (p[1] / p[3] - q[1] / q[3]) * height;\n    result[i] = 0.25 * Math.sqrt(dx * dx + dy * dy);\n  }\n\n  return result;\n}\n\nvar RANGES = [new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity)];\nvar SCRATCH_X = [0, 0, 0];\n\nfunction axesProperties(axes, camera, width, height, params) {\n  var model = camera.model || identity;\n  var view = camera.view || identity;\n  var projection = camera.projection || identity;\n  var isOrtho = camera._ortho || false;\n  var bounds = axes.bounds;\n  var params = params || cubeParams(model, view, projection, bounds, isOrtho);\n  var axis = params.axis;\n  m4mul(mvp, view, model);\n  m4mul(mvp, projection, mvp); //Calculate the following properties for each axis:\n  //\n  // * lo - start of visible range for each axis in tick coordinates\n  // * hi - end of visible range for each axis in tick coordinates\n  // * ticksPerPixel - pixel density of tick marks for the axis\n  //\n\n  var ranges = RANGES;\n\n  for (var i = 0; i < 3; ++i) {\n    ranges[i].lo = Infinity;\n    ranges[i].hi = -Infinity;\n    ranges[i].pixelsPerDataUnit = Infinity;\n  } //Compute frustum planes, intersect with box\n\n\n  var frustum = getPlanes(m4transpose(mvp, mvp));\n  m4transpose(mvp, mvp); //Loop over vertices of viewable box\n\n  for (var d = 0; d < 3; ++d) {\n    var u = (d + 1) % 3;\n    var v = (d + 2) % 3;\n    var x = SCRATCH_X;\n\n    i_loop: for (var i = 0; i < 2; ++i) {\n      var poly = [];\n\n      if (axis[d] < 0 === !!i) {\n        continue;\n      }\n\n      x[d] = bounds[i][d];\n\n      for (var j = 0; j < 2; ++j) {\n        x[u] = bounds[j ^ i][u];\n\n        for (var k = 0; k < 2; ++k) {\n          x[v] = bounds[k ^ j ^ i][v];\n          poly.push(x.slice());\n        }\n      }\n\n      var Q = isOrtho ? 5 : 4;\n\n      for (var j = Q; j === Q; ++j) {\n        // Note: using only near plane here (& for orthographic projection we use the far).\n        if (poly.length === 0) {\n          continue i_loop;\n        }\n\n        poly = splitPoly.positive(poly, frustum[j]);\n      } //Loop over vertices of polygon to find extremal points\n\n\n      for (var j = 0; j < poly.length; ++j) {\n        var v = poly[j];\n        var grad = gradient(SCRATCH_X, mvp, v, width, height);\n\n        for (var k = 0; k < 3; ++k) {\n          ranges[k].lo = Math.min(ranges[k].lo, v[k]);\n          ranges[k].hi = Math.max(ranges[k].hi, v[k]);\n\n          if (k !== d) {\n            ranges[k].pixelsPerDataUnit = Math.min(ranges[k].pixelsPerDataUnit, Math.abs(grad[k]));\n          }\n        }\n      }\n    }\n  }\n\n  return ranges;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/gl-axes3d/properties.js"],"names":["module","exports","axesProperties","getPlanes","require","splitPoly","cubeParams","m4mul","m4transpose","v4transformMat4","identity","Float32Array","mvp","AxesRange3D","lo","hi","pixelsPerDataUnit","SCRATCH_P","SCRATCH_Q","gradient","result","M","v","width","height","i","p","q","j","Infinity","dx","dy","Math","sqrt","RANGES","SCRATCH_X","axes","camera","params","model","view","projection","isOrtho","_ortho","bounds","axis","ranges","frustum","d","u","x","i_loop","poly","k","push","slice","Q","length","positive","grad","min","max","abs"],"mappings":"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","sourcesContent":["\"use strict\"\n\nmodule.exports = axesProperties\n\nvar getPlanes   = require(\"extract-frustum-planes\")\nvar splitPoly   = require(\"split-polygon\")\nvar cubeParams  = require(\"./lib/cube.js\")\nvar m4mul       = require(\"gl-mat4/multiply\")\nvar m4transpose = require(\"gl-mat4/transpose\")\nvar v4transformMat4 = require(\"gl-vec4/transformMat4\")\n\nvar identity    = new Float32Array([\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  ])\n\nvar mvp         = new Float32Array(16)\n\nfunction AxesRange3D(lo, hi, pixelsPerDataUnit) {\n  this.lo = lo\n  this.hi = hi\n  this.pixelsPerDataUnit = pixelsPerDataUnit\n}\n\nvar SCRATCH_P = [0,0,0,1]\nvar SCRATCH_Q = [0,0,0,1]\n\nfunction gradient(result, M, v, width, height) {\n  for(var i=0; i<3; ++i) {\n    var p = SCRATCH_P\n    var q = SCRATCH_Q\n    for(var j=0; j<3; ++j) {\n      q[j] = p[j] = v[j]\n    }\n    q[3] = p[3] = 1\n\n    q[i] += 1\n    v4transformMat4(q, q, M)\n    if(q[3] < 0) {\n      result[i] = Infinity\n    }\n\n    p[i] -= 1\n    v4transformMat4(p, p, M)\n    if(p[3] < 0) {\n      result[i] = Infinity\n    }\n\n    var dx = (p[0]/p[3] - q[0]/q[3]) * width\n    var dy = (p[1]/p[3] - q[1]/q[3]) * height\n\n    result[i] = 0.25 * Math.sqrt(dx*dx + dy*dy)\n  }\n  return result\n}\n\nvar RANGES = [\n  new AxesRange3D(Infinity, -Infinity, Infinity),\n  new AxesRange3D(Infinity, -Infinity, Infinity),\n  new AxesRange3D(Infinity, -Infinity, Infinity)\n]\n\nvar SCRATCH_X = [0,0,0]\n\nfunction axesProperties(axes, camera, width, height, params) {\n  var model       = camera.model || identity\n  var view        = camera.view || identity\n  var projection  = camera.projection || identity\n  var isOrtho     = camera._ortho || false\n  var bounds      = axes.bounds\n  var params      = params || cubeParams(model, view, projection, bounds, isOrtho)\n  var axis        = params.axis\n\n  m4mul(mvp, view, model)\n  m4mul(mvp, projection, mvp)\n\n  //Calculate the following properties for each axis:\n  //\n  // * lo - start of visible range for each axis in tick coordinates\n  // * hi - end of visible range for each axis in tick coordinates\n  // * ticksPerPixel - pixel density of tick marks for the axis\n  //\n  var ranges = RANGES\n  for(var i=0; i<3; ++i) {\n    ranges[i].lo = Infinity\n    ranges[i].hi = -Infinity\n    ranges[i].pixelsPerDataUnit = Infinity\n  }\n\n  //Compute frustum planes, intersect with box\n  var frustum = getPlanes(m4transpose(mvp, mvp))\n  m4transpose(mvp, mvp)\n\n  //Loop over vertices of viewable box\n  for(var d=0; d<3; ++d) {\n    var u = (d+1)%3\n    var v = (d+2)%3\n    var x = SCRATCH_X\ni_loop:\n    for(var i=0; i<2; ++i) {\n      var poly = []\n\n      if((axis[d] < 0) === !!i) {\n        continue\n      }\n\n      x[d] = bounds[i][d]\n      for(var j=0; j<2; ++j) {\n        x[u] = bounds[j^i][u]\n        for(var k=0; k<2; ++k) {\n          x[v] = bounds[k^j^i][v]\n          poly.push(x.slice())\n        }\n      }\n\n      var Q = (isOrtho) ? 5 : 4\n      for(var j=Q; j===Q; ++j) { // Note: using only near plane here (& for orthographic projection we use the far).\n        if(poly.length === 0) {\n          continue i_loop\n        }\n        poly = splitPoly.positive(poly, frustum[j])\n      }\n\n      //Loop over vertices of polygon to find extremal points\n      for(var j=0; j<poly.length; ++j) {\n        var v = poly[j]\n        var grad = gradient(SCRATCH_X, mvp, v, width, height)\n        for(var k=0; k<3; ++k) {\n          ranges[k].lo = Math.min(ranges[k].lo, v[k])\n          ranges[k].hi = Math.max(ranges[k].hi, v[k])\n          if(k !== d) {\n            ranges[k].pixelsPerDataUnit = Math.min(ranges[k].pixelsPerDataUnit, Math.abs(grad[k]))\n          }\n        }\n      }\n    }\n  }\n\n  return ranges\n}\n"]},"metadata":{},"sourceType":"script"}