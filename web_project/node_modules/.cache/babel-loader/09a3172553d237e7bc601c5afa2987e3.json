{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar uniformText = require('../bar/uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar piePlot = require('../pie/plot');\n\nvar computeTransform = piePlot.computeTransform;\nvar transformInsideText = piePlot.transformInsideText;\n\nvar styleOne = require('./style').styleOne;\n\nvar resizeText = require('../bar/style').resizeText;\n\nvar attachFxHandlers = require('./fx');\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers');\n\nexports.plot = function (gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var layer = fullLayout._sunburstlayer;\n  var join, onComplete; // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n\n  var isFullReplot = !transitionOpts;\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  clearMinTextSize('sunburst', fullLayout);\n  join = layer.selectAll('g.trace.sunburst').data(cdmodule, function (cd) {\n    return cd[0].trace.uid;\n  }); // using same 'stroke-linejoin' as pie traces\n\n  join.enter().append('g').classed('trace', true).classed('sunburst', true).attr('stroke-linejoin', 'round');\n  join.order();\n\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      layer.selectAll('g.trace').each(function (cd) {\n        plotOne(gd, cd, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (cd) {\n      plotOne(gd, cd, this, transitionOpts);\n    });\n\n    if (fullLayout.uniformtext.mode) {\n      resizeText(gd, fullLayout._sunburstlayer.selectAll('.trace'), 'sunburst');\n    }\n  }\n\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n};\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n  var fullLayout = gd._fullLayout;\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  var gTrace = d3.select(element);\n  var slices = gTrace.selectAll('g.slice');\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var maxDepth = helpers.getMaxDepth(trace);\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var rMax = 0.5 * Math.min(vpw, vph);\n  var cx = cd0.cx = gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cy = cd0.cy = gs.t + gs.h * (1 - domain.y[0]) - vph / 2;\n\n  if (!entry) {\n    return slices.remove();\n  } // previous root 'pt' (can be empty)\n\n\n  var prevEntry = null; // stash of 'previous' position data used by tweening functions\n\n  var prevLookup = {};\n\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    slices.each(function (pt) {\n      prevLookup[helpers.getPtId(pt)] = {\n        rpx0: pt.rpx0,\n        rpx1: pt.rpx1,\n        x0: pt.x0,\n        x1: pt.x1,\n        transform: pt.transform\n      };\n\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  } // N.B. slice data isn't the calcdata,\n  // grab corresponding calcdata item in sliceData[i].data.data\n\n\n  var sliceData = partition(entry).descendants();\n  var maxHeight = entry.height + 1;\n  var yOffset = 0;\n  var cutoff = maxDepth; // N.B. handle multiple-root special case\n\n  if (cd0.hasMultipleRoots && helpers.isHierarchyRoot(entry)) {\n    sliceData = sliceData.slice(1);\n    maxHeight -= 1;\n    yOffset = 1;\n    cutoff += 1;\n  } // filter out slices that won't show up on graph\n\n\n  sliceData = sliceData.filter(function (pt) {\n    return pt.y1 <= cutoff;\n  }); // partition span ('y') to sector radial px value\n\n  var maxY = Math.min(maxHeight, maxDepth);\n\n  var y2rpx = function (y) {\n    return (y - yOffset) / maxY * rMax;\n  }; // (radial px value, partition angle ('x'))  to px [x,y]\n\n\n  var rx2px = function (r, x) {\n    return [r * Math.cos(x), -r * Math.sin(x)];\n  }; // slice path generation fn\n\n\n  var pathSlice = function (d) {\n    return Lib.pathAnnulus(d.rpx0, d.rpx1, d.x0, d.x1, cx, cy);\n  }; // slice text translate x/y\n\n\n  var getTargetX = function (d) {\n    return cx + getTextXY(d)[0] * (d.transform.rCenter || 0) + (d.transform.x || 0);\n  };\n\n  var getTargetY = function (d) {\n    return cy + getTextXY(d)[1] * (d.transform.rCenter || 0) + (d.transform.y || 0);\n  };\n\n  slices = slices.data(sliceData, helpers.getPtId);\n  slices.enter().append('g').classed('slice', true);\n\n  if (hasTransition) {\n    slices.exit().transition().each(function () {\n      var sliceTop = d3.select(this);\n      var slicePath = sliceTop.select('path.surface');\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeExitSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n      var sliceTextGroup = sliceTop.select('g.slicetext');\n      sliceTextGroup.attr('opacity', 0);\n    }).remove();\n  } else {\n    slices.exit().remove();\n  }\n\n  slices.order(); // next x1 (i.e. sector end angle) of previous entry\n\n  var nextX1ofPrevEntry = null;\n\n  if (hasTransition && prevEntry) {\n    var prevEntryId = helpers.getPtId(prevEntry);\n    slices.each(function (pt) {\n      if (nextX1ofPrevEntry === null && helpers.getPtId(pt) === prevEntryId) {\n        nextX1ofPrevEntry = pt.x1;\n      }\n    });\n  }\n\n  var updateSlices = slices;\n\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: true,\n        hideOnLeaves: true,\n        isTransitioning: false\n      });\n    });\n  }\n\n  updateSlices.each(function (pt) {\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', 'all');\n    });\n    pt.rpx0 = y2rpx(pt.y0);\n    pt.rpx1 = y2rpx(pt.y1);\n    pt.xmid = (pt.x0 + pt.x1) / 2;\n    pt.pxmid = rx2px(pt.rpx1, pt.xmid);\n    pt.midangle = -(pt.xmid - Math.PI / 2);\n    pt.startangle = -(pt.x0 - Math.PI / 2);\n    pt.stopangle = -(pt.x1 - Math.PI / 2);\n    pt.halfangle = 0.5 * Math.min(Lib.angleDelta(pt.x0, pt.x1) || Math.PI, Math.PI);\n    pt.ring = 1 - pt.rpx0 / pt.rpx1;\n    pt.rInscribed = getInscribedRadiusFraction(pt, trace);\n\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      hideOnRoot: true,\n      hideOnLeaves: true,\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace);\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n    sliceText.text(exports.formatSliceLabel(pt, entry, trace, cd, fullLayout)).classed('slicetext', true).attr('text-anchor', 'middle').call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd); // position the text relative to the slice\n\n    var textBB = Drawing.bBox(sliceText.node());\n    pt.transform = transformInsideText(textBB, pt, cd0);\n    pt.transform.targetX = getTargetX(pt);\n    pt.transform.targetY = getTargetY(pt);\n\n    var strTransform = function (d, textBB) {\n      var transform = d.transform;\n      computeTransform(transform, textBB);\n      transform.fontSize = font.size;\n      recordMinTextSize(trace.type, transform, fullLayout);\n      return Lib.getTextTransform(transform);\n    };\n\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2);\n        return function (t) {\n          return strTransform(interp(t), textBB);\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt, textBB));\n    }\n  });\n\n  function makeExitSliceInterpolator(pt) {\n    var id = helpers.getPtId(pt);\n    var prev = prevLookup[id];\n    var entryPrev = prevLookup[helpers.getPtId(entry)];\n    var next;\n\n    if (entryPrev) {\n      var a = pt.x1 > entryPrev.x1 ? 2 * Math.PI : 0; // if pt to remove:\n      // - if 'below' where the root-node used to be: shrink it radially inward\n      // - otherwise, collapse it clockwise or counterclockwise which ever is shortest to theta=0\n\n      next = pt.rpx1 < entryPrev.rpx1 ? {\n        rpx0: 0,\n        rpx1: 0\n      } : {\n        x0: a,\n        x1: a\n      };\n    } else {\n      // this happens when maxdepth is set, when leaves must\n      // be removed and the rootPt is new (i.e. does not have a 'prev' object)\n      var parent;\n      var parentId = helpers.getPtId(pt.parent);\n      slices.each(function (pt2) {\n        if (helpers.getPtId(pt2) === parentId) {\n          return parent = pt2;\n        }\n      });\n      var parentChildren = parent.children;\n      var ci;\n      parentChildren.forEach(function (pt2, i) {\n        if (helpers.getPtId(pt2) === id) {\n          return ci = i;\n        }\n      });\n      var n = parentChildren.length;\n      var interp = d3.interpolate(parent.x0, parent.x1);\n      next = {\n        rpx0: rMax,\n        rpx1: rMax,\n        x0: interp(ci / n),\n        x1: interp((ci + 1) / n)\n      };\n    }\n\n    return d3.interpolate(prev, next);\n  }\n\n  function makeUpdateSliceInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var next = {\n      x0: pt.x0,\n      x1: pt.x1,\n      rpx0: pt.rpx0,\n      rpx1: pt.rpx1\n    };\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n            prev = {\n              x0: a,\n              x1: a\n            };\n          } else {\n            // if new leaf (when maxdepth is set),\n            // grow it radially and angularly from\n            // its parent node\n            prev = {\n              rpx0: rMax,\n              rpx1: rMax\n            };\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node, grow it radially\n          prev = {\n            rpx0: 0,\n            rpx1: 0\n          };\n        }\n      } else {\n        // start sector of new traces from theta=0\n        prev = {\n          x0: 0,\n          x1: 0\n        };\n      }\n    }\n\n    return d3.interpolate(prev, next);\n  }\n\n  function makeUpdateTextInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var transform = pt.transform;\n\n    if (prev0) {\n      prev = prev0;\n    } else {\n      prev = {\n        rpx1: pt.rpx1,\n        transform: {\n          textPosAngle: transform.textPosAngle,\n          scale: 0,\n          rotate: transform.rotate,\n          rCenter: transform.rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      }; // for new pts:\n\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n            prev.x0 = prev.x1 = a;\n          } else {\n            // if leaf\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node\n          prev.x0 = prev.x1 = 0;\n        }\n      } else {\n        // on new traces\n        prev.x0 = prev.x1 = 0;\n      }\n    }\n\n    var textPosAngleFn = d3.interpolate(prev.transform.textPosAngle, pt.transform.textPosAngle);\n    var rpx1Fn = d3.interpolate(prev.rpx1, pt.rpx1);\n    var x0Fn = d3.interpolate(prev.x0, pt.x0);\n    var x1Fn = d3.interpolate(prev.x1, pt.x1);\n    var scaleFn = d3.interpolate(prev.transform.scale, transform.scale);\n    var rotateFn = d3.interpolate(prev.transform.rotate, transform.rotate); // smooth out start/end from entry, to try to keep text inside sector\n    // while keeping transition smooth\n\n    var pow = transform.rCenter === 0 ? 3 : prev.transform.rCenter === 0 ? 1 / 3 : 1;\n\n    var _rCenterFn = d3.interpolate(prev.transform.rCenter, transform.rCenter);\n\n    var rCenterFn = function (t) {\n      return _rCenterFn(Math.pow(t, pow));\n    };\n\n    return function (t) {\n      var rpx1 = rpx1Fn(t);\n      var x0 = x0Fn(t);\n      var x1 = x1Fn(t);\n      var rCenter = rCenterFn(t);\n      var pxmid = rx2px(rpx1, (x0 + x1) / 2);\n      var textPosAngle = textPosAngleFn(t);\n      var d = {\n        pxmid: pxmid,\n        rpx1: rpx1,\n        transform: {\n          textPosAngle: textPosAngle,\n          rCenter: rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      };\n      recordMinTextSize(trace.type, transform, fullLayout);\n      return {\n        transform: {\n          targetX: getTargetX(d),\n          targetY: getTargetY(d),\n          scale: scaleFn(t),\n          rotate: rotateFn(t),\n          rCenter: rCenter\n        }\n      };\n    };\n  }\n\n  function interpX0X1FromParent(pt) {\n    var parent = pt.parent;\n    var parentPrev = prevLookup[helpers.getPtId(parent)];\n    var out = {};\n\n    if (parentPrev) {\n      // if parent is visible\n      var parentChildren = parent.children;\n      var ci = parentChildren.indexOf(pt);\n      var n = parentChildren.length;\n      var interp = d3.interpolate(parentPrev.x0, parentPrev.x1);\n      out.x0 = interp(ci / n);\n      out.x1 = interp(ci / n);\n    } else {\n      // w/o visible parent\n      // TODO !!! HOW ???\n      out.x0 = out.x1 = 0;\n    }\n\n    return out;\n  }\n} // x[0-1] keys are angles [radians]\n// y[0-1] keys are hierarchy heights [integers]\n\n\nfunction partition(entry) {\n  return d3Hierarchy.partition().size([2 * Math.PI, entry.height + 1])(entry);\n}\n\nexports.formatSliceLabel = function (pt, entry, trace, cd, fullLayout) {\n  var texttemplate = trace.texttemplate;\n  var textinfo = trace.textinfo;\n\n  if (!texttemplate && (!textinfo || textinfo === 'none')) {\n    return '';\n  }\n\n  var separators = fullLayout.separators;\n  var cd0 = cd[0];\n  var cdi = pt.data.data;\n  var hierarchy = cd0.hierarchy;\n  var isRoot = helpers.isHierarchyRoot(pt);\n  var parent = helpers.getParent(hierarchy, pt);\n  var val = helpers.getValue(pt);\n\n  if (!texttemplate) {\n    var parts = textinfo.split('+');\n\n    var hasFlag = function (flag) {\n      return parts.indexOf(flag) !== -1;\n    };\n\n    var thisText = [];\n    var tx;\n\n    if (hasFlag('label') && cdi.label) {\n      thisText.push(cdi.label);\n    }\n\n    if (cdi.hasOwnProperty('v') && hasFlag('value')) {\n      thisText.push(helpers.formatValue(cdi.v, separators));\n    }\n\n    if (!isRoot) {\n      if (hasFlag('current path')) {\n        thisText.push(helpers.getPath(pt.data));\n      }\n\n      var nPercent = 0;\n      if (hasFlag('percent parent')) nPercent++;\n      if (hasFlag('percent entry')) nPercent++;\n      if (hasFlag('percent root')) nPercent++;\n      var hasMultiplePercents = nPercent > 1;\n\n      if (nPercent) {\n        var percent;\n\n        var addPercent = function (key) {\n          tx = helpers.formatPercent(percent, separators);\n          if (hasMultiplePercents) tx += ' of ' + key;\n          thisText.push(tx);\n        };\n\n        if (hasFlag('percent parent') && !isRoot) {\n          percent = val / helpers.getValue(parent);\n          addPercent('parent');\n        }\n\n        if (hasFlag('percent entry')) {\n          percent = val / helpers.getValue(entry);\n          addPercent('entry');\n        }\n\n        if (hasFlag('percent root')) {\n          percent = val / helpers.getValue(hierarchy);\n          addPercent('root');\n        }\n      }\n    }\n\n    if (hasFlag('text')) {\n      tx = Lib.castOption(trace, cdi.i, 'text');\n      if (Lib.isValidTextValue(tx)) thisText.push(tx);\n    }\n\n    return thisText.join('<br>');\n  }\n\n  var txt = Lib.castOption(trace, cdi.i, 'texttemplate');\n  if (!txt) return '';\n  var obj = {};\n  if (cdi.label) obj.label = cdi.label;\n\n  if (cdi.hasOwnProperty('v')) {\n    obj.value = cdi.v;\n    obj.valueLabel = helpers.formatValue(cdi.v, separators);\n  }\n\n  obj.currentPath = helpers.getPath(pt.data);\n\n  if (!isRoot) {\n    obj.percentParent = val / helpers.getValue(parent);\n    obj.percentParentLabel = helpers.formatPercent(obj.percentParent, separators);\n    obj.parent = helpers.getPtLabel(parent);\n  }\n\n  obj.percentEntry = val / helpers.getValue(entry);\n  obj.percentEntryLabel = helpers.formatPercent(obj.percentEntry, separators);\n  obj.entry = helpers.getPtLabel(entry);\n  obj.percentRoot = val / helpers.getValue(hierarchy);\n  obj.percentRootLabel = helpers.formatPercent(obj.percentRoot, separators);\n  obj.root = helpers.getPtLabel(hierarchy);\n\n  if (cdi.hasOwnProperty('color')) {\n    obj.color = cdi.color;\n  }\n\n  var ptTx = Lib.castOption(trace, cdi.i, 'text');\n  if (Lib.isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n  obj.customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  return Lib.texttemplateString(txt, obj, fullLayout._d3locale, obj, trace._meta || {});\n};\n\nfunction getInscribedRadiusFraction(pt) {\n  if (pt.rpx0 === 0 && Lib.isFullCircle([pt.x0, pt.x1])) {\n    // special case of 100% with no hole\n    return 1;\n  } else {\n    return Math.max(0, Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2));\n  }\n}\n\nfunction getTextXY(d) {\n  return getCoords(d.rpx1, d.transform.textPosAngle);\n}\n\nfunction getCoords(r, angle) {\n  return [r * Math.sin(angle), -r * Math.cos(angle)];\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/sunburst/plot.js"],"names":["d3","require","d3Hierarchy","Drawing","Lib","svgTextUtils","uniformText","recordMinTextSize","clearMinTextSize","piePlot","computeTransform","transformInsideText","styleOne","resizeText","attachFxHandlers","constants","helpers","exports","plot","gd","cdmodule","transitionOpts","makeOnCompleteCallback","fullLayout","_fullLayout","layer","_sunburstlayer","join","onComplete","isFullReplot","hasTransition","uniformtext","mode","selectAll","data","cd","trace","uid","enter","append","classed","attr","order","transition","duration","ease","easing","each","plotOne","exit","remove","element","gTrace","select","slices","cd0","hierarchy","entry","findEntryWithLevel","level","maxDepth","getMaxDepth","gs","_size","domain","vpw","w","x","vph","h","y","rMax","Math","min","cx","l","cy","t","prevEntry","prevLookup","pt","getPtId","rpx0","rpx1","x0","x1","transform","isEntry","sliceData","partition","descendants","maxHeight","height","yOffset","cutoff","hasMultipleRoots","isHierarchyRoot","slice","filter","y1","maxY","y2rpx","rx2px","r","cos","sin","pathSlice","d","pathAnnulus","getTargetX","getTextXY","rCenter","getTargetY","sliceTop","slicePath","attrTween","pt2","interp","makeExitSliceInterpolator","sliceTextGroup","nextX1ofPrevEntry","prevEntryId","updateSlices","setSliceCursor","hideOnRoot","hideOnLeaves","isTransitioning","ensureSingle","s","style","y0","xmid","pxmid","midangle","PI","startangle","stopangle","halfangle","angleDelta","ring","rInscribed","getInscribedRadiusFraction","makeUpdateSliceInterpolator","call","eventDataKeys","transitionTime","CLICK_TRANSITION_TIME","transitionEasing","CLICK_TRANSITION_EASING","_transitioning","sliceText","font","ensureUniformFontSize","determineTextFont","text","formatSliceLabel","convertToTspans","textBB","bBox","node","targetX","targetY","strTransform","fontSize","size","type","getTextTransform","makeUpdateTextInterpolator","id","prev","entryPrev","next","a","parent","parentId","parentChildren","children","ci","forEach","i","n","length","interpolate","prev0","extendFlat","interpX0X1FromParent","textPosAngle","scale","rotate","textPosAngleFn","rpx1Fn","x0Fn","x1Fn","scaleFn","rotateFn","pow","_rCenterFn","rCenterFn","parentPrev","out","indexOf","texttemplate","textinfo","separators","cdi","isRoot","getParent","val","getValue","parts","split","hasFlag","flag","thisText","tx","label","push","hasOwnProperty","formatValue","v","getPath","nPercent","hasMultiplePercents","percent","addPercent","key","formatPercent","castOption","isValidTextValue","txt","obj","value","valueLabel","currentPath","percentParent","percentParentLabel","getPtLabel","percentEntry","percentEntryLabel","percentRoot","percentRootLabel","root","color","ptTx","customdata","texttemplateString","_d3locale","_meta","isFullCircle","max","getCoords","angle"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar piePlot = require('../pie/plot');\nvar computeTransform = piePlot.computeTransform;\nvar transformInsideText = piePlot.transformInsideText;\nvar styleOne = require('./style').styleOne;\nvar resizeText = require('../bar/style').resizeText;\nvar attachFxHandlers = require('./fx');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\nexports.plot = function(gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout;\n    var layer = fullLayout._sunburstlayer;\n    var join, onComplete;\n\n    // If transition config is provided, then it is only a partial replot and traces not\n    // updated are removed.\n    var isFullReplot = !transitionOpts;\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    clearMinTextSize('sunburst', fullLayout);\n\n    join = layer.selectAll('g.trace.sunburst')\n        .data(cdmodule, function(cd) { return cd[0].trace.uid; });\n\n    // using same 'stroke-linejoin' as pie traces\n    join.enter().append('g')\n        .classed('trace', true)\n        .classed('sunburst', true)\n        .attr('stroke-linejoin', 'round');\n\n    join.order();\n\n    if(hasTransition) {\n        if(makeOnCompleteCallback) {\n            // If it was passed a callback to register completion, make a callback. If\n            // this is created, then it must be executed on completion, otherwise the\n            // pos-transition redraw will not execute:\n            onComplete = makeOnCompleteCallback();\n        }\n\n        var transition = d3.transition()\n            .duration(transitionOpts.duration)\n            .ease(transitionOpts.easing)\n            .each('end', function() { onComplete && onComplete(); })\n            .each('interrupt', function() { onComplete && onComplete(); });\n\n        transition.each(function() {\n            // Must run the selection again since otherwise enters/updates get grouped together\n            // and these get executed out of order. Except we need them in order!\n            layer.selectAll('g.trace').each(function(cd) {\n                plotOne(gd, cd, this, transitionOpts);\n            });\n        });\n    } else {\n        join.each(function(cd) {\n            plotOne(gd, cd, this, transitionOpts);\n        });\n\n        if(fullLayout.uniformtext.mode) {\n            resizeText(gd, fullLayout._sunburstlayer.selectAll('.trace'), 'sunburst');\n        }\n    }\n\n    if(isFullReplot) {\n        join.exit().remove();\n    }\n};\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n    var fullLayout = gd._fullLayout;\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    var gTrace = d3.select(element);\n    var slices = gTrace.selectAll('g.slice');\n\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var hierarchy = cd0.hierarchy;\n    var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n    var maxDepth = helpers.getMaxDepth(trace);\n\n    var gs = fullLayout._size;\n    var domain = trace.domain;\n    var vpw = gs.w * (domain.x[1] - domain.x[0]);\n    var vph = gs.h * (domain.y[1] - domain.y[0]);\n    var rMax = 0.5 * Math.min(vpw, vph);\n    var cx = cd0.cx = gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n    var cy = cd0.cy = gs.t + gs.h * (1 - domain.y[0]) - vph / 2;\n\n    if(!entry) {\n        return slices.remove();\n    }\n\n    // previous root 'pt' (can be empty)\n    var prevEntry = null;\n    // stash of 'previous' position data used by tweening functions\n    var prevLookup = {};\n\n    if(hasTransition) {\n        // Important: do this before binding new sliceData!\n        slices.each(function(pt) {\n            prevLookup[helpers.getPtId(pt)] = {\n                rpx0: pt.rpx0,\n                rpx1: pt.rpx1,\n                x0: pt.x0,\n                x1: pt.x1,\n                transform: pt.transform\n            };\n\n            if(!prevEntry && helpers.isEntry(pt)) {\n                prevEntry = pt;\n            }\n        });\n    }\n\n    // N.B. slice data isn't the calcdata,\n    // grab corresponding calcdata item in sliceData[i].data.data\n    var sliceData = partition(entry).descendants();\n\n    var maxHeight = entry.height + 1;\n    var yOffset = 0;\n    var cutoff = maxDepth;\n    // N.B. handle multiple-root special case\n    if(cd0.hasMultipleRoots && helpers.isHierarchyRoot(entry)) {\n        sliceData = sliceData.slice(1);\n        maxHeight -= 1;\n        yOffset = 1;\n        cutoff += 1;\n    }\n\n    // filter out slices that won't show up on graph\n    sliceData = sliceData.filter(function(pt) { return pt.y1 <= cutoff; });\n\n    // partition span ('y') to sector radial px value\n    var maxY = Math.min(maxHeight, maxDepth);\n    var y2rpx = function(y) { return (y - yOffset) / maxY * rMax; };\n    // (radial px value, partition angle ('x'))  to px [x,y]\n    var rx2px = function(r, x) { return [r * Math.cos(x), -r * Math.sin(x)]; };\n    // slice path generation fn\n    var pathSlice = function(d) { return Lib.pathAnnulus(d.rpx0, d.rpx1, d.x0, d.x1, cx, cy); };\n    // slice text translate x/y\n\n    var getTargetX = function(d) { return cx + getTextXY(d)[0] * (d.transform.rCenter || 0) + (d.transform.x || 0); };\n    var getTargetY = function(d) { return cy + getTextXY(d)[1] * (d.transform.rCenter || 0) + (d.transform.y || 0); };\n\n    slices = slices.data(sliceData, helpers.getPtId);\n\n    slices.enter().append('g')\n        .classed('slice', true);\n\n    if(hasTransition) {\n        slices.exit().transition()\n            .each(function() {\n                var sliceTop = d3.select(this);\n\n                var slicePath = sliceTop.select('path.surface');\n                slicePath.transition().attrTween('d', function(pt2) {\n                    var interp = makeExitSliceInterpolator(pt2);\n                    return function(t) { return pathSlice(interp(t)); };\n                });\n\n                var sliceTextGroup = sliceTop.select('g.slicetext');\n                sliceTextGroup.attr('opacity', 0);\n            })\n            .remove();\n    } else {\n        slices.exit().remove();\n    }\n\n    slices.order();\n\n    // next x1 (i.e. sector end angle) of previous entry\n    var nextX1ofPrevEntry = null;\n    if(hasTransition && prevEntry) {\n        var prevEntryId = helpers.getPtId(prevEntry);\n        slices.each(function(pt) {\n            if(nextX1ofPrevEntry === null && (helpers.getPtId(pt) === prevEntryId)) {\n                nextX1ofPrevEntry = pt.x1;\n            }\n        });\n    }\n\n    var updateSlices = slices;\n    if(hasTransition) {\n        updateSlices = updateSlices.transition().each('end', function() {\n            // N.B. gd._transitioning is (still) *true* by the time\n            // transition updates get here\n            var sliceTop = d3.select(this);\n            helpers.setSliceCursor(sliceTop, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: true,\n                isTransitioning: false\n            });\n        });\n    }\n\n    updateSlices.each(function(pt) {\n        var sliceTop = d3.select(this);\n\n        var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function(s) {\n            s.style('pointer-events', 'all');\n        });\n\n        pt.rpx0 = y2rpx(pt.y0);\n        pt.rpx1 = y2rpx(pt.y1);\n        pt.xmid = (pt.x0 + pt.x1) / 2;\n        pt.pxmid = rx2px(pt.rpx1, pt.xmid);\n        pt.midangle = -(pt.xmid - Math.PI / 2);\n        pt.startangle = -(pt.x0 - Math.PI / 2);\n        pt.stopangle = -(pt.x1 - Math.PI / 2);\n        pt.halfangle = 0.5 * Math.min(Lib.angleDelta(pt.x0, pt.x1) || Math.PI, Math.PI);\n        pt.ring = 1 - (pt.rpx0 / pt.rpx1);\n        pt.rInscribed = getInscribedRadiusFraction(pt, trace);\n\n        if(hasTransition) {\n            slicePath.transition().attrTween('d', function(pt2) {\n                var interp = makeUpdateSliceInterpolator(pt2);\n                return function(t) { return pathSlice(interp(t)); };\n            });\n        } else {\n            slicePath.attr('d', pathSlice);\n        }\n\n        sliceTop\n            .call(attachFxHandlers, entry, gd, cd, {\n                eventDataKeys: constants.eventDataKeys,\n                transitionTime: constants.CLICK_TRANSITION_TIME,\n                transitionEasing: constants.CLICK_TRANSITION_EASING\n            })\n            .call(helpers.setSliceCursor, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: true,\n                isTransitioning: gd._transitioning\n            });\n\n        slicePath.call(styleOne, pt, trace);\n\n        var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n        var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n\n        sliceText.text(exports.formatSliceLabel(pt, entry, trace, cd, fullLayout))\n            .classed('slicetext', true)\n            .attr('text-anchor', 'middle')\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        // position the text relative to the slice\n        var textBB = Drawing.bBox(sliceText.node());\n        pt.transform = transformInsideText(textBB, pt, cd0);\n        pt.transform.targetX = getTargetX(pt);\n        pt.transform.targetY = getTargetY(pt);\n\n        var strTransform = function(d, textBB) {\n            var transform = d.transform;\n            computeTransform(transform, textBB);\n\n            transform.fontSize = font.size;\n            recordMinTextSize(trace.type, transform, fullLayout);\n\n            return Lib.getTextTransform(transform);\n        };\n\n        if(hasTransition) {\n            sliceText.transition().attrTween('transform', function(pt2) {\n                var interp = makeUpdateTextInterpolator(pt2);\n                return function(t) { return strTransform(interp(t), textBB); };\n            });\n        } else {\n            sliceText.attr('transform', strTransform(pt, textBB));\n        }\n    });\n\n    function makeExitSliceInterpolator(pt) {\n        var id = helpers.getPtId(pt);\n        var prev = prevLookup[id];\n        var entryPrev = prevLookup[helpers.getPtId(entry)];\n        var next;\n\n        if(entryPrev) {\n            var a = pt.x1 > entryPrev.x1 ? 2 * Math.PI : 0;\n            // if pt to remove:\n            // - if 'below' where the root-node used to be: shrink it radially inward\n            // - otherwise, collapse it clockwise or counterclockwise which ever is shortest to theta=0\n            next = pt.rpx1 < entryPrev.rpx1 ? {rpx0: 0, rpx1: 0} : {x0: a, x1: a};\n        } else {\n            // this happens when maxdepth is set, when leaves must\n            // be removed and the rootPt is new (i.e. does not have a 'prev' object)\n            var parent;\n            var parentId = helpers.getPtId(pt.parent);\n            slices.each(function(pt2) {\n                if(helpers.getPtId(pt2) === parentId) {\n                    return parent = pt2;\n                }\n            });\n            var parentChildren = parent.children;\n            var ci;\n            parentChildren.forEach(function(pt2, i) {\n                if(helpers.getPtId(pt2) === id) {\n                    return ci = i;\n                }\n            });\n            var n = parentChildren.length;\n            var interp = d3.interpolate(parent.x0, parent.x1);\n            next = {\n                rpx0: rMax, rpx1: rMax,\n                x0: interp(ci / n), x1: interp((ci + 1) / n)\n            };\n        }\n\n        return d3.interpolate(prev, next);\n    }\n\n    function makeUpdateSliceInterpolator(pt) {\n        var prev0 = prevLookup[helpers.getPtId(pt)];\n        var prev;\n        var next = {x0: pt.x0, x1: pt.x1, rpx0: pt.rpx0, rpx1: pt.rpx1};\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(prevEntry) {\n                // if trace was visible before\n                if(pt.parent) {\n                    if(nextX1ofPrevEntry) {\n                        // if new branch, twist it in clockwise or\n                        // counterclockwise which ever is shorter to\n                        // its final angle\n                        var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n                        prev = {x0: a, x1: a};\n                    } else {\n                        // if new leaf (when maxdepth is set),\n                        // grow it radially and angularly from\n                        // its parent node\n                        prev = {rpx0: rMax, rpx1: rMax};\n                        Lib.extendFlat(prev, interpX0X1FromParent(pt));\n                    }\n                } else {\n                    // if new root-node, grow it radially\n                    prev = {rpx0: 0, rpx1: 0};\n                }\n            } else {\n                // start sector of new traces from theta=0\n                prev = {x0: 0, x1: 0};\n            }\n        }\n\n        return d3.interpolate(prev, next);\n    }\n\n    function makeUpdateTextInterpolator(pt) {\n        var prev0 = prevLookup[helpers.getPtId(pt)];\n        var prev;\n        var transform = pt.transform;\n\n        if(prev0) {\n            prev = prev0;\n        } else {\n            prev = {\n                rpx1: pt.rpx1,\n                transform: {\n                    textPosAngle: transform.textPosAngle,\n                    scale: 0,\n                    rotate: transform.rotate,\n                    rCenter: transform.rCenter,\n                    x: transform.x,\n                    y: transform.y\n                }\n            };\n\n            // for new pts:\n            if(prevEntry) {\n                // if trace was visible before\n                if(pt.parent) {\n                    if(nextX1ofPrevEntry) {\n                        // if new branch, twist it in clockwise or\n                        // counterclockwise which ever is shorter to\n                        // its final angle\n                        var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n                        prev.x0 = prev.x1 = a;\n                    } else {\n                        // if leaf\n                        Lib.extendFlat(prev, interpX0X1FromParent(pt));\n                    }\n                } else {\n                    // if new root-node\n                    prev.x0 = prev.x1 = 0;\n                }\n            } else {\n                // on new traces\n                prev.x0 = prev.x1 = 0;\n            }\n        }\n\n        var textPosAngleFn = d3.interpolate(prev.transform.textPosAngle, pt.transform.textPosAngle);\n        var rpx1Fn = d3.interpolate(prev.rpx1, pt.rpx1);\n        var x0Fn = d3.interpolate(prev.x0, pt.x0);\n        var x1Fn = d3.interpolate(prev.x1, pt.x1);\n        var scaleFn = d3.interpolate(prev.transform.scale, transform.scale);\n        var rotateFn = d3.interpolate(prev.transform.rotate, transform.rotate);\n\n        // smooth out start/end from entry, to try to keep text inside sector\n        // while keeping transition smooth\n        var pow = transform.rCenter === 0 ? 3 :\n            prev.transform.rCenter === 0 ? 1 / 3 :\n            1;\n        var _rCenterFn = d3.interpolate(prev.transform.rCenter, transform.rCenter);\n        var rCenterFn = function(t) { return _rCenterFn(Math.pow(t, pow)); };\n\n        return function(t) {\n            var rpx1 = rpx1Fn(t);\n            var x0 = x0Fn(t);\n            var x1 = x1Fn(t);\n            var rCenter = rCenterFn(t);\n            var pxmid = rx2px(rpx1, (x0 + x1) / 2);\n            var textPosAngle = textPosAngleFn(t);\n\n            var d = {\n                pxmid: pxmid,\n                rpx1: rpx1,\n                transform: {\n                    textPosAngle: textPosAngle,\n                    rCenter: rCenter,\n                    x: transform.x,\n                    y: transform.y\n                }\n            };\n\n            recordMinTextSize(trace.type, transform, fullLayout);\n            return {\n                transform: {\n                    targetX: getTargetX(d),\n                    targetY: getTargetY(d),\n                    scale: scaleFn(t),\n                    rotate: rotateFn(t),\n                    rCenter: rCenter\n                }\n            };\n        };\n    }\n\n    function interpX0X1FromParent(pt) {\n        var parent = pt.parent;\n        var parentPrev = prevLookup[helpers.getPtId(parent)];\n        var out = {};\n\n        if(parentPrev) {\n            // if parent is visible\n            var parentChildren = parent.children;\n            var ci = parentChildren.indexOf(pt);\n            var n = parentChildren.length;\n            var interp = d3.interpolate(parentPrev.x0, parentPrev.x1);\n            out.x0 = interp(ci / n);\n            out.x1 = interp(ci / n);\n        } else {\n            // w/o visible parent\n            // TODO !!! HOW ???\n            out.x0 = out.x1 = 0;\n        }\n\n        return out;\n    }\n}\n\n// x[0-1] keys are angles [radians]\n// y[0-1] keys are hierarchy heights [integers]\nfunction partition(entry) {\n    return d3Hierarchy.partition()\n        .size([2 * Math.PI, entry.height + 1])(entry);\n}\n\nexports.formatSliceLabel = function(pt, entry, trace, cd, fullLayout) {\n    var texttemplate = trace.texttemplate;\n    var textinfo = trace.textinfo;\n\n    if(!texttemplate && (!textinfo || textinfo === 'none')) {\n        return '';\n    }\n\n    var separators = fullLayout.separators;\n    var cd0 = cd[0];\n    var cdi = pt.data.data;\n    var hierarchy = cd0.hierarchy;\n    var isRoot = helpers.isHierarchyRoot(pt);\n    var parent = helpers.getParent(hierarchy, pt);\n    var val = helpers.getValue(pt);\n\n    if(!texttemplate) {\n        var parts = textinfo.split('+');\n        var hasFlag = function(flag) { return parts.indexOf(flag) !== -1; };\n        var thisText = [];\n        var tx;\n\n        if(hasFlag('label') && cdi.label) {\n            thisText.push(cdi.label);\n        }\n\n        if(cdi.hasOwnProperty('v') && hasFlag('value')) {\n            thisText.push(helpers.formatValue(cdi.v, separators));\n        }\n\n        if(!isRoot) {\n            if(hasFlag('current path')) {\n                thisText.push(helpers.getPath(pt.data));\n            }\n\n            var nPercent = 0;\n            if(hasFlag('percent parent')) nPercent++;\n            if(hasFlag('percent entry')) nPercent++;\n            if(hasFlag('percent root')) nPercent++;\n            var hasMultiplePercents = nPercent > 1;\n\n            if(nPercent) {\n                var percent;\n                var addPercent = function(key) {\n                    tx = helpers.formatPercent(percent, separators);\n\n                    if(hasMultiplePercents) tx += ' of ' + key;\n                    thisText.push(tx);\n                };\n\n                if(hasFlag('percent parent') && !isRoot) {\n                    percent = val / helpers.getValue(parent);\n                    addPercent('parent');\n                }\n                if(hasFlag('percent entry')) {\n                    percent = val / helpers.getValue(entry);\n                    addPercent('entry');\n                }\n                if(hasFlag('percent root')) {\n                    percent = val / helpers.getValue(hierarchy);\n                    addPercent('root');\n                }\n            }\n        }\n\n        if(hasFlag('text')) {\n            tx = Lib.castOption(trace, cdi.i, 'text');\n            if(Lib.isValidTextValue(tx)) thisText.push(tx);\n        }\n\n        return thisText.join('<br>');\n    }\n\n    var txt = Lib.castOption(trace, cdi.i, 'texttemplate');\n    if(!txt) return '';\n    var obj = {};\n    if(cdi.label) obj.label = cdi.label;\n    if(cdi.hasOwnProperty('v')) {\n        obj.value = cdi.v;\n        obj.valueLabel = helpers.formatValue(cdi.v, separators);\n    }\n\n    obj.currentPath = helpers.getPath(pt.data);\n\n    if(!isRoot) {\n        obj.percentParent = val / helpers.getValue(parent);\n        obj.percentParentLabel = helpers.formatPercent(\n            obj.percentParent, separators\n        );\n        obj.parent = helpers.getPtLabel(parent);\n    }\n\n    obj.percentEntry = val / helpers.getValue(entry);\n    obj.percentEntryLabel = helpers.formatPercent(\n        obj.percentEntry, separators\n    );\n    obj.entry = helpers.getPtLabel(entry);\n\n    obj.percentRoot = val / helpers.getValue(hierarchy);\n    obj.percentRootLabel = helpers.formatPercent(\n        obj.percentRoot, separators\n    );\n    obj.root = helpers.getPtLabel(hierarchy);\n\n    if(cdi.hasOwnProperty('color')) {\n        obj.color = cdi.color;\n    }\n    var ptTx = Lib.castOption(trace, cdi.i, 'text');\n    if(Lib.isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n    obj.customdata = Lib.castOption(trace, cdi.i, 'customdata');\n    return Lib.texttemplateString(txt, obj, fullLayout._d3locale, obj, trace._meta || {});\n};\n\nfunction getInscribedRadiusFraction(pt) {\n    if(pt.rpx0 === 0 && Lib.isFullCircle([pt.x0, pt.x1])) {\n        // special case of 100% with no hole\n        return 1;\n    } else {\n        return Math.max(0, Math.min(\n            1 / (1 + 1 / Math.sin(pt.halfangle)),\n            pt.ring / 2\n        ));\n    }\n}\n\nfunction getTextXY(d) {\n    return getCoords(d.rpx1, d.transform.textPosAngle);\n}\n\nfunction getCoords(r, angle) {\n    return [r * Math.sin(angle), -r * Math.cos(angle)];\n}\n"]},"metadata":{},"sourceType":"script"}