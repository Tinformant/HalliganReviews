{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar isArray1D = require('../../lib').isArray1D;\n\nvar cheaterBasis = require('./cheater_basis');\n\nvar arrayMinmax = require('./array_minmax');\n\nvar calcGridlines = require('./calc_gridlines');\n\nvar calcLabels = require('./calc_labels');\n\nvar calcClipPath = require('./calc_clippath');\n\nvar clean2dArray = require('../heatmap/clean_2d_array');\n\nvar smoothFill2dArray = require('./smooth_fill_2d_array');\n\nvar convertColumnData = require('../heatmap/convert_column_xyz');\n\nvar setConvert = require('./set_convert');\n\nmodule.exports = function calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var aax = trace.aaxis;\n  var bax = trace.baxis;\n  var x = trace.x;\n  var y = trace.y;\n  var cols = [];\n  if (x && isArray1D(x)) cols.push('x');\n  if (y && isArray1D(y)) cols.push('y');\n\n  if (cols.length) {\n    convertColumnData(trace, aax, bax, 'a', 'b', cols);\n  }\n\n  var a = trace._a = trace._a || trace.a;\n  var b = trace._b = trace._b || trace.b;\n  x = trace._x || trace.x;\n  y = trace._y || trace.y;\n  var t = {};\n\n  if (trace._cheater) {\n    var avals = aax.cheatertype === 'index' ? a.length : a;\n    var bvals = bax.cheatertype === 'index' ? b.length : b;\n    x = cheaterBasis(avals, bvals, trace.cheaterslope);\n  }\n\n  trace._x = x = clean2dArray(x);\n  trace._y = y = clean2dArray(y); // Fill in any undefined values with elliptic smoothing. This doesn't take\n  // into account the spacing of the values. That is, the derivatives should\n  // be modified to use a and b values. It's not that hard, but this is already\n  // moderate overkill for just filling in missing values.\n\n  smoothFill2dArray(x, a, b);\n  smoothFill2dArray(y, a, b);\n  setConvert(trace); // create conversion functions that depend on the data\n\n  trace.setScale(); // This is a rather expensive scan. Nothing guarantees monotonicity,\n  // so we need to scan through all data to get proper ranges:\n\n  var xrange = arrayMinmax(x);\n  var yrange = arrayMinmax(y);\n  var dx = 0.5 * (xrange[1] - xrange[0]);\n  var xc = 0.5 * (xrange[1] + xrange[0]);\n  var dy = 0.5 * (yrange[1] - yrange[0]);\n  var yc = 0.5 * (yrange[1] + yrange[0]); // Expand the axes to fit the plot, except just grow it by a factor of 1.3\n  // because the labels should be taken into account except that's difficult\n  // hence 1.3.\n\n  var grow = 1.3;\n  xrange = [xc - dx * grow, xc + dx * grow];\n  yrange = [yc - dy * grow, yc + dy * grow];\n  trace._extremes[xa._id] = Axes.findExtremes(xa, xrange, {\n    padded: true\n  });\n  trace._extremes[ya._id] = Axes.findExtremes(ya, yrange, {\n    padded: true\n  }); // Enumerate the gridlines, both major and minor, and store them on the trace\n  // object:\n\n  calcGridlines(trace, 'a', 'b');\n  calcGridlines(trace, 'b', 'a'); // Calculate the text labels for each major gridline and store them on the\n  // trace object:\n\n  calcLabels(trace, aax);\n  calcLabels(trace, bax); // Tabulate points for the four segments that bound the axes so that we can\n  // map to pixel coordinates in the plot function and create a clip rect:\n\n  t.clipsegments = calcClipPath(trace._xctrl, trace._yctrl, aax, bax);\n  t.x = x;\n  t.y = y;\n  t.a = a;\n  t.b = b;\n  return [t];\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/carpet/calc.js"],"names":["Axes","require","isArray1D","cheaterBasis","arrayMinmax","calcGridlines","calcLabels","calcClipPath","clean2dArray","smoothFill2dArray","convertColumnData","setConvert","module","exports","calc","gd","trace","xa","getFromId","xaxis","ya","yaxis","aax","aaxis","bax","baxis","x","y","cols","push","length","a","_a","b","_b","_x","_y","t","_cheater","avals","cheatertype","bvals","cheaterslope","setScale","xrange","yrange","dx","xc","dy","yc","grow","_extremes","_id","findExtremes","padded","clipsegments","_xctrl","_yctrl"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar isArray1D = require('../../lib').isArray1D;\nvar cheaterBasis = require('./cheater_basis');\nvar arrayMinmax = require('./array_minmax');\nvar calcGridlines = require('./calc_gridlines');\nvar calcLabels = require('./calc_labels');\nvar calcClipPath = require('./calc_clippath');\nvar clean2dArray = require('../heatmap/clean_2d_array');\nvar smoothFill2dArray = require('./smooth_fill_2d_array');\nvar convertColumnData = require('../heatmap/convert_column_xyz');\nvar setConvert = require('./set_convert');\n\nmodule.exports = function calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis);\n    var ya = Axes.getFromId(gd, trace.yaxis);\n    var aax = trace.aaxis;\n    var bax = trace.baxis;\n\n    var x = trace.x;\n    var y = trace.y;\n    var cols = [];\n    if(x && isArray1D(x)) cols.push('x');\n    if(y && isArray1D(y)) cols.push('y');\n\n    if(cols.length) {\n        convertColumnData(trace, aax, bax, 'a', 'b', cols);\n    }\n\n    var a = trace._a = trace._a || trace.a;\n    var b = trace._b = trace._b || trace.b;\n    x = trace._x || trace.x;\n    y = trace._y || trace.y;\n\n    var t = {};\n\n    if(trace._cheater) {\n        var avals = aax.cheatertype === 'index' ? a.length : a;\n        var bvals = bax.cheatertype === 'index' ? b.length : b;\n        x = cheaterBasis(avals, bvals, trace.cheaterslope);\n    }\n\n    trace._x = x = clean2dArray(x);\n    trace._y = y = clean2dArray(y);\n\n    // Fill in any undefined values with elliptic smoothing. This doesn't take\n    // into account the spacing of the values. That is, the derivatives should\n    // be modified to use a and b values. It's not that hard, but this is already\n    // moderate overkill for just filling in missing values.\n    smoothFill2dArray(x, a, b);\n    smoothFill2dArray(y, a, b);\n\n    setConvert(trace);\n\n    // create conversion functions that depend on the data\n    trace.setScale();\n\n    // This is a rather expensive scan. Nothing guarantees monotonicity,\n    // so we need to scan through all data to get proper ranges:\n    var xrange = arrayMinmax(x);\n    var yrange = arrayMinmax(y);\n\n    var dx = 0.5 * (xrange[1] - xrange[0]);\n    var xc = 0.5 * (xrange[1] + xrange[0]);\n\n    var dy = 0.5 * (yrange[1] - yrange[0]);\n    var yc = 0.5 * (yrange[1] + yrange[0]);\n\n    // Expand the axes to fit the plot, except just grow it by a factor of 1.3\n    // because the labels should be taken into account except that's difficult\n    // hence 1.3.\n    var grow = 1.3;\n    xrange = [xc - dx * grow, xc + dx * grow];\n    yrange = [yc - dy * grow, yc + dy * grow];\n\n    trace._extremes[xa._id] = Axes.findExtremes(xa, xrange, {padded: true});\n    trace._extremes[ya._id] = Axes.findExtremes(ya, yrange, {padded: true});\n\n    // Enumerate the gridlines, both major and minor, and store them on the trace\n    // object:\n    calcGridlines(trace, 'a', 'b');\n    calcGridlines(trace, 'b', 'a');\n\n    // Calculate the text labels for each major gridline and store them on the\n    // trace object:\n    calcLabels(trace, aax);\n    calcLabels(trace, bax);\n\n    // Tabulate points for the four segments that bound the axes so that we can\n    // map to pixel coordinates in the plot function and create a clip rect:\n    t.clipsegments = calcClipPath(trace._xctrl, trace._yctrl, aax, bax);\n\n    t.x = x;\n    t.y = y;\n    t.a = a;\n    t.b = b;\n\n    return [t];\n};\n"]},"metadata":{},"sourceType":"script"}