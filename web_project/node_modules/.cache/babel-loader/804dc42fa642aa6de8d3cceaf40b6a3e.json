{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n/* eslint block-scoped-var: 0*/\n\n/* eslint no-redeclare: 0*/\n'use strict';\n\nmodule.exports = computeTickMarks;\n\nvar Axes = require('../../cartesian/axes');\n\nvar Lib = require('../../../lib');\n\nvar AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];\nvar centerPoint = [0, 0, 0];\n\nfunction contourLevelsFromTicks(ticks) {\n  var result = new Array(3);\n\n  for (var i = 0; i < 3; ++i) {\n    var tlevel = ticks[i];\n    var clevel = new Array(tlevel.length);\n\n    for (var j = 0; j < tlevel.length; ++j) {\n      clevel[j] = tlevel[j].x;\n    }\n\n    result[i] = clevel;\n  }\n\n  return result;\n}\n\nfunction computeTickMarks(scene) {\n  var axesOptions = scene.axesOptions;\n  var glRange = scene.glplot.axesPixels;\n  var sceneLayout = scene.fullSceneLayout;\n  var ticks = [[], [], []];\n\n  for (var i = 0; i < 3; ++i) {\n    var axes = sceneLayout[AXES_NAMES[i]];\n    axes._length = (glRange[i].hi - glRange[i].lo) * glRange[i].pixelsPerDataUnit / scene.dataScale[i];\n\n    if (Math.abs(axes._length) === Infinity || isNaN(axes._length)) {\n      ticks[i] = [];\n    } else {\n      axes._input_range = axes.range.slice();\n      axes.range[0] = glRange[i].lo / scene.dataScale[i];\n      axes.range[1] = glRange[i].hi / scene.dataScale[i];\n      axes._m = 1.0 / (scene.dataScale[i] * glRange[i].pixelsPerDataUnit);\n\n      if (axes.range[0] === axes.range[1]) {\n        axes.range[0] -= 1;\n        axes.range[1] += 1;\n      } // this is necessary to short-circuit the 'y' handling\n      // in autotick part of calcTicks... Treating all axes as 'y' in this case\n      // running the autoticks here, then setting\n      // autoticks to false to get around the 2D handling in calcTicks.\n\n\n      var tickModeCached = axes.tickmode;\n\n      if (axes.tickmode === 'auto') {\n        axes.tickmode = 'linear';\n        var nticks = axes.nticks || Lib.constrain(axes._length / 40, 4, 9);\n        Axes.autoTicks(axes, Math.abs(axes.range[1] - axes.range[0]) / nticks);\n      }\n\n      var dataTicks = Axes.calcTicks(axes, {\n        msUTC: true\n      });\n\n      for (var j = 0; j < dataTicks.length; ++j) {\n        dataTicks[j].x = dataTicks[j].x * scene.dataScale[i];\n\n        if (axes.type === 'date') {\n          dataTicks[j].text = dataTicks[j].text.replace(/\\<br\\>/g, ' ');\n        }\n      }\n\n      ticks[i] = dataTicks;\n      axes.tickmode = tickModeCached;\n    }\n  }\n\n  axesOptions.ticks = ticks; // Calculate tick lengths dynamically\n\n  for (var i = 0; i < 3; ++i) {\n    centerPoint[i] = 0.5 * (scene.glplot.bounds[0][i] + scene.glplot.bounds[1][i]);\n\n    for (var j = 0; j < 2; ++j) {\n      axesOptions.bounds[j][i] = scene.glplot.bounds[j][i];\n    }\n  }\n\n  scene.contourLevels = contourLevelsFromTicks(ticks);\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/plots/gl3d/layout/tick_marks.js"],"names":["module","exports","computeTickMarks","Axes","require","Lib","AXES_NAMES","centerPoint","contourLevelsFromTicks","ticks","result","Array","i","tlevel","clevel","length","j","x","scene","axesOptions","glRange","glplot","axesPixels","sceneLayout","fullSceneLayout","axes","_length","hi","lo","pixelsPerDataUnit","dataScale","Math","abs","Infinity","isNaN","_input_range","range","slice","_m","tickModeCached","tickmode","nticks","constrain","autoTicks","dataTicks","calcTicks","msUTC","type","text","replace","bounds","contourLevels"],"mappings":"AAAA;;;;;;;;AAQA;;AACA;AAEA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,gBAAjB;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,sBAAD,CAAlB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,cAAD,CAAjB;;AAEA,IAAIE,UAAU,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,CAAjB;AAEA,IAAIC,WAAW,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAlB;;AAEA,SAASC,sBAAT,CAAgCC,KAAhC,EAAuC;AACnC,MAAIC,MAAM,GAAG,IAAIC,KAAJ,CAAU,CAAV,CAAb;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsB,EAAEA,CAAxB,EAA2B;AACvB,QAAIC,MAAM,GAAGJ,KAAK,CAACG,CAAD,CAAlB;AACA,QAAIE,MAAM,GAAG,IAAIH,KAAJ,CAAUE,MAAM,CAACE,MAAjB,CAAb;;AACA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGH,MAAM,CAACE,MAA1B,EAAkC,EAAEC,CAApC,EAAuC;AACnCF,MAAAA,MAAM,CAACE,CAAD,CAAN,GAAYH,MAAM,CAACG,CAAD,CAAN,CAAUC,CAAtB;AACH;;AACDP,IAAAA,MAAM,CAACE,CAAD,CAAN,GAAYE,MAAZ;AACH;;AACD,SAAOJ,MAAP;AACH;;AAED,SAASR,gBAAT,CAA0BgB,KAA1B,EAAiC;AAC7B,MAAIC,WAAW,GAAGD,KAAK,CAACC,WAAxB;AACA,MAAIC,OAAO,GAAGF,KAAK,CAACG,MAAN,CAAaC,UAA3B;AACA,MAAIC,WAAW,GAAGL,KAAK,CAACM,eAAxB;AAEA,MAAIf,KAAK,GAAG,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,CAAZ;;AAEA,OAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsB,EAAEA,CAAxB,EAA2B;AACvB,QAAIa,IAAI,GAAGF,WAAW,CAACjB,UAAU,CAACM,CAAD,CAAX,CAAtB;AAEAa,IAAAA,IAAI,CAACC,OAAL,GAAe,CAACN,OAAO,CAACR,CAAD,CAAP,CAAWe,EAAX,GAAgBP,OAAO,CAACR,CAAD,CAAP,CAAWgB,EAA5B,IACXR,OAAO,CAACR,CAAD,CAAP,CAAWiB,iBADA,GACoBX,KAAK,CAACY,SAAN,CAAgBlB,CAAhB,CADnC;;AAGA,QAAGmB,IAAI,CAACC,GAAL,CAASP,IAAI,CAACC,OAAd,MAA2BO,QAA3B,IACAC,KAAK,CAACT,IAAI,CAACC,OAAN,CADR,EACwB;AACpBjB,MAAAA,KAAK,CAACG,CAAD,CAAL,GAAW,EAAX;AACH,KAHD,MAGO;AACHa,MAAAA,IAAI,CAACU,YAAL,GAAoBV,IAAI,CAACW,KAAL,CAAWC,KAAX,EAApB;AACAZ,MAAAA,IAAI,CAACW,KAAL,CAAW,CAAX,IAAiBhB,OAAO,CAACR,CAAD,CAAP,CAAWgB,EAAZ,GAAkBV,KAAK,CAACY,SAAN,CAAgBlB,CAAhB,CAAlC;AACAa,MAAAA,IAAI,CAACW,KAAL,CAAW,CAAX,IAAiBhB,OAAO,CAACR,CAAD,CAAP,CAAWe,EAAZ,GAAkBT,KAAK,CAACY,SAAN,CAAgBlB,CAAhB,CAAlC;AACAa,MAAAA,IAAI,CAACa,EAAL,GAAU,OAAOpB,KAAK,CAACY,SAAN,CAAgBlB,CAAhB,IAAqBQ,OAAO,CAACR,CAAD,CAAP,CAAWiB,iBAAvC,CAAV;;AAEA,UAAGJ,IAAI,CAACW,KAAL,CAAW,CAAX,MAAkBX,IAAI,CAACW,KAAL,CAAW,CAAX,CAArB,EAAoC;AAChCX,QAAAA,IAAI,CAACW,KAAL,CAAW,CAAX,KAAiB,CAAjB;AACAX,QAAAA,IAAI,CAACW,KAAL,CAAW,CAAX,KAAiB,CAAjB;AACH,OATE,CAUH;AACA;AACA;AACA;;;AACA,UAAIG,cAAc,GAAGd,IAAI,CAACe,QAA1B;;AACA,UAAGf,IAAI,CAACe,QAAL,KAAkB,MAArB,EAA6B;AACzBf,QAAAA,IAAI,CAACe,QAAL,GAAgB,QAAhB;AACA,YAAIC,MAAM,GAAGhB,IAAI,CAACgB,MAAL,IAAepC,GAAG,CAACqC,SAAJ,CAAejB,IAAI,CAACC,OAAL,GAAe,EAA9B,EAAmC,CAAnC,EAAsC,CAAtC,CAA5B;AACAvB,QAAAA,IAAI,CAACwC,SAAL,CAAelB,IAAf,EAAqBM,IAAI,CAACC,GAAL,CAASP,IAAI,CAACW,KAAL,CAAW,CAAX,IAAgBX,IAAI,CAACW,KAAL,CAAW,CAAX,CAAzB,IAA0CK,MAA/D;AACH;;AACD,UAAIG,SAAS,GAAGzC,IAAI,CAAC0C,SAAL,CAAepB,IAAf,EAAqB;AAAEqB,QAAAA,KAAK,EAAE;AAAT,OAArB,CAAhB;;AACA,WAAI,IAAI9B,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG4B,SAAS,CAAC7B,MAA7B,EAAqC,EAAEC,CAAvC,EAA0C;AACtC4B,QAAAA,SAAS,CAAC5B,CAAD,CAAT,CAAaC,CAAb,GAAiB2B,SAAS,CAAC5B,CAAD,CAAT,CAAaC,CAAb,GAAiBC,KAAK,CAACY,SAAN,CAAgBlB,CAAhB,CAAlC;;AAEA,YAAGa,IAAI,CAACsB,IAAL,KAAc,MAAjB,EAAyB;AACrBH,UAAAA,SAAS,CAAC5B,CAAD,CAAT,CAAagC,IAAb,GACAJ,SAAS,CAAC5B,CAAD,CAAT,CAAagC,IAAb,CAAkBC,OAAlB,CAA0B,SAA1B,EAAqC,GAArC,CADA;AAEH;AACJ;;AACDxC,MAAAA,KAAK,CAACG,CAAD,CAAL,GAAWgC,SAAX;AAGAnB,MAAAA,IAAI,CAACe,QAAL,GAAgBD,cAAhB;AACH;AACJ;;AAEDpB,EAAAA,WAAW,CAACV,KAAZ,GAAoBA,KAApB,CApD6B,CAsD7B;;AACA,OAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsB,EAAEA,CAAxB,EAA2B;AACvBL,IAAAA,WAAW,CAACK,CAAD,CAAX,GAAiB,OAAOM,KAAK,CAACG,MAAN,CAAa6B,MAAb,CAAoB,CAApB,EAAuBtC,CAAvB,IAA4BM,KAAK,CAACG,MAAN,CAAa6B,MAAb,CAAoB,CAApB,EAAuBtC,CAAvB,CAAnC,CAAjB;;AACA,SAAI,IAAII,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsB,EAAEA,CAAxB,EAA2B;AACvBG,MAAAA,WAAW,CAAC+B,MAAZ,CAAmBlC,CAAnB,EAAsBJ,CAAtB,IAA2BM,KAAK,CAACG,MAAN,CAAa6B,MAAb,CAAoBlC,CAApB,EAAuBJ,CAAvB,CAA3B;AACH;AACJ;;AAEDM,EAAAA,KAAK,CAACiC,aAAN,GAAsB3C,sBAAsB,CAACC,KAAD,CAA5C;AACH","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n/* eslint block-scoped-var: 0*/\n/* eslint no-redeclare: 0*/\n\n'use strict';\n\nmodule.exports = computeTickMarks;\n\nvar Axes = require('../../cartesian/axes');\nvar Lib = require('../../../lib');\n\nvar AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];\n\nvar centerPoint = [0, 0, 0];\n\nfunction contourLevelsFromTicks(ticks) {\n    var result = new Array(3);\n    for(var i = 0; i < 3; ++i) {\n        var tlevel = ticks[i];\n        var clevel = new Array(tlevel.length);\n        for(var j = 0; j < tlevel.length; ++j) {\n            clevel[j] = tlevel[j].x;\n        }\n        result[i] = clevel;\n    }\n    return result;\n}\n\nfunction computeTickMarks(scene) {\n    var axesOptions = scene.axesOptions;\n    var glRange = scene.glplot.axesPixels;\n    var sceneLayout = scene.fullSceneLayout;\n\n    var ticks = [[], [], []];\n\n    for(var i = 0; i < 3; ++i) {\n        var axes = sceneLayout[AXES_NAMES[i]];\n\n        axes._length = (glRange[i].hi - glRange[i].lo) *\n            glRange[i].pixelsPerDataUnit / scene.dataScale[i];\n\n        if(Math.abs(axes._length) === Infinity ||\n           isNaN(axes._length)) {\n            ticks[i] = [];\n        } else {\n            axes._input_range = axes.range.slice();\n            axes.range[0] = (glRange[i].lo) / scene.dataScale[i];\n            axes.range[1] = (glRange[i].hi) / scene.dataScale[i];\n            axes._m = 1.0 / (scene.dataScale[i] * glRange[i].pixelsPerDataUnit);\n\n            if(axes.range[0] === axes.range[1]) {\n                axes.range[0] -= 1;\n                axes.range[1] += 1;\n            }\n            // this is necessary to short-circuit the 'y' handling\n            // in autotick part of calcTicks... Treating all axes as 'y' in this case\n            // running the autoticks here, then setting\n            // autoticks to false to get around the 2D handling in calcTicks.\n            var tickModeCached = axes.tickmode;\n            if(axes.tickmode === 'auto') {\n                axes.tickmode = 'linear';\n                var nticks = axes.nticks || Lib.constrain((axes._length / 40), 4, 9);\n                Axes.autoTicks(axes, Math.abs(axes.range[1] - axes.range[0]) / nticks);\n            }\n            var dataTicks = Axes.calcTicks(axes, { msUTC: true });\n            for(var j = 0; j < dataTicks.length; ++j) {\n                dataTicks[j].x = dataTicks[j].x * scene.dataScale[i];\n\n                if(axes.type === 'date') {\n                    dataTicks[j].text =\n                    dataTicks[j].text.replace(/\\<br\\>/g, ' ');\n                }\n            }\n            ticks[i] = dataTicks;\n\n\n            axes.tickmode = tickModeCached;\n        }\n    }\n\n    axesOptions.ticks = ticks;\n\n    // Calculate tick lengths dynamically\n    for(var i = 0; i < 3; ++i) {\n        centerPoint[i] = 0.5 * (scene.glplot.bounds[0][i] + scene.glplot.bounds[1][i]);\n        for(var j = 0; j < 2; ++j) {\n            axesOptions.bounds[j][i] = scene.glplot.bounds[j][i];\n        }\n    }\n\n    scene.contourLevels = contourLevelsFromTicks(ticks);\n}\n"]},"metadata":{},"sourceType":"script"}