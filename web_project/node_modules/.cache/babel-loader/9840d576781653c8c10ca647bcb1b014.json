{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../lib');\n\nvar dfltConfig = require('../plot_api/plot_config').dfltConfig;\n/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */\n\n\nfunction copyArgArray(gd, args) {\n  var copy = [];\n  var arg;\n\n  for (var i = 0; i < args.length; i++) {\n    arg = args[i];\n    if (arg === gd) copy[i] = arg;else if (typeof arg === 'object') {\n      copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);\n    } else copy[i] = arg;\n  }\n\n  return copy;\n} // -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\n\nvar queue = {}; // TODO: disable/enable undo and redo buttons appropriately\n\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */\n\nqueue.add = function (gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n  var queueObj, queueIndex; // make sure we have the queue and our position in it\n\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  queueIndex = gd.undoQueue.index; // if we're already playing an undo or redo, or if this is an auto operation\n  // (like pane resize... any others?) then we don't save this to the undo queue\n\n  if (gd.autoplay) {\n    if (!gd.undoQueue.inSequence) gd.autoplay = false;\n    return;\n  } // if we're not in a sequence or are just starting, we need a new queue item\n\n\n  if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n    queueObj = {\n      undo: {\n        calls: [],\n        args: []\n      },\n      redo: {\n        calls: [],\n        args: []\n      }\n    };\n    gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n    gd.undoQueue.index += 1;\n  } else {\n    queueObj = gd.undoQueue.queue[queueIndex - 1];\n  }\n\n  gd.undoQueue.beginSequence = false; // we unshift to handle calls for undo in a forward for loop later\n\n  if (queueObj) {\n    queueObj.undo.calls.unshift(undoFunc);\n    queueObj.undo.args.unshift(undoArgs);\n    queueObj.redo.calls.push(redoFunc);\n    queueObj.redo.args.push(redoArgs);\n  }\n\n  if (gd.undoQueue.queue.length > dfltConfig.queueLength) {\n    gd.undoQueue.queue.shift();\n    gd.undoQueue.index--;\n  }\n};\n/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */\n\n\nqueue.startSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = true;\n  gd.undoQueue.beginSequence = true;\n};\n/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */\n\n\nqueue.stopSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = false;\n  gd.undoQueue.beginSequence = false;\n};\n/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */\n\n\nqueue.undo = function undo(gd) {\n  var queueObj, i;\n\n  if (gd.framework && gd.framework.isPolar) {\n    gd.framework.undo();\n    return;\n  }\n\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {\n    return;\n  } // index is pointing to next *forward* queueObj, point to the one we're undoing\n\n\n  gd.undoQueue.index--; // get the queueObj for instructions on how to undo\n\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index]; // this sequence keeps things from adding to the queue during undo/redo\n\n  gd.undoQueue.inSequence = true;\n\n  for (i = 0; i < queueObj.undo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n  }\n\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false;\n};\n/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */\n\n\nqueue.redo = function redo(gd) {\n  var queueObj, i;\n\n  if (gd.framework && gd.framework.isPolar) {\n    gd.framework.redo();\n    return;\n  }\n\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {\n    return;\n  } // get the queueObj for instructions on how to undo\n\n\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index]; // this sequence keeps things from adding to the queue during undo/redo\n\n  gd.undoQueue.inSequence = true;\n\n  for (i = 0; i < queueObj.redo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n  }\n\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false; // index is pointing to the thing we just redid, move it\n\n  gd.undoQueue.index++;\n};\n/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */\n\n\nqueue.plotDo = function (gd, func, args) {\n  gd.autoplay = true; // this *won't* copy gd and it preserves `undefined` properties!\n\n  args = copyArgArray(gd, args); // call the supplied function\n\n  func.apply(null, args);\n};\n\nmodule.exports = queue;","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/lib/queue.js"],"names":["Lib","require","dfltConfig","copyArgArray","gd","args","copy","arg","i","length","Array","isArray","extendDeep","extendDeepAll","queue","add","undoFunc","undoArgs","redoFunc","redoArgs","queueObj","queueIndex","undoQueue","index","sequence","autoplay","inSequence","beginSequence","undo","calls","redo","splice","unshift","push","queueLength","shift","startSequence","stopSequence","framework","isPolar","undefined","isNaN","plotDo","func","apply","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar dfltConfig = require('../plot_api/plot_config').dfltConfig;\n\n/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */\nfunction copyArgArray(gd, args) {\n    var copy = [];\n    var arg;\n\n    for(var i = 0; i < args.length; i++) {\n        arg = args[i];\n\n        if(arg === gd) copy[i] = arg;\n        else if(typeof arg === 'object') {\n            copy[i] = Array.isArray(arg) ?\n                Lib.extendDeep([], arg) :\n                Lib.extendDeepAll({}, arg);\n        } else copy[i] = arg;\n    }\n\n    return copy;\n}\n\n\n// -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\n\nvar queue = {};\n\n// TODO: disable/enable undo and redo buttons appropriately\n\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */\nqueue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n    var queueObj,\n        queueIndex;\n\n    // make sure we have the queue and our position in it\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    queueIndex = gd.undoQueue.index;\n\n    // if we're already playing an undo or redo, or if this is an auto operation\n    // (like pane resize... any others?) then we don't save this to the undo queue\n    if(gd.autoplay) {\n        if(!gd.undoQueue.inSequence) gd.autoplay = false;\n        return;\n    }\n\n    // if we're not in a sequence or are just starting, we need a new queue item\n    if(!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n        queueObj = {undo: {calls: [], args: []}, redo: {calls: [], args: []}};\n        gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n        gd.undoQueue.index += 1;\n    } else {\n        queueObj = gd.undoQueue.queue[queueIndex - 1];\n    }\n    gd.undoQueue.beginSequence = false;\n\n    // we unshift to handle calls for undo in a forward for loop later\n    if(queueObj) {\n        queueObj.undo.calls.unshift(undoFunc);\n        queueObj.undo.args.unshift(undoArgs);\n        queueObj.redo.calls.push(redoFunc);\n        queueObj.redo.args.push(redoArgs);\n    }\n\n    if(gd.undoQueue.queue.length > dfltConfig.queueLength) {\n        gd.undoQueue.queue.shift();\n        gd.undoQueue.index--;\n    }\n};\n\n/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */\nqueue.startSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = true;\n    gd.undoQueue.beginSequence = true;\n};\n\n/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */\nqueue.stopSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = false;\n    gd.undoQueue.beginSequence = false;\n};\n\n/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */\nqueue.undo = function undo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.undo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index <= 0) {\n        return;\n    }\n\n    // index is pointing to next *forward* queueObj, point to the one we're undoing\n    gd.undoQueue.index--;\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.undo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n};\n\n/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */\nqueue.redo = function redo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.redo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index >= gd.undoQueue.queue.length) {\n        return;\n    }\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.redo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n\n    // index is pointing to the thing we just redid, move it\n    gd.undoQueue.index++;\n};\n\n/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */\nqueue.plotDo = function(gd, func, args) {\n    gd.autoplay = true;\n\n    // this *won't* copy gd and it preserves `undefined` properties!\n    args = copyArgArray(gd, args);\n\n    // call the supplied function\n    func.apply(null, args);\n};\n\nmodule.exports = queue;\n"]},"metadata":{},"sourceType":"script"}