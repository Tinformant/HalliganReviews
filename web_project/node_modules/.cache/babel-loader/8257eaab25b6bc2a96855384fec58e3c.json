{"ast":null,"code":"'use strict';\n\nmodule.exports = {\n  init: sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete: sweepComplete,\n  scanBipartite: scanBipartite,\n  scanComplete: scanComplete\n};\n\nvar pool = require('typedarray-pool');\n\nvar bits = require('bit-twiddle');\n\nvar isort = require('./sort'); //Flag for blue\n\n\nvar BLUE_FLAG = 1 << 28; //1D sweep event queue stuff (use pool to save space)\n\nvar INIT_CAPACITY = 1024;\nvar RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8); //Reserves memory for the 1D sweep data structures\n\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count);\n\n  if (RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE);\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n\n  if (RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX);\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n\n  if (BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE);\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n\n  if (BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX);\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n\n  if (COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE);\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n\n  if (COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX);\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n\n  var eventLength = 8 * rcount;\n\n  if (SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS);\n    SWEEP_EVENTS = pool.mallocDouble(eventLength);\n  }\n} //Remove an item from the active queue in O(1)\n\n\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item];\n  var top = queue[count - 1];\n  queue[idx] = top;\n  index[top] = idx;\n} //Insert an item into the active queue in O(1)\n\n\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item;\n  index[item] = count;\n} //Recursion base case: use 1D sweep algorithm\n\n\nfunction sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = d - 1;\n  var iend = elemSize - 1;\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = redIndex[i];\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -(idx + 1);\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = blueIndex[i] + BLUE_FLAG;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  var blueActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n    if (e >= BLUE_FLAG) {\n      //blue destroy event\n      e = e - BLUE_FLAG | 0;\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);\n    } else if (e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);\n    } else if (e <= -BLUE_FLAG) {\n      //blue create event\n      e = -e - BLUE_FLAG | 0;\n\n      for (var j = 0; j < redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);\n    } else {\n      //red create event\n      e = -e - 1 | 0;\n\n      for (var j = 0; j < blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j]);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);\n    }\n  }\n} //Complete sweep\n\n\nfunction sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = d - 1;\n  var iend = elemSize - 1;\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = redIndex[i] + 1 << 1;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = blueIndex[i] + 1 << 1;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx | 1;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx | 1;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  var blueActive = 0;\n  var commonActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n    var color = e & 1;\n\n    if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {\n      color = 2;\n      i += 1;\n    }\n\n    if (e < 0) {\n      //Create event\n      var id = -(e >> 1) - 1; //Intersect with common\n\n      for (var j = 0; j < commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n\n      if (color !== 0) {\n        //Intersect with red\n        for (var j = 0; j < redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id);\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n\n      if (color !== 1) {\n        //Intersect with blue\n        for (var j = 0; j < blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id);\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n\n      if (color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);\n      } else if (color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);\n      } else if (color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);\n      }\n    } else {\n      //Destroy event\n      var id = (e >> 1) - 1;\n\n      if (color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);\n      } else if (color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);\n      } else if (color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);\n      }\n    }\n  }\n} //Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\n\n\nfunction scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = axis;\n  var iend = axis + d;\n  var redShift = 1;\n  var blueShift = 1;\n\n  if (flip) {\n    blueShift = BLUE_FLAG;\n  } else {\n    redShift = BLUE_FLAG;\n  }\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = i + redShift;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = i + blueShift;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n    if (e < 0) {\n      var idx = -e;\n      var isRed = false;\n\n      if (idx >= BLUE_FLAG) {\n        isRed = !flip;\n        idx -= BLUE_FLAG;\n      } else {\n        isRed = !!flip;\n        idx -= 1;\n      }\n\n      if (isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);\n      } else {\n        var blueId = blueIndex[idx];\n        var bluePtr = elemSize * idx;\n        var b0 = blue[bluePtr + axis + 1];\n        var b1 = blue[bluePtr + axis + 1 + d];\n\n        red_loop: for (var j = 0; j < redActive; ++j) {\n          var oidx = RED_SWEEP_QUEUE[j];\n          var redPtr = elemSize * oidx;\n\n          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n            continue;\n          }\n\n          for (var k = axis + 2; k < d; ++k) {\n            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop;\n            }\n          }\n\n          var redId = redIndex[oidx];\n          var retval;\n\n          if (flip) {\n            retval = visit(blueId, redId);\n          } else {\n            retval = visit(redId, blueId);\n          }\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);\n    }\n  }\n}\n\nfunction scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = axis;\n  var iend = axis + d;\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = i + BLUE_FLAG;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = i + 1;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n    if (e < 0) {\n      var idx = -e;\n\n      if (idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;\n      } else {\n        idx -= 1;\n        var blueId = blueIndex[idx];\n        var bluePtr = elemSize * idx;\n        var b0 = blue[bluePtr + axis + 1];\n        var b1 = blue[bluePtr + axis + 1 + d];\n\n        red_loop: for (var j = 0; j < redActive; ++j) {\n          var oidx = RED_SWEEP_QUEUE[j];\n          var redId = redIndex[oidx];\n\n          if (redId === blueId) {\n            break;\n          }\n\n          var redPtr = elemSize * oidx;\n\n          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n            continue;\n          }\n\n          for (var k = axis + 2; k < d; ++k) {\n            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop;\n            }\n          }\n\n          var retval = visit(redId, blueId);\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG;\n\n      for (var j = redActive - 1; j >= 0; --j) {\n        if (RED_SWEEP_QUEUE[j] === idx) {\n          for (var k = j + 1; k < redActive; ++k) {\n            RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];\n          }\n\n          break;\n        }\n      }\n\n      --redActive;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/box-intersect/lib/sweep.js"],"names":["module","exports","init","sqInit","sweepBipartite","sweepComplete","scanBipartite","scanComplete","pool","require","bits","isort","BLUE_FLAG","INIT_CAPACITY","RED_SWEEP_QUEUE","mallocInt32","RED_SWEEP_INDEX","BLUE_SWEEP_QUEUE","BLUE_SWEEP_INDEX","COMMON_SWEEP_QUEUE","COMMON_SWEEP_INDEX","SWEEP_EVENTS","mallocDouble","count","rcount","nextPow2","length","free","eventLength","sqPop","queue","index","item","idx","top","sqPush","d","visit","redStart","redEnd","red","redIndex","blueStart","blueEnd","blue","blueIndex","ptr","elemSize","istart","iend","i","redOffset","blueOffset","n","redActive","blueActive","e","j","retval","commonActive","color","id","axis","flip","redShift","blueShift","isRed","blueId","bluePtr","b0","b1","red_loop","oidx","redPtr","k","redId"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = {\n  init:           sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete:  sweepComplete,\n  scanBipartite:  scanBipartite,\n  scanComplete:   scanComplete\n}\n\nvar pool  = require('typedarray-pool')\nvar bits  = require('bit-twiddle')\nvar isort = require('./sort')\n\n//Flag for blue\nvar BLUE_FLAG = (1<<28)\n\n//1D sweep event queue stuff (use pool to save space)\nvar INIT_CAPACITY      = 1024\nvar RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)\nvar RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)\nvar SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)\n\n//Reserves memory for the 1D sweep data structures\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count)\n  if(RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE)\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX)\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE)\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX)\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE)\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX)\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  var eventLength = 8 * rcount\n  if(SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS)\n    SWEEP_EVENTS = pool.mallocDouble(eventLength)\n  }\n}\n\n//Remove an item from the active queue in O(1)\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item]\n  var top = queue[count-1]\n  queue[idx] = top\n  index[top] = idx\n}\n\n//Insert an item into the active queue in O(1)\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item\n  index[item]  = count\n}\n\n//Recursion base case: use 1D sweep algorithm\nfunction sweepBipartite(\n    d, visit,\n    redStart,  redEnd, red, redIndex,\n    blueStart, blueEnd, blue, blueIndex) {\n\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = redIndex[i]\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -(idx+1)\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = blueIndex[i]+BLUE_FLAG\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive  = 0\n  var blueActive = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e >= BLUE_FLAG) {\n      //blue destroy event\n      e = (e-BLUE_FLAG)|0\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)\n    } else if(e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)\n    } else if(e <= -BLUE_FLAG) {\n      //blue create event\n      e = (-e-BLUE_FLAG)|0\n      for(var j=0; j<redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)\n    } else {\n      //red create event\n      e = (-e-1)|0\n      for(var j=0; j<blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j])\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)\n    }\n  }\n}\n\n//Complete sweep\nfunction sweepComplete(d, visit, \n  redStart, redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = (redIndex[i]+1)<<1\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = (blueIndex[i]+1)<<1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = (-idx)|1\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx|1\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  var blueActive   = 0\n  var commonActive = 0\n  for(var i=0; i<n; ++i) {\n    var e     = SWEEP_EVENTS[2*i+1]|0\n    var color = e&1\n    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {\n      color = 2\n      i += 1\n    }\n    \n    if(e < 0) {\n      //Create event\n      var id = -(e>>1) - 1\n\n      //Intersect with common\n      for(var j=0; j<commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n\n      if(color !== 0) {\n        //Intersect with red\n        for(var j=0; j<redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color !== 1) {\n        //Intersect with blue\n        for(var j=0; j<blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)\n      } else if(color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)\n      } else if(color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)\n      }\n    } else {\n      //Destroy event\n      var id = (e>>1) - 1\n      if(color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)\n      } else if(color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)\n      } else if(color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)\n      }\n    }\n  }\n}\n\n//Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\nfunction scanBipartite(\n  d, axis, visit, flip,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n  \n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  var redShift  = 1\n  var blueShift = 1\n  if(flip) {\n    blueShift = BLUE_FLAG\n  } else {\n    redShift  = BLUE_FLAG\n  }\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + redShift\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + blueShift\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      var isRed = false\n      if(idx >= BLUE_FLAG) {\n        isRed = !flip\n        idx -= BLUE_FLAG \n      } else {\n        isRed = !!flip\n        idx -= 1\n      }\n      if(isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)\n      } else {\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n        \n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redPtr = elemSize * oidx\n\n          if(b1 < red[redPtr+axis+1] || \n             red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var redId  = redIndex[oidx]\n          var retval\n          if(flip) {\n            retval = visit(blueId, redId)\n          } else {\n            retval = visit(redId, blueId)\n          }\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)\n    }\n  }\n}\n\nfunction scanComplete(\n  d, axis, visit,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + BLUE_FLAG\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + 1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      if(idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG\n      } else {\n        idx -= 1\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n\n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redId  = redIndex[oidx]\n\n          if(redId === blueId) {\n            break\n          }\n\n          var redPtr = elemSize * oidx\n          if(b1 < red[redPtr+axis+1] || \n            red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d]   < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var retval = visit(redId, blueId)\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG\n      for(var j=redActive-1; j>=0; --j) {\n        if(RED_SWEEP_QUEUE[j] === idx) {\n          for(var k=j+1; k<redActive; ++k) {\n            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]\n          }\n          break\n        }\n      }\n      --redActive\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}