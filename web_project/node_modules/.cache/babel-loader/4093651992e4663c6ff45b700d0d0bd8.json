{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar helpers = require('../sunburst/helpers');\n\nvar Lib = require('../../lib');\n\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\n\nvar barPlot = require('../bar/plot');\n\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\n\nvar uniformText = require('../bar/uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar resizeText = require('../bar/style').resizeText;\n\nvar constants = require('./constants');\n\nvar drawDescendants = require('./draw_descendants');\n\nvar drawAncestors = require('./draw_ancestors');\n\nmodule.exports = function (gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var layer = fullLayout._treemaplayer;\n  var join, onComplete; // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n\n  var isFullReplot = !transitionOpts;\n  clearMinTextSize('treemap', fullLayout);\n  join = layer.selectAll('g.trace.treemap').data(cdmodule, function (cd) {\n    return cd[0].trace.uid;\n  });\n  join.enter().append('g').classed('trace', true).classed('treemap', true);\n  join.order();\n\n  if (!fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts)) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      layer.selectAll('g.trace').each(function (cd) {\n        plotOne(gd, cd, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (cd) {\n      plotOne(gd, cd, this, transitionOpts);\n    });\n\n    if (fullLayout.uniformtext.mode) {\n      resizeText(gd, fullLayout._treemaplayer.selectAll('.trace'), 'treemap');\n    }\n  }\n\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n};\n\nfunction getKey(pt) {\n  return helpers.isHierarchyRoot(pt) ? '' : // don't use the dummyId\n  helpers.getPtId(pt);\n}\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var gTrace = d3.select(element);\n  var selAncestors = gTrace.selectAll('g.pathbar');\n  var selDescendants = gTrace.selectAll('g.slice');\n\n  if (!entry) {\n    selAncestors.remove();\n    selDescendants.remove();\n    return;\n  }\n\n  var isRoot = helpers.isHierarchyRoot(entry);\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  var maxDepth = helpers.getMaxDepth(trace);\n\n  var hasVisibleDepth = function (pt) {\n    return pt.data.depth - entry.data.depth < maxDepth;\n  };\n\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var barW = vpw;\n  var barH = trace.pathbar.thickness;\n  var barPad = trace.marker.line.width + constants.gapWithPathbar;\n  var barDifY = !trace.pathbar.visible ? 0 : trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n  var pathbarOrigin = {\n    x0: barW,\n    // slide to the right\n    x1: barW,\n    y0: barDifY,\n    y1: barDifY + barH\n  };\n\n  var findClosestEdge = function (pt, ref, size) {\n    var e = trace.tiling.pad;\n\n    var isLeftOfRect = function (x) {\n      return x - e <= ref.x0;\n    };\n\n    var isRightOfRect = function (x) {\n      return x + e >= ref.x1;\n    };\n\n    var isBottomOfRect = function (y) {\n      return y - e <= ref.y0;\n    };\n\n    var isTopOfRect = function (y) {\n      return y + e >= ref.y1;\n    };\n\n    return {\n      x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n      x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n      y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n      y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n    };\n  }; // stash of 'previous' position data used by tweening functions\n\n\n  var prevEntry = null;\n  var prevLookupPathbar = {};\n  var prevLookupSlices = {};\n  var nextOfPrevEntry = null;\n\n  var getPrev = function (pt, onPathbar) {\n    return onPathbar ? prevLookupPathbar[getKey(pt)] : prevLookupSlices[getKey(pt)];\n  };\n\n  var getOrigin = function (pt, onPathbar, refRect, size) {\n    if (onPathbar) {\n      return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n    } else {\n      var ref = prevLookupSlices[trace.level] || refRect;\n\n      if (hasVisibleDepth(pt)) {\n        // case of an empty object - happens when maxdepth is set\n        return findClosestEdge(pt, ref, size);\n      }\n    }\n\n    return {};\n  }; // N.B. handle multiple-root special case\n\n\n  if (cd0.hasMultipleRoots && isRoot) {\n    maxDepth++;\n  }\n\n  trace._maxDepth = maxDepth;\n  trace._backgroundColor = fullLayout.paper_bgcolor;\n  trace._entryDepth = entry.data.depth;\n  trace._atRootLevel = isRoot;\n  var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n\n  var viewMapX = function (x) {\n    return cenX + x;\n  };\n\n  var viewMapY = function (y) {\n    return cenY + y;\n  };\n\n  var barY0 = viewMapY(0);\n  var barX0 = viewMapX(0);\n\n  var viewBarX = function (x) {\n    return barX0 + x;\n  };\n\n  var viewBarY = function (y) {\n    return barY0 + y;\n  };\n\n  function pos(x, y) {\n    return x + ',' + y;\n  }\n\n  var xStart = viewBarX(0);\n\n  var limitX0 = function (p) {\n    p.x = Math.max(xStart, p.x);\n  };\n\n  var edgeshape = trace.pathbar.edgeshape; // pathbar(directory) path generation fn\n\n  var pathAncestor = function (d) {\n    var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n\n    var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n\n    var _y0 = viewBarY(d.y0);\n\n    var _y1 = viewBarY(d.y1);\n\n    var halfH = barH / 2;\n    var pL = {};\n    var pR = {};\n    pL.x = _x0;\n    pR.x = _x1;\n    pL.y = pR.y = (_y0 + _y1) / 2;\n    var pA = {\n      x: _x0,\n      y: _y0\n    };\n    var pB = {\n      x: _x1,\n      y: _y0\n    };\n    var pC = {\n      x: _x1,\n      y: _y1\n    };\n    var pD = {\n      x: _x0,\n      y: _y1\n    };\n\n    if (edgeshape === '>') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pC.x -= halfH;\n      pD.x -= halfH;\n    } else if (edgeshape === '/') {\n      pC.x -= halfH;\n      pD.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '\\\\') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '<') {\n      pL.x -= halfH;\n      pR.x -= halfH;\n    }\n\n    limitX0(pA);\n    limitX0(pD);\n    limitX0(pL);\n    limitX0(pB);\n    limitX0(pC);\n    limitX0(pR);\n    return 'M' + pos(pA.x, pA.y) + 'L' + pos(pB.x, pB.y) + 'L' + pos(pR.x, pR.y) + 'L' + pos(pC.x, pC.y) + 'L' + pos(pD.x, pD.y) + 'L' + pos(pL.x, pL.y) + 'Z';\n  }; // slice path generation fn\n\n\n  var pathDescendant = function (d) {\n    var _x0 = viewMapX(d.x0);\n\n    var _x1 = viewMapX(d.x1);\n\n    var _y0 = viewMapY(d.y0);\n\n    var _y1 = viewMapY(d.y1);\n\n    var dx = _x1 - _x0;\n    var dy = _y1 - _y0;\n    if (!dx || !dy) return '';\n    var FILLET = 0; // TODO: may expose this constant\n\n    var r = dx > 2 * FILLET && dy > 2 * FILLET ? FILLET : 0;\n\n    var arc = function (rx, ry) {\n      return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : '';\n    };\n\n    return 'M' + pos(_x0, _y0 + r) + arc(r, -r) + 'L' + pos(_x1 - r, _y0) + arc(r, r) + 'L' + pos(_x1, _y1 - r) + arc(-r, r) + 'L' + pos(_x0 + r, _y1) + arc(-r, -r) + 'Z';\n  };\n\n  var toMoveInsideSlice = function (pt, opts) {\n    var x0 = pt.x0;\n    var x1 = pt.x1;\n    var y0 = pt.y0;\n    var y1 = pt.y1;\n    var textBB = pt.textBB;\n\n    var hasFlag = function (f) {\n      return trace.textposition.indexOf(f) !== -1;\n    };\n\n    var hasBottom = hasFlag('bottom');\n    var hasTop = hasFlag('top') || opts.isHeader && !hasBottom;\n    var anchor = hasTop ? 'start' : hasBottom ? 'end' : 'middle';\n    var hasRight = hasFlag('right');\n    var hasLeft = hasFlag('left') || opts.onPathbar;\n    var leftToRight = hasLeft ? -1 : hasRight ? 1 : 0;\n    var pad = trace.marker.pad;\n\n    if (opts.isHeader) {\n      x0 += pad.l - TEXTPAD;\n      x1 -= pad.r - TEXTPAD;\n\n      if (x0 >= x1) {\n        var mid = (x0 + x1) / 2;\n        x0 = mid;\n        x1 = mid;\n      } // limit the drawing area for headers\n\n\n      var limY;\n\n      if (hasBottom) {\n        limY = y1 - pad.b;\n        if (y0 < limY && limY < y1) y0 = limY;\n      } else {\n        limY = y0 + pad.t;\n        if (y0 < limY && limY < y1) y1 = limY;\n      }\n    } // position the text relative to the slice\n\n\n    var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: false,\n      constrained: true,\n      angle: 0,\n      anchor: anchor,\n      leftToRight: leftToRight\n    });\n    transform.fontSize = opts.fontSize;\n    transform.targetX = viewMapX(transform.targetX);\n    transform.targetY = viewMapY(transform.targetY);\n\n    if (isNaN(transform.targetX) || isNaN(transform.targetY)) {\n      return {};\n    }\n\n    if (x0 !== x1 && y0 !== y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return {\n      scale: transform.scale,\n      rotate: transform.rotate,\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY\n    };\n  };\n\n  var interpFromParent = function (pt, onPathbar) {\n    var parentPrev;\n    var i = 0;\n    var Q = pt;\n\n    while (!parentPrev && i < maxDepth) {\n      // loop to find a parent/grandParent on the previous graph\n      i++;\n      Q = Q.parent;\n\n      if (Q) {\n        parentPrev = getPrev(Q, onPathbar);\n      } else i = maxDepth;\n    }\n\n    return parentPrev || {};\n  };\n\n  var makeExitSliceInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev = getPrev(pt, onPathbar);\n    var next;\n\n    if (onPathbar) {\n      next = pathbarOrigin;\n    } else {\n      var entryPrev = getPrev(entry, onPathbar);\n\n      if (entryPrev) {\n        // 'entryPrev' is here has the previous coordinates of the entry\n        // node, which corresponds to the last \"clicked\" node when zooming in\n        next = findClosestEdge(pt, entryPrev, size);\n      } else {\n        // this happens when maxdepth is set, when leaves must\n        // be removed and the entry is new (i.e. does not have a 'prev' object)\n        next = {};\n      }\n    }\n\n    return d3.interpolate(prev, next);\n  };\n\n  var makeUpdateSliceInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev;\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (onPathbar) {\n        prev = pathbarOrigin;\n      } else {\n        if (prevEntry) {\n          // if trace was visible before\n          if (pt.parent) {\n            var ref = nextOfPrevEntry || refRect;\n\n            if (ref && !onPathbar) {\n              prev = findClosestEdge(pt, ref, size);\n            } else {\n              // if new leaf (when maxdepth is set),\n              // grow it from its parent node\n              prev = {};\n              Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n          } else {\n            prev = pt;\n          }\n        } else {\n          prev = {};\n        }\n      }\n    }\n\n    return d3.interpolate(prev, {\n      x0: pt.x0,\n      x1: pt.x1,\n      y0: pt.y0,\n      y1: pt.y1\n    });\n  };\n\n  var makeUpdateTextInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev = {};\n    var origin = getOrigin(pt, onPathbar, refRect, size);\n    Lib.extendFlat(prev, {\n      transform: toMoveInsideSlice({\n        x0: origin.x0,\n        x1: origin.x1,\n        y0: origin.y0,\n        y1: origin.y1,\n        textBB: pt.textBB,\n        _text: pt._text\n      }, {\n        isHeader: helpers.isHeader(pt, trace)\n      })\n    });\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (pt.parent) {\n        Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n      }\n    }\n\n    var transform = pt.transform;\n\n    if (pt.x0 !== pt.x1 && pt.y0 !== pt.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return d3.interpolate(prev, {\n      transform: {\n        scale: transform.scale,\n        rotate: transform.rotate,\n        textX: transform.textX,\n        textY: transform.textY,\n        anchorX: transform.anchorX,\n        anchorY: transform.anchorY,\n        targetX: transform.targetX,\n        targetY: transform.targetY\n      }\n    });\n  };\n\n  var handleSlicesExit = function (slices, onPathbar, refRect, size, pathSlice) {\n    var width = size[0];\n    var height = size[1];\n\n    if (hasTransition) {\n      slices.exit().transition().each(function () {\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.select('path.surface');\n        slicePath.transition().attrTween('d', function (pt2) {\n          var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n          return function (t) {\n            return pathSlice(interp(t));\n          };\n        });\n        var sliceTextGroup = sliceTop.select('g.slicetext');\n        sliceTextGroup.attr('opacity', 0);\n      }).remove();\n    } else {\n      slices.exit().remove();\n    }\n  };\n\n  var strTransform = function (d) {\n    var transform = d.transform;\n\n    if (d.x0 !== d.x1 && d.y0 !== d.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return Lib.getTextTransform({\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY,\n      scale: transform.scale,\n      rotate: transform.rotate\n    });\n  };\n\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    selAncestors.each(function (pt) {\n      prevLookupPathbar[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupPathbar[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n    });\n    selDescendants.each(function (pt) {\n      prevLookupSlices[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupSlices[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  }\n\n  nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n    width: vpw,\n    height: vph,\n    viewX: viewMapX,\n    viewY: viewMapY,\n    pathSlice: pathDescendant,\n    toMoveInsideSlice: toMoveInsideSlice,\n    prevEntry: prevEntry,\n    makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n    makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n    handleSlicesExit: handleSlicesExit,\n    hasTransition: hasTransition,\n    strTransform: strTransform\n  });\n\n  if (trace.pathbar.visible) {\n    drawAncestors(gd, cd, entry, selAncestors, {\n      barDifY: barDifY,\n      width: barW,\n      height: barH,\n      viewX: viewBarX,\n      viewY: viewBarY,\n      pathSlice: pathAncestor,\n      toMoveInsideSlice: toMoveInsideSlice,\n      makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n      makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n      handleSlicesExit: handleSlicesExit,\n      hasTransition: hasTransition,\n      strTransform: strTransform\n    });\n  } else {\n    selAncestors.remove();\n  }\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/treemap/plot.js"],"names":["d3","require","helpers","Lib","TEXTPAD","barPlot","toMoveInsideBar","uniformText","recordMinTextSize","clearMinTextSize","resizeText","constants","drawDescendants","drawAncestors","module","exports","gd","cdmodule","transitionOpts","makeOnCompleteCallback","fullLayout","_fullLayout","layer","_treemaplayer","join","onComplete","isFullReplot","selectAll","data","cd","trace","uid","enter","append","classed","order","uniformtext","mode","hasTransition","transition","duration","ease","easing","each","plotOne","exit","remove","getKey","pt","isHierarchyRoot","getPtId","element","cd0","hierarchy","entry","findEntryWithLevel","level","gTrace","select","selAncestors","selDescendants","isRoot","maxDepth","getMaxDepth","hasVisibleDepth","depth","gs","_size","domain","vpw","w","x","vph","h","y","barW","barH","pathbar","thickness","barPad","marker","line","width","gapWithPathbar","barDifY","visible","side","indexOf","pathbarOrigin","x0","x1","y0","y1","findClosestEdge","ref","size","e","tiling","pad","isLeftOfRect","isRightOfRect","isBottomOfRect","isTopOfRect","prevEntry","prevLookupPathbar","prevLookupSlices","nextOfPrevEntry","getPrev","onPathbar","getOrigin","refRect","hasMultipleRoots","_maxDepth","_backgroundColor","paper_bgcolor","_entryDepth","_atRootLevel","cenX","l","cenY","t","viewMapX","viewMapY","barY0","barX0","viewBarX","viewBarY","pos","xStart","limitX0","p","Math","max","edgeshape","pathAncestor","d","_x0","min","_x1","_y0","_y1","halfH","pL","pR","pA","pB","pC","pD","pathDescendant","dx","dy","FILLET","r","arc","rx","ry","toMoveInsideSlice","opts","textBB","hasFlag","f","textposition","hasBottom","hasTop","isHeader","anchor","hasRight","hasLeft","leftToRight","mid","limY","b","transform","isHorizontal","constrained","angle","fontSize","targetX","targetY","isNaN","type","scale","rotate","textX","textY","anchorX","anchorY","interpFromParent","parentPrev","i","Q","parent","makeExitSliceInterpolator","prev","next","entryPrev","interpolate","makeUpdateSliceInterpolator","prev0","extendFlat","makeUpdateTextInterpolator","origin","_text","handleSlicesExit","slices","pathSlice","height","sliceTop","slicePath","attrTween","pt2","interp","sliceTextGroup","attr","strTransform","getTextTransform","isEntry","viewX","viewY"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar helpers = require('../sunburst/helpers');\n\nvar Lib = require('../../lib');\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\nvar barPlot = require('../bar/plot');\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar resizeText = require('../bar/style').resizeText;\nvar constants = require('./constants');\nvar drawDescendants = require('./draw_descendants');\nvar drawAncestors = require('./draw_ancestors');\n\nmodule.exports = function(gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout;\n    var layer = fullLayout._treemaplayer;\n    var join, onComplete;\n\n    // If transition config is provided, then it is only a partial replot and traces not\n    // updated are removed.\n    var isFullReplot = !transitionOpts;\n\n    clearMinTextSize('treemap', fullLayout);\n\n    join = layer.selectAll('g.trace.treemap')\n        .data(cdmodule, function(cd) { return cd[0].trace.uid; });\n\n    join.enter().append('g')\n        .classed('trace', true)\n        .classed('treemap', true);\n\n    join.order();\n\n    if(!fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts)) {\n        if(makeOnCompleteCallback) {\n            // If it was passed a callback to register completion, make a callback. If\n            // this is created, then it must be executed on completion, otherwise the\n            // pos-transition redraw will not execute:\n            onComplete = makeOnCompleteCallback();\n        }\n\n        var transition = d3.transition()\n            .duration(transitionOpts.duration)\n            .ease(transitionOpts.easing)\n            .each('end', function() { onComplete && onComplete(); })\n            .each('interrupt', function() { onComplete && onComplete(); });\n\n        transition.each(function() {\n            // Must run the selection again since otherwise enters/updates get grouped together\n            // and these get executed out of order. Except we need them in order!\n            layer.selectAll('g.trace').each(function(cd) {\n                plotOne(gd, cd, this, transitionOpts);\n            });\n        });\n    } else {\n        join.each(function(cd) {\n            plotOne(gd, cd, this, transitionOpts);\n        });\n\n        if(fullLayout.uniformtext.mode) {\n            resizeText(gd, fullLayout._treemaplayer.selectAll('.trace'), 'treemap');\n        }\n    }\n\n    if(isFullReplot) {\n        join.exit().remove();\n    }\n};\n\nfunction getKey(pt) {\n    return helpers.isHierarchyRoot(pt) ?\n        '' : // don't use the dummyId\n        helpers.getPtId(pt);\n}\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n    var fullLayout = gd._fullLayout;\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var hierarchy = cd0.hierarchy;\n    var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n\n    var gTrace = d3.select(element);\n    var selAncestors = gTrace.selectAll('g.pathbar');\n    var selDescendants = gTrace.selectAll('g.slice');\n\n    if(!entry) {\n        selAncestors.remove();\n        selDescendants.remove();\n        return;\n    }\n\n    var isRoot = helpers.isHierarchyRoot(entry);\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    var maxDepth = helpers.getMaxDepth(trace);\n    var hasVisibleDepth = function(pt) {\n        return pt.data.depth - entry.data.depth < maxDepth;\n    };\n\n    var gs = fullLayout._size;\n    var domain = trace.domain;\n\n    var vpw = gs.w * (domain.x[1] - domain.x[0]);\n    var vph = gs.h * (domain.y[1] - domain.y[0]);\n    var barW = vpw;\n    var barH = trace.pathbar.thickness;\n    var barPad = trace.marker.line.width + constants.gapWithPathbar;\n    var barDifY = !trace.pathbar.visible ? 0 :\n        trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n\n    var pathbarOrigin = {\n        x0: barW, // slide to the right\n        x1: barW,\n        y0: barDifY,\n        y1: barDifY + barH\n    };\n\n    var findClosestEdge = function(pt, ref, size) {\n        var e = trace.tiling.pad;\n        var isLeftOfRect = function(x) { return x - e <= ref.x0; };\n        var isRightOfRect = function(x) { return x + e >= ref.x1; };\n        var isBottomOfRect = function(y) { return y - e <= ref.y0; };\n        var isTopOfRect = function(y) { return y + e >= ref.y1; };\n\n        return {\n            x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n            x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n            y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n            y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n        };\n    };\n\n    // stash of 'previous' position data used by tweening functions\n    var prevEntry = null;\n    var prevLookupPathbar = {};\n    var prevLookupSlices = {};\n    var nextOfPrevEntry = null;\n    var getPrev = function(pt, onPathbar) {\n        return onPathbar ?\n            prevLookupPathbar[getKey(pt)] :\n            prevLookupSlices[getKey(pt)];\n    };\n\n    var getOrigin = function(pt, onPathbar, refRect, size) {\n        if(onPathbar) {\n            return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n        } else {\n            var ref = prevLookupSlices[trace.level] || refRect;\n\n            if(hasVisibleDepth(pt)) { // case of an empty object - happens when maxdepth is set\n                return findClosestEdge(pt, ref, size);\n            }\n        }\n        return {};\n    };\n\n    // N.B. handle multiple-root special case\n    if(cd0.hasMultipleRoots && isRoot) {\n        maxDepth++;\n    }\n\n    trace._maxDepth = maxDepth;\n    trace._backgroundColor = fullLayout.paper_bgcolor;\n    trace._entryDepth = entry.data.depth;\n    trace._atRootLevel = isRoot;\n\n    var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n    var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n\n    var viewMapX = function(x) { return cenX + x; };\n    var viewMapY = function(y) { return cenY + y; };\n\n    var barY0 = viewMapY(0);\n    var barX0 = viewMapX(0);\n\n    var viewBarX = function(x) { return barX0 + x; };\n    var viewBarY = function(y) { return barY0 + y; };\n\n    function pos(x, y) {\n        return x + ',' + y;\n    }\n\n    var xStart = viewBarX(0);\n    var limitX0 = function(p) { p.x = Math.max(xStart, p.x); };\n\n    var edgeshape = trace.pathbar.edgeshape;\n\n    // pathbar(directory) path generation fn\n    var pathAncestor = function(d) {\n        var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n        var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n        var _y0 = viewBarY(d.y0);\n        var _y1 = viewBarY(d.y1);\n\n        var halfH = barH / 2;\n\n        var pL = {};\n        var pR = {};\n\n        pL.x = _x0;\n        pR.x = _x1;\n\n        pL.y = pR.y = (_y0 + _y1) / 2;\n\n        var pA = {x: _x0, y: _y0};\n        var pB = {x: _x1, y: _y0};\n        var pC = {x: _x1, y: _y1};\n        var pD = {x: _x0, y: _y1};\n\n        if(edgeshape === '>') {\n            pA.x -= halfH;\n            pB.x -= halfH;\n            pC.x -= halfH;\n            pD.x -= halfH;\n        } else if(edgeshape === '/') {\n            pC.x -= halfH;\n            pD.x -= halfH;\n            pL.x -= halfH / 2;\n            pR.x -= halfH / 2;\n        } else if(edgeshape === '\\\\') {\n            pA.x -= halfH;\n            pB.x -= halfH;\n            pL.x -= halfH / 2;\n            pR.x -= halfH / 2;\n        } else if(edgeshape === '<') {\n            pL.x -= halfH;\n            pR.x -= halfH;\n        }\n\n        limitX0(pA);\n        limitX0(pD);\n        limitX0(pL);\n\n        limitX0(pB);\n        limitX0(pC);\n        limitX0(pR);\n\n        return (\n           'M' + pos(pA.x, pA.y) +\n           'L' + pos(pB.x, pB.y) +\n           'L' + pos(pR.x, pR.y) +\n           'L' + pos(pC.x, pC.y) +\n           'L' + pos(pD.x, pD.y) +\n           'L' + pos(pL.x, pL.y) +\n           'Z'\n        );\n    };\n\n    // slice path generation fn\n    var pathDescendant = function(d) {\n        var _x0 = viewMapX(d.x0);\n        var _x1 = viewMapX(d.x1);\n        var _y0 = viewMapY(d.y0);\n        var _y1 = viewMapY(d.y1);\n\n        var dx = _x1 - _x0;\n        var dy = _y1 - _y0;\n        if(!dx || !dy) return '';\n\n        var FILLET = 0; // TODO: may expose this constant\n\n        var r = (\n            dx > 2 * FILLET &&\n            dy > 2 * FILLET\n        ) ? FILLET : 0;\n\n        var arc = function(rx, ry) { return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : ''; };\n\n        return (\n           'M' + pos(_x0, _y0 + r) +\n           arc(r, -r) +\n           'L' + pos(_x1 - r, _y0) +\n           arc(r, r) +\n           'L' + pos(_x1, _y1 - r) +\n           arc(-r, r) +\n           'L' + pos(_x0 + r, _y1) +\n           arc(-r, -r) + 'Z'\n        );\n    };\n\n    var toMoveInsideSlice = function(pt, opts) {\n        var x0 = pt.x0;\n        var x1 = pt.x1;\n        var y0 = pt.y0;\n        var y1 = pt.y1;\n        var textBB = pt.textBB;\n\n        var hasFlag = function(f) { return trace.textposition.indexOf(f) !== -1; };\n\n        var hasBottom = hasFlag('bottom');\n        var hasTop = hasFlag('top') || (opts.isHeader && !hasBottom);\n\n        var anchor =\n            hasTop ? 'start' :\n            hasBottom ? 'end' : 'middle';\n\n        var hasRight = hasFlag('right');\n        var hasLeft = hasFlag('left') || opts.onPathbar;\n\n        var leftToRight =\n            hasLeft ? -1 :\n            hasRight ? 1 : 0;\n\n        var pad = trace.marker.pad;\n        if(opts.isHeader) {\n            x0 += pad.l - TEXTPAD;\n            x1 -= pad.r - TEXTPAD;\n            if(x0 >= x1) {\n                var mid = (x0 + x1) / 2;\n                x0 = mid;\n                x1 = mid;\n            }\n\n            // limit the drawing area for headers\n            var limY;\n            if(hasBottom) {\n                limY = y1 - pad.b;\n                if(y0 < limY && limY < y1) y0 = limY;\n            } else {\n                limY = y0 + pad.t;\n                if(y0 < limY && limY < y1) y1 = limY;\n            }\n        }\n\n        // position the text relative to the slice\n        var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: false,\n            constrained: true,\n            angle: 0,\n            anchor: anchor,\n            leftToRight: leftToRight\n        });\n        transform.fontSize = opts.fontSize;\n\n        transform.targetX = viewMapX(transform.targetX);\n        transform.targetY = viewMapY(transform.targetY);\n\n        if(isNaN(transform.targetX) || isNaN(transform.targetY)) {\n            return {};\n        }\n\n        if(x0 !== x1 && y0 !== y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return {\n            scale: transform.scale,\n            rotate: transform.rotate,\n            textX: transform.textX,\n            textY: transform.textY,\n            anchorX: transform.anchorX,\n            anchorY: transform.anchorY,\n            targetX: transform.targetX,\n            targetY: transform.targetY\n        };\n    };\n\n    var interpFromParent = function(pt, onPathbar) {\n        var parentPrev;\n        var i = 0;\n        var Q = pt;\n        while(!parentPrev && i < maxDepth) { // loop to find a parent/grandParent on the previous graph\n            i++;\n            Q = Q.parent;\n            if(Q) {\n                parentPrev = getPrev(Q, onPathbar);\n            } else i = maxDepth;\n        }\n        return parentPrev || {};\n    };\n\n    var makeExitSliceInterpolator = function(pt, onPathbar, refRect, size) {\n        var prev = getPrev(pt, onPathbar);\n        var next;\n\n        if(onPathbar) {\n            next = pathbarOrigin;\n        } else {\n            var entryPrev = getPrev(entry, onPathbar);\n            if(entryPrev) {\n                // 'entryPrev' is here has the previous coordinates of the entry\n                // node, which corresponds to the last \"clicked\" node when zooming in\n                next = findClosestEdge(pt, entryPrev, size);\n            } else {\n                // this happens when maxdepth is set, when leaves must\n                // be removed and the entry is new (i.e. does not have a 'prev' object)\n                next = {};\n            }\n        }\n\n        return d3.interpolate(prev, next);\n    };\n\n    var makeUpdateSliceInterpolator = function(pt, onPathbar, refRect, size) {\n        var prev0 = getPrev(pt, onPathbar);\n        var prev;\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(onPathbar) {\n                prev = pathbarOrigin;\n            } else {\n                if(prevEntry) {\n                    // if trace was visible before\n                    if(pt.parent) {\n                        var ref = nextOfPrevEntry || refRect;\n\n                        if(ref && !onPathbar) {\n                            prev = findClosestEdge(pt, ref, size);\n                        } else {\n                            // if new leaf (when maxdepth is set),\n                            // grow it from its parent node\n                            prev = {};\n                            Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n                        }\n                    } else {\n                        prev = pt;\n                    }\n                } else {\n                    prev = {};\n                }\n            }\n        }\n\n        return d3.interpolate(prev, {\n            x0: pt.x0,\n            x1: pt.x1,\n            y0: pt.y0,\n            y1: pt.y1\n        });\n    };\n\n    var makeUpdateTextInterpolator = function(pt, onPathbar, refRect, size) {\n        var prev0 = getPrev(pt, onPathbar);\n        var prev = {};\n        var origin = getOrigin(pt, onPathbar, refRect, size);\n\n        Lib.extendFlat(prev, {\n            transform: toMoveInsideSlice({\n                x0: origin.x0,\n                x1: origin.x1,\n                y0: origin.y0,\n                y1: origin.y1,\n                textBB: pt.textBB,\n                _text: pt._text\n            }, {\n                isHeader: helpers.isHeader(pt, trace)\n            })\n        });\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(pt.parent) {\n                Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n        }\n\n        var transform = pt.transform;\n        if(pt.x0 !== pt.x1 && pt.y0 !== pt.y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return d3.interpolate(prev, {\n            transform: {\n                scale: transform.scale,\n                rotate: transform.rotate,\n                textX: transform.textX,\n                textY: transform.textY,\n                anchorX: transform.anchorX,\n                anchorY: transform.anchorY,\n                targetX: transform.targetX,\n                targetY: transform.targetY\n            }\n        });\n    };\n\n    var handleSlicesExit = function(slices, onPathbar, refRect, size, pathSlice) {\n        var width = size[0];\n        var height = size[1];\n\n        if(hasTransition) {\n            slices.exit().transition()\n                .each(function() {\n                    var sliceTop = d3.select(this);\n\n                    var slicePath = sliceTop.select('path.surface');\n                    slicePath.transition().attrTween('d', function(pt2) {\n                        var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n                        return function(t) { return pathSlice(interp(t)); };\n                    });\n\n                    var sliceTextGroup = sliceTop.select('g.slicetext');\n                    sliceTextGroup.attr('opacity', 0);\n                })\n                .remove();\n        } else {\n            slices.exit().remove();\n        }\n    };\n\n    var strTransform = function(d) {\n        var transform = d.transform;\n\n        if(d.x0 !== d.x1 && d.y0 !== d.y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return Lib.getTextTransform({\n            textX: transform.textX,\n            textY: transform.textY,\n            anchorX: transform.anchorX,\n            anchorY: transform.anchorY,\n            targetX: transform.targetX,\n            targetY: transform.targetY,\n            scale: transform.scale,\n            rotate: transform.rotate\n        });\n    };\n\n    if(hasTransition) {\n        // Important: do this before binding new sliceData!\n\n        selAncestors.each(function(pt) {\n            prevLookupPathbar[getKey(pt)] = {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n\n            if(pt.transform) {\n                prevLookupPathbar[getKey(pt)].transform = {\n                    textX: pt.transform.textX,\n                    textY: pt.transform.textY,\n                    anchorX: pt.transform.anchorX,\n                    anchorY: pt.transform.anchorY,\n                    targetX: pt.transform.targetX,\n                    targetY: pt.transform.targetY,\n                    scale: pt.transform.scale,\n                    rotate: pt.transform.rotate\n                };\n            }\n        });\n\n        selDescendants.each(function(pt) {\n            prevLookupSlices[getKey(pt)] = {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n\n            if(pt.transform) {\n                prevLookupSlices[getKey(pt)].transform = {\n                    textX: pt.transform.textX,\n                    textY: pt.transform.textY,\n                    anchorX: pt.transform.anchorX,\n                    anchorY: pt.transform.anchorY,\n                    targetX: pt.transform.targetX,\n                    targetY: pt.transform.targetY,\n                    scale: pt.transform.scale,\n                    rotate: pt.transform.rotate\n                };\n            }\n\n            if(!prevEntry && helpers.isEntry(pt)) {\n                prevEntry = pt;\n            }\n        });\n    }\n\n    nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n        width: vpw,\n        height: vph,\n\n        viewX: viewMapX,\n        viewY: viewMapY,\n\n        pathSlice: pathDescendant,\n        toMoveInsideSlice: toMoveInsideSlice,\n\n        prevEntry: prevEntry,\n        makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n        makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n\n        handleSlicesExit: handleSlicesExit,\n        hasTransition: hasTransition,\n        strTransform: strTransform\n    });\n\n    if(trace.pathbar.visible) {\n        drawAncestors(gd, cd, entry, selAncestors, {\n            barDifY: barDifY,\n            width: barW,\n            height: barH,\n\n            viewX: viewBarX,\n            viewY: viewBarY,\n\n            pathSlice: pathAncestor,\n            toMoveInsideSlice: toMoveInsideSlice,\n\n            makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n            makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n\n            handleSlicesExit: handleSlicesExit,\n            hasTransition: hasTransition,\n            strTransform: strTransform\n        });\n    } else {\n        selAncestors.remove();\n    }\n}\n"]},"metadata":{},"sourceType":"script"}