{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar helpers = require('@turf/helpers');\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\n\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n      k,\n      l,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      coordIndex = 0,\n      isGeometryCollection,\n      type = geojson.type,\n      isFeatureCollection = type === 'FeatureCollection',\n      isFeature = type === 'Feature',\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry\n\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon') ? 1 : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n\n        case 'Point':\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n\n        case 'LineString':\n        case 'MultiPoint':\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === 'MultiPoint') multiFeatureIndex++;\n          }\n\n          if (geomType === 'LineString') multiFeatureIndex++;\n          break;\n\n        case 'Polygon':\n        case 'MultiLineString':\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n\n            if (geomType === 'MultiLineString') multiFeatureIndex++;\n            if (geomType === 'Polygon') geometryIndex++;\n          }\n\n          if (geomType === 'Polygon') multiFeatureIndex++;\n          break;\n\n        case 'MultiPolygon':\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n\n              geometryIndex++;\n            }\n\n            multiFeatureIndex++;\n          }\n\n          break;\n\n        case 'GeometryCollection':\n          for (j = 0; j < geometry.geometries.length; j++) if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n\n          break;\n\n        default:\n          throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\n\n\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\n\n\nfunction propEach(geojson, callback) {\n  var i;\n\n  switch (geojson.type) {\n    case 'FeatureCollection':\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n\n      break;\n\n    case 'Feature':\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\n\n\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\n\n\nfunction featureEach(geojson, callback) {\n  if (geojson.type === 'Feature') {\n    callback(geojson, 0);\n  } else if (geojson.type === 'FeatureCollection') {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\n\n\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\n\n\nfunction geomEach(geojson, callback) {\n  var i,\n      j,\n      g,\n      geometry,\n      stopG,\n      geometryMaybeCollection,\n      isGeometryCollection,\n      featureProperties,\n      featureBBox,\n      featureId,\n      featureIndex = 0,\n      isFeatureCollection = geojson.type === 'FeatureCollection',\n      isFeature = geojson.type === 'Feature',\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry\n\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n\n      switch (geometry.type) {\n        case 'Point':\n        case 'LineString':\n        case 'MultiPoint':\n        case 'Polygon':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n\n        case 'GeometryCollection':\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error('Unknown Geometry Type');\n      }\n    } // Only increase `featureIndex` per each feature\n\n\n    featureIndex++;\n  }\n}\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\n\n\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\n\n\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n\n    switch (type) {\n      case null:\n      case 'Point':\n      case 'LineString':\n      case 'Polygon':\n        if (callback(helpers.feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n\n    var geomType; // Callback for multi-geometry\n\n    switch (type) {\n      case 'MultiPoint':\n        geomType = 'Point';\n        break;\n\n      case 'MultiLineString':\n        geomType = 'LineString';\n        break;\n\n      case 'MultiPolygon':\n        geomType = 'Polygon';\n        break;\n    }\n\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\n\n\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0; // Exclude null Geometries\n\n    if (!feature.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n\n    var type = feature.geometry.type;\n    if (type === 'Point' || type === 'MultiPoint') return; // Generate 2-vertex line segments\n\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n        previousCoords = currentCoord;\n        previousFeatureIndex = featureIndex;\n        previousMultiIndex = multiPartIndexCoord;\n        prevGeomIndex = geometryIndex;\n        segmentIndex = 0;\n        return;\n      }\n\n      var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\n\n\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\n\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error('geojson is required');\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n\n    switch (type) {\n      case 'LineString':\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n\n      case 'Polygon':\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n\n        break;\n    }\n  });\n}\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\n\n\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\n\n\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error('options is invalid');\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case 'FeatureCollection':\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case 'Feature':\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case 'Point':\n    case 'MultiPoint':\n      return null;\n\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error('geojson is invalid');\n  } // Find SegmentIndex\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n      return null;\n\n    case 'LineString':\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n\n    case 'Polygon':\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n\n    case 'MultiLineString':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n\n    case 'MultiPolygon':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n\n  throw new Error('geojson is invalid');\n}\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\n\n\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error('options is invalid');\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case 'FeatureCollection':\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case 'Feature':\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case 'Point':\n    case 'MultiPoint':\n      return null;\n\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error('geojson is invalid');\n  } // Find Coord Index\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case 'Point':\n      return helpers.point(coords, properties, options);\n\n    case 'MultiPoint':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n\n    case 'LineString':\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n\n    case 'Polygon':\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n\n    case 'MultiLineString':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n\n    case 'MultiPolygon':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n\n  throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/@turf/meta/index.js"],"names":["Object","defineProperty","exports","value","helpers","require","coordEach","geojson","callback","excludeWrapCoord","j","k","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","features","length","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","coordinates","geomType","Error","coordReduce","initialValue","previousValue","currentCoord","undefined","propEach","i","properties","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","coord","push","geomEach","g","featureProperties","featureBBox","featureId","bbox","id","geomReduce","currentGeometry","flattenEach","feature","coordinate","geom","flattenReduce","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","lineString","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","options","isObject","findPoint","point"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n"]},"metadata":{},"sourceType":"script"}