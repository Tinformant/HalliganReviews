{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar _ = Lib._;\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var tickLen = convertTickWidth(gd, xa, trace);\n  var minDiff = trace._minDiff;\n  trace._minDiff = null;\n  var x = trace._xcalc;\n  trace._xcalc = null;\n  var cd = calcCommon(gd, trace, x, ya, ptFunc);\n  trace._extremes[xa._id] = Axes.findExtremes(xa, x, {\n    vpad: minDiff / 2\n  });\n\n  if (cd.length) {\n    Lib.extendFlat(cd[0].t, {\n      wHover: minDiff / 2,\n      tickLen: tickLen\n    });\n    return cd;\n  } else {\n    return [{\n      t: {\n        empty: true\n      }\n    }];\n  }\n}\n\nfunction ptFunc(o, h, l, c) {\n  return {\n    o: o,\n    h: h,\n    l: l,\n    c: c\n  };\n} // shared between OHLC and candlestick\n// ptFunc makes a calcdata point specific to each trace type, from oi, hi, li, ci\n\n\nfunction calcCommon(gd, trace, x, ya, ptFunc) {\n  var o = ya.makeCalcdata(trace, 'open');\n  var h = ya.makeCalcdata(trace, 'high');\n  var l = ya.makeCalcdata(trace, 'low');\n  var c = ya.makeCalcdata(trace, 'close');\n  var hasTextArray = Array.isArray(trace.text);\n  var hasHovertextArray = Array.isArray(trace.hovertext); // we're optimists - before we have any changing data, assume increasing\n\n  var increasing = true;\n  var cPrev = null;\n  var cd = [];\n\n  for (var i = 0; i < x.length; i++) {\n    var xi = x[i];\n    var oi = o[i];\n    var hi = h[i];\n    var li = l[i];\n    var ci = c[i];\n\n    if (xi !== BADNUM && oi !== BADNUM && hi !== BADNUM && li !== BADNUM && ci !== BADNUM) {\n      if (ci === oi) {\n        // if open == close, look for a change from the previous close\n        if (cPrev !== null && ci !== cPrev) increasing = ci > cPrev; // else (c === cPrev or cPrev is null) no change\n      } else increasing = ci > oi;\n\n      cPrev = ci;\n      var pt = ptFunc(oi, hi, li, ci);\n      pt.pos = xi;\n      pt.yc = (oi + ci) / 2;\n      pt.i = i;\n      pt.dir = increasing ? 'increasing' : 'decreasing'; // For categoryorder, store low and high\n\n      pt.x = pt.pos;\n      pt.y = [li, hi];\n      if (hasTextArray) pt.tx = trace.text[i];\n      if (hasHovertextArray) pt.htx = trace.hovertext[i];\n      cd.push(pt);\n    } else {\n      cd.push({\n        pos: xi,\n        empty: true\n      });\n    }\n  }\n\n  trace._extremes[ya._id] = Axes.findExtremes(ya, Lib.concat(l, h), {\n    padded: true\n  });\n\n  if (cd.length) {\n    cd[0].t = {\n      labels: {\n        open: _(gd, 'open:') + ' ',\n        high: _(gd, 'high:') + ' ',\n        low: _(gd, 'low:') + ' ',\n        close: _(gd, 'close:') + ' '\n      }\n    };\n  }\n\n  return cd;\n}\n/*\n * find min x-coordinates difference of all traces\n * attached to this x-axis and stash the result in _minDiff\n * in all traces; when a trace uses this in its\n * calc step it deletes _minDiff, so that next calc this is\n * done again in case the data changed.\n * also since we need it here, stash _xcalc on the trace\n */\n\n\nfunction convertTickWidth(gd, xa, trace) {\n  var minDiff = trace._minDiff;\n\n  if (!minDiff) {\n    var fullData = gd._fullData;\n    var ohlcTracesOnThisXaxis = [];\n    minDiff = Infinity;\n    var i;\n\n    for (i = 0; i < fullData.length; i++) {\n      var tracei = fullData[i];\n\n      if (tracei.type === 'ohlc' && tracei.visible === true && tracei.xaxis === xa._id) {\n        ohlcTracesOnThisXaxis.push(tracei);\n        var xcalc = xa.makeCalcdata(tracei, 'x');\n        tracei._xcalc = xcalc;\n        var _minDiff = Lib.distinctVals(xcalc).minDiff;\n\n        if (_minDiff && isFinite(_minDiff)) {\n          minDiff = Math.min(minDiff, _minDiff);\n        }\n      }\n    } // if minDiff is still Infinity here, set it to 1\n\n\n    if (minDiff === Infinity) minDiff = 1;\n\n    for (i = 0; i < ohlcTracesOnThisXaxis.length; i++) {\n      ohlcTracesOnThisXaxis[i]._minDiff = minDiff;\n    }\n  }\n\n  return minDiff * trace.tickwidth;\n}\n\nmodule.exports = {\n  calc: calc,\n  calcCommon: calcCommon\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/ohlc/calc.js"],"names":["Lib","require","_","Axes","BADNUM","calc","gd","trace","xa","getFromId","xaxis","ya","yaxis","tickLen","convertTickWidth","minDiff","_minDiff","x","_xcalc","cd","calcCommon","ptFunc","_extremes","_id","findExtremes","vpad","length","extendFlat","t","wHover","empty","o","h","l","c","makeCalcdata","hasTextArray","Array","isArray","text","hasHovertextArray","hovertext","increasing","cPrev","i","xi","oi","hi","li","ci","pt","pos","yc","dir","y","tx","htx","push","concat","padded","labels","open","high","low","close","fullData","_fullData","ohlcTracesOnThisXaxis","Infinity","tracei","type","visible","xcalc","distinctVals","isFinite","Math","min","tickwidth","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar _ = Lib._;\nvar Axes = require('../../plots/cartesian/axes');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis);\n    var ya = Axes.getFromId(gd, trace.yaxis);\n\n    var tickLen = convertTickWidth(gd, xa, trace);\n    var minDiff = trace._minDiff;\n    trace._minDiff = null;\n    var x = trace._xcalc;\n    trace._xcalc = null;\n\n    var cd = calcCommon(gd, trace, x, ya, ptFunc);\n\n    trace._extremes[xa._id] = Axes.findExtremes(xa, x, {vpad: minDiff / 2});\n    if(cd.length) {\n        Lib.extendFlat(cd[0].t, {\n            wHover: minDiff / 2,\n            tickLen: tickLen\n        });\n        return cd;\n    } else {\n        return [{t: {empty: true}}];\n    }\n}\n\nfunction ptFunc(o, h, l, c) {\n    return {\n        o: o,\n        h: h,\n        l: l,\n        c: c\n    };\n}\n\n\n// shared between OHLC and candlestick\n// ptFunc makes a calcdata point specific to each trace type, from oi, hi, li, ci\nfunction calcCommon(gd, trace, x, ya, ptFunc) {\n    var o = ya.makeCalcdata(trace, 'open');\n    var h = ya.makeCalcdata(trace, 'high');\n    var l = ya.makeCalcdata(trace, 'low');\n    var c = ya.makeCalcdata(trace, 'close');\n\n    var hasTextArray = Array.isArray(trace.text);\n    var hasHovertextArray = Array.isArray(trace.hovertext);\n\n    // we're optimists - before we have any changing data, assume increasing\n    var increasing = true;\n    var cPrev = null;\n\n    var cd = [];\n    for(var i = 0; i < x.length; i++) {\n        var xi = x[i];\n        var oi = o[i];\n        var hi = h[i];\n        var li = l[i];\n        var ci = c[i];\n\n        if(xi !== BADNUM && oi !== BADNUM && hi !== BADNUM && li !== BADNUM && ci !== BADNUM) {\n            if(ci === oi) {\n                // if open == close, look for a change from the previous close\n                if(cPrev !== null && ci !== cPrev) increasing = ci > cPrev;\n                // else (c === cPrev or cPrev is null) no change\n            } else increasing = ci > oi;\n\n            cPrev = ci;\n\n            var pt = ptFunc(oi, hi, li, ci);\n\n            pt.pos = xi;\n            pt.yc = (oi + ci) / 2;\n            pt.i = i;\n            pt.dir = increasing ? 'increasing' : 'decreasing';\n\n            // For categoryorder, store low and high\n            pt.x = pt.pos;\n            pt.y = [li, hi];\n\n            if(hasTextArray) pt.tx = trace.text[i];\n            if(hasHovertextArray) pt.htx = trace.hovertext[i];\n\n            cd.push(pt);\n        } else {\n            cd.push({pos: xi, empty: true});\n        }\n    }\n\n    trace._extremes[ya._id] = Axes.findExtremes(ya, Lib.concat(l, h), {padded: true});\n\n    if(cd.length) {\n        cd[0].t = {\n            labels: {\n                open: _(gd, 'open:') + ' ',\n                high: _(gd, 'high:') + ' ',\n                low: _(gd, 'low:') + ' ',\n                close: _(gd, 'close:') + ' '\n            }\n        };\n    }\n\n    return cd;\n}\n\n/*\n * find min x-coordinates difference of all traces\n * attached to this x-axis and stash the result in _minDiff\n * in all traces; when a trace uses this in its\n * calc step it deletes _minDiff, so that next calc this is\n * done again in case the data changed.\n * also since we need it here, stash _xcalc on the trace\n */\nfunction convertTickWidth(gd, xa, trace) {\n    var minDiff = trace._minDiff;\n\n    if(!minDiff) {\n        var fullData = gd._fullData;\n        var ohlcTracesOnThisXaxis = [];\n\n        minDiff = Infinity;\n\n        var i;\n\n        for(i = 0; i < fullData.length; i++) {\n            var tracei = fullData[i];\n\n            if(tracei.type === 'ohlc' &&\n                tracei.visible === true &&\n                tracei.xaxis === xa._id\n            ) {\n                ohlcTracesOnThisXaxis.push(tracei);\n\n                var xcalc = xa.makeCalcdata(tracei, 'x');\n                tracei._xcalc = xcalc;\n\n                var _minDiff = Lib.distinctVals(xcalc).minDiff;\n                if(_minDiff && isFinite(_minDiff)) {\n                    minDiff = Math.min(minDiff, _minDiff);\n                }\n            }\n        }\n\n        // if minDiff is still Infinity here, set it to 1\n        if(minDiff === Infinity) minDiff = 1;\n\n        for(i = 0; i < ohlcTracesOnThisXaxis.length; i++) {\n            ohlcTracesOnThisXaxis[i]._minDiff = minDiff;\n        }\n    }\n\n    return minDiff * trace.tickwidth;\n}\n\nmodule.exports = {\n    calc: calc,\n    calcCommon: calcCommon\n};\n"]},"metadata":{},"sourceType":"script"}