{"ast":null,"code":"'use strict';\n\nvar bsearch = require('binary-search-bounds');\n\nmodule.exports = classifyFaces;\n\nfunction FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {\n  this.cells = cells;\n  this.neighbor = neighbor;\n  this.flags = flags;\n  this.constraint = constraint;\n  this.active = active;\n  this.next = next;\n  this.boundary = boundary;\n}\n\nvar proto = FaceIndex.prototype;\n\nfunction compareCell(a, b) {\n  return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];\n}\n\nproto.locate = function () {\n  var key = [0, 0, 0];\n  return function (a, b, c) {\n    var x = a,\n        y = b,\n        z = c;\n\n    if (b < c) {\n      if (b < a) {\n        x = b;\n        y = c;\n        z = a;\n      }\n    } else if (c < a) {\n      x = c;\n      y = a;\n      z = b;\n    }\n\n    if (x < 0) {\n      return -1;\n    }\n\n    key[0] = x;\n    key[1] = y;\n    key[2] = z;\n    return bsearch.eq(this.cells, key, compareCell);\n  };\n}();\n\nfunction indexCells(triangulation, infinity) {\n  //First get cells and canonicalize\n  var cells = triangulation.cells();\n  var nc = cells.length;\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n    var x = c[0],\n        y = c[1],\n        z = c[2];\n\n    if (y < z) {\n      if (y < x) {\n        c[0] = y;\n        c[1] = z;\n        c[2] = x;\n      }\n    } else if (z < x) {\n      c[0] = z;\n      c[1] = x;\n      c[2] = y;\n    }\n  }\n\n  cells.sort(compareCell); //Initialize flag array\n\n  var flags = new Array(nc);\n\n  for (var i = 0; i < flags.length; ++i) {\n    flags[i] = 0;\n  } //Build neighbor index, initialize queues\n\n\n  var active = [];\n  var next = [];\n  var neighbor = new Array(3 * nc);\n  var constraint = new Array(3 * nc);\n  var boundary = null;\n\n  if (infinity) {\n    boundary = [];\n  }\n\n  var index = new FaceIndex(cells, neighbor, constraint, flags, active, next, boundary);\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < 3; ++j) {\n      var x = c[j],\n          y = c[(j + 1) % 3];\n      var a = neighbor[3 * i + j] = index.locate(y, x, triangulation.opposite(y, x));\n      var b = constraint[3 * i + j] = triangulation.isConstraint(x, y);\n\n      if (a < 0) {\n        if (b) {\n          next.push(i);\n        } else {\n          active.push(i);\n          flags[i] = 1;\n        }\n\n        if (infinity) {\n          boundary.push([y, x, -1]);\n        }\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction filterCells(cells, flags, target) {\n  var ptr = 0;\n\n  for (var i = 0; i < cells.length; ++i) {\n    if (flags[i] === target) {\n      cells[ptr++] = cells[i];\n    }\n  }\n\n  cells.length = ptr;\n  return cells;\n}\n\nfunction classifyFaces(triangulation, target, infinity) {\n  var index = indexCells(triangulation, infinity);\n\n  if (target === 0) {\n    if (infinity) {\n      return index.cells.concat(index.boundary);\n    } else {\n      return index.cells;\n    }\n  }\n\n  var side = 1;\n  var active = index.active;\n  var next = index.next;\n  var flags = index.flags;\n  var cells = index.cells;\n  var constraint = index.constraint;\n  var neighbor = index.neighbor;\n\n  while (active.length > 0 || next.length > 0) {\n    while (active.length > 0) {\n      var t = active.pop();\n\n      if (flags[t] === -side) {\n        continue;\n      }\n\n      flags[t] = side;\n      var c = cells[t];\n\n      for (var j = 0; j < 3; ++j) {\n        var f = neighbor[3 * t + j];\n\n        if (f >= 0 && flags[f] === 0) {\n          if (constraint[3 * t + j]) {\n            next.push(f);\n          } else {\n            active.push(f);\n            flags[f] = side;\n          }\n        }\n      }\n    } //Swap arrays and loop\n\n\n    var tmp = next;\n    next = active;\n    active = tmp;\n    next.length = 0;\n    side = -side;\n  }\n\n  var result = filterCells(cells, flags, target);\n\n  if (infinity) {\n    return result.concat(index.boundary);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/cdt2d/lib/filter.js"],"names":["bsearch","require","module","exports","classifyFaces","FaceIndex","cells","neighbor","constraint","flags","active","next","boundary","proto","prototype","compareCell","a","b","locate","key","c","x","y","z","eq","indexCells","triangulation","infinity","nc","length","i","sort","Array","index","j","opposite","isConstraint","push","filterCells","target","ptr","concat","side","t","pop","f","tmp","result"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,sBAAD,CAArB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,aAAjB;;AAEA,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,UAApC,EAAgDC,KAAhD,EAAuDC,MAAvD,EAA+DC,IAA/D,EAAqEC,QAArE,EAA+E;AAC7E,OAAKN,KAAL,GAAmBA,KAAnB;AACA,OAAKC,QAAL,GAAmBA,QAAnB;AACA,OAAKE,KAAL,GAAmBA,KAAnB;AACA,OAAKD,UAAL,GAAmBA,UAAnB;AACA,OAAKE,MAAL,GAAmBA,MAAnB;AACA,OAAKC,IAAL,GAAmBA,IAAnB;AACA,OAAKC,QAAL,GAAmBA,QAAnB;AACD;;AAED,IAAIC,KAAK,GAAGR,SAAS,CAACS,SAAtB;;AAEA,SAASC,WAAT,CAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AACzB,SAAOD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAR,IACAD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CADR,IAEAD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAFf;AAGD;;AAEDJ,KAAK,CAACK,MAAN,GAAgB,YAAW;AACzB,MAAIC,GAAG,GAAG,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV;AACA,SAAO,UAASH,CAAT,EAAYC,CAAZ,EAAeG,CAAf,EAAkB;AACvB,QAAIC,CAAC,GAAGL,CAAR;AAAA,QAAWM,CAAC,GAAGL,CAAf;AAAA,QAAkBM,CAAC,GAAGH,CAAtB;;AACA,QAAGH,CAAC,GAAGG,CAAP,EAAU;AACR,UAAGH,CAAC,GAAGD,CAAP,EAAU;AACRK,QAAAA,CAAC,GAAGJ,CAAJ;AACAK,QAAAA,CAAC,GAAGF,CAAJ;AACAG,QAAAA,CAAC,GAAGP,CAAJ;AACD;AACF,KAND,MAMO,IAAGI,CAAC,GAAGJ,CAAP,EAAU;AACfK,MAAAA,CAAC,GAAGD,CAAJ;AACAE,MAAAA,CAAC,GAAGN,CAAJ;AACAO,MAAAA,CAAC,GAAGN,CAAJ;AACD;;AACD,QAAGI,CAAC,GAAG,CAAP,EAAU;AACR,aAAO,CAAC,CAAR;AACD;;AACDF,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASE,CAAT;AACAF,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASG,CAAT;AACAH,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASI,CAAT;AACA,WAAOvB,OAAO,CAACwB,EAAR,CAAW,KAAKlB,KAAhB,EAAuBa,GAAvB,EAA4BJ,WAA5B,CAAP;AACD,GApBD;AAqBD,CAvBc,EAAf;;AAyBA,SAASU,UAAT,CAAoBC,aAApB,EAAmCC,QAAnC,EAA6C;AAC3C;AACA,MAAIrB,KAAK,GAAGoB,aAAa,CAACpB,KAAd,EAAZ;AACA,MAAIsB,EAAE,GAAGtB,KAAK,CAACuB,MAAf;;AACA,OAAI,IAAIC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACF,EAAf,EAAmB,EAAEE,CAArB,EAAwB;AACtB,QAAIV,CAAC,GAAGd,KAAK,CAACwB,CAAD,CAAb;AACA,QAAIT,CAAC,GAAGD,CAAC,CAAC,CAAD,CAAT;AAAA,QAAcE,CAAC,GAAGF,CAAC,CAAC,CAAD,CAAnB;AAAA,QAAwBG,CAAC,GAAGH,CAAC,CAAC,CAAD,CAA7B;;AACA,QAAGE,CAAC,GAAGC,CAAP,EAAU;AACR,UAAGD,CAAC,GAAGD,CAAP,EAAU;AACRD,QAAAA,CAAC,CAAC,CAAD,CAAD,GAAOE,CAAP;AACAF,QAAAA,CAAC,CAAC,CAAD,CAAD,GAAOG,CAAP;AACAH,QAAAA,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAP;AACD;AACF,KAND,MAMO,IAAGE,CAAC,GAAGF,CAAP,EAAU;AACfD,MAAAA,CAAC,CAAC,CAAD,CAAD,GAAOG,CAAP;AACAH,MAAAA,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAP;AACAD,MAAAA,CAAC,CAAC,CAAD,CAAD,GAAOE,CAAP;AACD;AACF;;AACDhB,EAAAA,KAAK,CAACyB,IAAN,CAAWhB,WAAX,EAnB2C,CAqB3C;;AACA,MAAIN,KAAK,GAAG,IAAIuB,KAAJ,CAAUJ,EAAV,CAAZ;;AACA,OAAI,IAAIE,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACrB,KAAK,CAACoB,MAArB,EAA6B,EAAEC,CAA/B,EAAkC;AAChCrB,IAAAA,KAAK,CAACqB,CAAD,CAAL,GAAW,CAAX;AACD,GAzB0C,CA2B3C;;;AACA,MAAIpB,MAAM,GAAG,EAAb;AACA,MAAIC,IAAI,GAAK,EAAb;AACA,MAAIJ,QAAQ,GAAG,IAAIyB,KAAJ,CAAU,IAAEJ,EAAZ,CAAf;AACA,MAAIpB,UAAU,GAAG,IAAIwB,KAAJ,CAAU,IAAEJ,EAAZ,CAAjB;AACA,MAAIhB,QAAQ,GAAG,IAAf;;AACA,MAAGe,QAAH,EAAa;AACXf,IAAAA,QAAQ,GAAG,EAAX;AACD;;AACD,MAAIqB,KAAK,GAAG,IAAI5B,SAAJ,CACVC,KADU,EAEVC,QAFU,EAGVC,UAHU,EAIVC,KAJU,EAKVC,MALU,EAMVC,IANU,EAOVC,QAPU,CAAZ;;AAQA,OAAI,IAAIkB,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACF,EAAf,EAAmB,EAAEE,CAArB,EAAwB;AACtB,QAAIV,CAAC,GAAGd,KAAK,CAACwB,CAAD,CAAb;;AACA,SAAI,IAAII,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,CAAf,EAAkB,EAAEA,CAApB,EAAuB;AACrB,UAAIb,CAAC,GAAGD,CAAC,CAACc,CAAD,CAAT;AAAA,UAAcZ,CAAC,GAAGF,CAAC,CAAC,CAACc,CAAC,GAAC,CAAH,IAAM,CAAP,CAAnB;AACA,UAAIlB,CAAC,GAAGT,QAAQ,CAAC,IAAEuB,CAAF,GAAII,CAAL,CAAR,GAAkBD,KAAK,CAACf,MAAN,CAAaI,CAAb,EAAgBD,CAAhB,EAAmBK,aAAa,CAACS,QAAd,CAAuBb,CAAvB,EAA0BD,CAA1B,CAAnB,CAA1B;AACA,UAAIJ,CAAC,GAAGT,UAAU,CAAC,IAAEsB,CAAF,GAAII,CAAL,CAAV,GAAoBR,aAAa,CAACU,YAAd,CAA2Bf,CAA3B,EAA8BC,CAA9B,CAA5B;;AACA,UAAGN,CAAC,GAAG,CAAP,EAAU;AACR,YAAGC,CAAH,EAAM;AACJN,UAAAA,IAAI,CAAC0B,IAAL,CAAUP,CAAV;AACD,SAFD,MAEO;AACLpB,UAAAA,MAAM,CAAC2B,IAAP,CAAYP,CAAZ;AACArB,UAAAA,KAAK,CAACqB,CAAD,CAAL,GAAW,CAAX;AACD;;AACD,YAAGH,QAAH,EAAa;AACXf,UAAAA,QAAQ,CAACyB,IAAT,CAAc,CAACf,CAAD,EAAID,CAAJ,EAAO,CAAC,CAAR,CAAd;AACD;AACF;AACF;AACF;;AACD,SAAOY,KAAP;AACD;;AAED,SAASK,WAAT,CAAqBhC,KAArB,EAA4BG,KAA5B,EAAmC8B,MAAnC,EAA2C;AACzC,MAAIC,GAAG,GAAG,CAAV;;AACA,OAAI,IAAIV,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACxB,KAAK,CAACuB,MAArB,EAA6B,EAAEC,CAA/B,EAAkC;AAChC,QAAGrB,KAAK,CAACqB,CAAD,CAAL,KAAaS,MAAhB,EAAwB;AACtBjC,MAAAA,KAAK,CAACkC,GAAG,EAAJ,CAAL,GAAelC,KAAK,CAACwB,CAAD,CAApB;AACD;AACF;;AACDxB,EAAAA,KAAK,CAACuB,MAAN,GAAeW,GAAf;AACA,SAAOlC,KAAP;AACD;;AAED,SAASF,aAAT,CAAuBsB,aAAvB,EAAsCa,MAAtC,EAA8CZ,QAA9C,EAAwD;AACtD,MAAIM,KAAK,GAAGR,UAAU,CAACC,aAAD,EAAgBC,QAAhB,CAAtB;;AAEA,MAAGY,MAAM,KAAK,CAAd,EAAiB;AACf,QAAGZ,QAAH,EAAa;AACX,aAAOM,KAAK,CAAC3B,KAAN,CAAYmC,MAAZ,CAAmBR,KAAK,CAACrB,QAAzB,CAAP;AACD,KAFD,MAEO;AACL,aAAOqB,KAAK,CAAC3B,KAAb;AACD;AACF;;AAED,MAAIoC,IAAI,GAAG,CAAX;AACA,MAAIhC,MAAM,GAAGuB,KAAK,CAACvB,MAAnB;AACA,MAAIC,IAAI,GAAGsB,KAAK,CAACtB,IAAjB;AACA,MAAIF,KAAK,GAAGwB,KAAK,CAACxB,KAAlB;AACA,MAAIH,KAAK,GAAG2B,KAAK,CAAC3B,KAAlB;AACA,MAAIE,UAAU,GAAGyB,KAAK,CAACzB,UAAvB;AACA,MAAID,QAAQ,GAAG0B,KAAK,CAAC1B,QAArB;;AAEA,SAAMG,MAAM,CAACmB,MAAP,GAAgB,CAAhB,IAAqBlB,IAAI,CAACkB,MAAL,GAAc,CAAzC,EAA4C;AAC1C,WAAMnB,MAAM,CAACmB,MAAP,GAAgB,CAAtB,EAAyB;AACvB,UAAIc,CAAC,GAAGjC,MAAM,CAACkC,GAAP,EAAR;;AACA,UAAGnC,KAAK,CAACkC,CAAD,CAAL,KAAa,CAACD,IAAjB,EAAuB;AACrB;AACD;;AACDjC,MAAAA,KAAK,CAACkC,CAAD,CAAL,GAAWD,IAAX;AACA,UAAItB,CAAC,GAAGd,KAAK,CAACqC,CAAD,CAAb;;AACA,WAAI,IAAIT,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,CAAf,EAAkB,EAAEA,CAApB,EAAuB;AACrB,YAAIW,CAAC,GAAGtC,QAAQ,CAAC,IAAEoC,CAAF,GAAIT,CAAL,CAAhB;;AACA,YAAGW,CAAC,IAAI,CAAL,IAAUpC,KAAK,CAACoC,CAAD,CAAL,KAAa,CAA1B,EAA6B;AAC3B,cAAGrC,UAAU,CAAC,IAAEmC,CAAF,GAAIT,CAAL,CAAb,EAAsB;AACpBvB,YAAAA,IAAI,CAAC0B,IAAL,CAAUQ,CAAV;AACD,WAFD,MAEO;AACLnC,YAAAA,MAAM,CAAC2B,IAAP,CAAYQ,CAAZ;AACApC,YAAAA,KAAK,CAACoC,CAAD,CAAL,GAAWH,IAAX;AACD;AACF;AACF;AACF,KAnByC,CAqB1C;;;AACA,QAAII,GAAG,GAAGnC,IAAV;AACAA,IAAAA,IAAI,GAAGD,MAAP;AACAA,IAAAA,MAAM,GAAGoC,GAAT;AACAnC,IAAAA,IAAI,CAACkB,MAAL,GAAc,CAAd;AACAa,IAAAA,IAAI,GAAG,CAACA,IAAR;AACD;;AAED,MAAIK,MAAM,GAAGT,WAAW,CAAChC,KAAD,EAAQG,KAAR,EAAe8B,MAAf,CAAxB;;AACA,MAAGZ,QAAH,EAAa;AACX,WAAOoB,MAAM,CAACN,MAAP,CAAcR,KAAK,CAACrB,QAApB,CAAP;AACD;;AACD,SAAOmC,MAAP;AACD","sourcesContent":["'use strict'\n\nvar bsearch = require('binary-search-bounds')\n\nmodule.exports = classifyFaces\n\nfunction FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {\n  this.cells       = cells\n  this.neighbor    = neighbor\n  this.flags       = flags\n  this.constraint  = constraint\n  this.active      = active\n  this.next        = next\n  this.boundary    = boundary\n}\n\nvar proto = FaceIndex.prototype\n\nfunction compareCell(a, b) {\n  return a[0] - b[0] ||\n         a[1] - b[1] ||\n         a[2] - b[2]\n}\n\nproto.locate = (function() {\n  var key = [0,0,0]\n  return function(a, b, c) {\n    var x = a, y = b, z = c\n    if(b < c) {\n      if(b < a) {\n        x = b\n        y = c\n        z = a\n      }\n    } else if(c < a) {\n      x = c\n      y = a\n      z = b\n    }\n    if(x < 0) {\n      return -1\n    }\n    key[0] = x\n    key[1] = y\n    key[2] = z\n    return bsearch.eq(this.cells, key, compareCell)\n  }\n})()\n\nfunction indexCells(triangulation, infinity) {\n  //First get cells and canonicalize\n  var cells = triangulation.cells()\n  var nc = cells.length\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    var x = c[0], y = c[1], z = c[2]\n    if(y < z) {\n      if(y < x) {\n        c[0] = y\n        c[1] = z\n        c[2] = x\n      }\n    } else if(z < x) {\n      c[0] = z\n      c[1] = x\n      c[2] = y\n    }\n  }\n  cells.sort(compareCell)\n\n  //Initialize flag array\n  var flags = new Array(nc)\n  for(var i=0; i<flags.length; ++i) {\n    flags[i] = 0\n  }\n\n  //Build neighbor index, initialize queues\n  var active = []\n  var next   = []\n  var neighbor = new Array(3*nc)\n  var constraint = new Array(3*nc)\n  var boundary = null\n  if(infinity) {\n    boundary = []\n  }\n  var index = new FaceIndex(\n    cells,\n    neighbor,\n    constraint,\n    flags,\n    active,\n    next,\n    boundary)\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    for(var j=0; j<3; ++j) {\n      var x = c[j], y = c[(j+1)%3]\n      var a = neighbor[3*i+j] = index.locate(y, x, triangulation.opposite(y, x))\n      var b = constraint[3*i+j] = triangulation.isConstraint(x, y)\n      if(a < 0) {\n        if(b) {\n          next.push(i)\n        } else {\n          active.push(i)\n          flags[i] = 1\n        }\n        if(infinity) {\n          boundary.push([y, x, -1])\n        }\n      }\n    }\n  }\n  return index\n}\n\nfunction filterCells(cells, flags, target) {\n  var ptr = 0\n  for(var i=0; i<cells.length; ++i) {\n    if(flags[i] === target) {\n      cells[ptr++] = cells[i]\n    }\n  }\n  cells.length = ptr\n  return cells\n}\n\nfunction classifyFaces(triangulation, target, infinity) {\n  var index = indexCells(triangulation, infinity)\n\n  if(target === 0) {\n    if(infinity) {\n      return index.cells.concat(index.boundary)\n    } else {\n      return index.cells\n    }\n  }\n\n  var side = 1\n  var active = index.active\n  var next = index.next\n  var flags = index.flags\n  var cells = index.cells\n  var constraint = index.constraint\n  var neighbor = index.neighbor\n\n  while(active.length > 0 || next.length > 0) {\n    while(active.length > 0) {\n      var t = active.pop()\n      if(flags[t] === -side) {\n        continue\n      }\n      flags[t] = side\n      var c = cells[t]\n      for(var j=0; j<3; ++j) {\n        var f = neighbor[3*t+j]\n        if(f >= 0 && flags[f] === 0) {\n          if(constraint[3*t+j]) {\n            next.push(f)\n          } else {\n            active.push(f)\n            flags[f] = side\n          }\n        }\n      }\n    }\n\n    //Swap arrays and loop\n    var tmp = next\n    next = active\n    active = tmp\n    next.length = 0\n    side = -side\n  }\n\n  var result = filterCells(cells, flags, target)\n  if(infinity) {\n    return result.concat(index.boundary)\n  }\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}