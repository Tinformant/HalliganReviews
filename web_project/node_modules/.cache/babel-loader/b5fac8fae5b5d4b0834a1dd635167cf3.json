{"ast":null,"code":"'use strict';\n\nvar bsearch = require('binary-search-bounds');\n\nvar orient = require('robust-orientation')[3];\n\nvar EVENT_POINT = 0;\nvar EVENT_END = 1;\nvar EVENT_START = 2;\nmodule.exports = monotoneTriangulate; //A partial convex hull fragment, made of two unimonotone polygons\n\nfunction PartialHull(a, b, idx, lowerIds, upperIds) {\n  this.a = a;\n  this.b = b;\n  this.idx = idx;\n  this.lowerIds = lowerIds;\n  this.upperIds = upperIds;\n} //An event in the sweep line procedure\n\n\nfunction Event(a, b, type, idx) {\n  this.a = a;\n  this.b = b;\n  this.type = type;\n  this.idx = idx;\n} //This is used to compare events for the sweep line procedure\n// Points are:\n//  1. sorted lexicographically\n//  2. sorted by type  (point < end < start)\n//  3. segments sorted by winding order\n//  4. sorted by index\n\n\nfunction compareEvent(a, b) {\n  var d = a.a[0] - b.a[0] || a.a[1] - b.a[1] || a.type - b.type;\n\n  if (d) {\n    return d;\n  }\n\n  if (a.type !== EVENT_POINT) {\n    d = orient(a.a, a.b, b.b);\n\n    if (d) {\n      return d;\n    }\n  }\n\n  return a.idx - b.idx;\n}\n\nfunction testPoint(hull, p) {\n  return orient(hull.a, hull.b, p);\n}\n\nfunction addPoint(cells, hulls, points, p, idx) {\n  var lo = bsearch.lt(hulls, p, testPoint);\n  var hi = bsearch.gt(hulls, p, testPoint);\n\n  for (var i = lo; i < hi; ++i) {\n    var hull = hulls[i]; //Insert p into lower hull\n\n    var lowerIds = hull.lowerIds;\n    var m = lowerIds.length;\n\n    while (m > 1 && orient(points[lowerIds[m - 2]], points[lowerIds[m - 1]], p) > 0) {\n      cells.push([lowerIds[m - 1], lowerIds[m - 2], idx]);\n      m -= 1;\n    }\n\n    lowerIds.length = m;\n    lowerIds.push(idx); //Insert p into upper hull\n\n    var upperIds = hull.upperIds;\n    var m = upperIds.length;\n\n    while (m > 1 && orient(points[upperIds[m - 2]], points[upperIds[m - 1]], p) < 0) {\n      cells.push([upperIds[m - 2], upperIds[m - 1], idx]);\n      m -= 1;\n    }\n\n    upperIds.length = m;\n    upperIds.push(idx);\n  }\n}\n\nfunction findSplit(hull, edge) {\n  var d;\n\n  if (hull.a[0] < edge.a[0]) {\n    d = orient(hull.a, hull.b, edge.a);\n  } else {\n    d = orient(edge.b, edge.a, hull.a);\n  }\n\n  if (d) {\n    return d;\n  }\n\n  if (edge.b[0] < hull.b[0]) {\n    d = orient(hull.a, hull.b, edge.b);\n  } else {\n    d = orient(edge.b, edge.a, hull.b);\n  }\n\n  return d || hull.idx - edge.idx;\n}\n\nfunction splitHulls(hulls, points, event) {\n  var splitIdx = bsearch.le(hulls, event, findSplit);\n  var hull = hulls[splitIdx];\n  var upperIds = hull.upperIds;\n  var x = upperIds[upperIds.length - 1];\n  hull.upperIds = [x];\n  hulls.splice(splitIdx + 1, 0, new PartialHull(event.a, event.b, event.idx, [x], upperIds));\n}\n\nfunction mergeHulls(hulls, points, event) {\n  //Swap pointers for merge search\n  var tmp = event.a;\n  event.a = event.b;\n  event.b = tmp;\n  var mergeIdx = bsearch.eq(hulls, event, findSplit);\n  var upper = hulls[mergeIdx];\n  var lower = hulls[mergeIdx - 1];\n  lower.upperIds = upper.upperIds;\n  hulls.splice(mergeIdx, 1);\n}\n\nfunction monotoneTriangulate(points, edges) {\n  var numPoints = points.length;\n  var numEdges = edges.length;\n  var events = []; //Create point events\n\n  for (var i = 0; i < numPoints; ++i) {\n    events.push(new Event(points[i], null, EVENT_POINT, i));\n  } //Create edge events\n\n\n  for (var i = 0; i < numEdges; ++i) {\n    var e = edges[i];\n    var a = points[e[0]];\n    var b = points[e[1]];\n\n    if (a[0] < b[0]) {\n      events.push(new Event(a, b, EVENT_START, i), new Event(b, a, EVENT_END, i));\n    } else if (a[0] > b[0]) {\n      events.push(new Event(b, a, EVENT_START, i), new Event(a, b, EVENT_END, i));\n    }\n  } //Sort events\n\n\n  events.sort(compareEvent); //Initialize hull\n\n  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52);\n  var hull = [new PartialHull([minX, 1], [minX, 0], -1, [], [], [], [])]; //Process events in order\n\n  var cells = [];\n\n  for (var i = 0, numEvents = events.length; i < numEvents; ++i) {\n    var event = events[i];\n    var type = event.type;\n\n    if (type === EVENT_POINT) {\n      addPoint(cells, hull, points, event.a, event.idx);\n    } else if (type === EVENT_START) {\n      splitHulls(hull, points, event);\n    } else {\n      mergeHulls(hull, points, event);\n    }\n  } //Return triangulation\n\n\n  return cells;\n}","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/cdt2d/lib/monotone.js"],"names":["bsearch","require","orient","EVENT_POINT","EVENT_END","EVENT_START","module","exports","monotoneTriangulate","PartialHull","a","b","idx","lowerIds","upperIds","Event","type","compareEvent","d","testPoint","hull","p","addPoint","cells","hulls","points","lo","lt","hi","gt","i","m","length","push","findSplit","edge","splitHulls","event","splitIdx","le","x","splice","mergeHulls","tmp","mergeIdx","eq","upper","lower","edges","numPoints","numEdges","events","e","sort","minX","Math","abs","pow","numEvents"],"mappings":"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","sourcesContent":["'use strict'\n\nvar bsearch = require('binary-search-bounds')\nvar orient = require('robust-orientation')[3]\n\nvar EVENT_POINT = 0\nvar EVENT_END   = 1\nvar EVENT_START = 2\n\nmodule.exports = monotoneTriangulate\n\n//A partial convex hull fragment, made of two unimonotone polygons\nfunction PartialHull(a, b, idx, lowerIds, upperIds) {\n  this.a = a\n  this.b = b\n  this.idx = idx\n  this.lowerIds = lowerIds\n  this.upperIds = upperIds\n}\n\n//An event in the sweep line procedure\nfunction Event(a, b, type, idx) {\n  this.a    = a\n  this.b    = b\n  this.type = type\n  this.idx  = idx\n}\n\n//This is used to compare events for the sweep line procedure\n// Points are:\n//  1. sorted lexicographically\n//  2. sorted by type  (point < end < start)\n//  3. segments sorted by winding order\n//  4. sorted by index\nfunction compareEvent(a, b) {\n  var d =\n    (a.a[0] - b.a[0]) ||\n    (a.a[1] - b.a[1]) ||\n    (a.type - b.type)\n  if(d) { return d }\n  if(a.type !== EVENT_POINT) {\n    d = orient(a.a, a.b, b.b)\n    if(d) { return d }\n  }\n  return a.idx - b.idx\n}\n\nfunction testPoint(hull, p) {\n  return orient(hull.a, hull.b, p)\n}\n\nfunction addPoint(cells, hulls, points, p, idx) {\n  var lo = bsearch.lt(hulls, p, testPoint)\n  var hi = bsearch.gt(hulls, p, testPoint)\n  for(var i=lo; i<hi; ++i) {\n    var hull = hulls[i]\n\n    //Insert p into lower hull\n    var lowerIds = hull.lowerIds\n    var m = lowerIds.length\n    while(m > 1 && orient(\n        points[lowerIds[m-2]],\n        points[lowerIds[m-1]],\n        p) > 0) {\n      cells.push(\n        [lowerIds[m-1],\n         lowerIds[m-2],\n         idx])\n      m -= 1\n    }\n    lowerIds.length = m\n    lowerIds.push(idx)\n\n    //Insert p into upper hull\n    var upperIds = hull.upperIds\n    var m = upperIds.length\n    while(m > 1 && orient(\n        points[upperIds[m-2]],\n        points[upperIds[m-1]],\n        p) < 0) {\n      cells.push(\n        [upperIds[m-2],\n         upperIds[m-1],\n         idx])\n      m -= 1\n    }\n    upperIds.length = m\n    upperIds.push(idx)\n  }\n}\n\nfunction findSplit(hull, edge) {\n  var d\n  if(hull.a[0] < edge.a[0]) {\n    d = orient(hull.a, hull.b, edge.a)\n  } else {\n    d = orient(edge.b, edge.a, hull.a)\n  }\n  if(d) { return d }\n  if(edge.b[0] < hull.b[0]) {\n    d = orient(hull.a, hull.b, edge.b)\n  } else {\n    d = orient(edge.b, edge.a, hull.b)\n  }\n  return d || hull.idx - edge.idx\n}\n\nfunction splitHulls(hulls, points, event) {\n  var splitIdx = bsearch.le(hulls, event, findSplit)\n  var hull = hulls[splitIdx]\n  var upperIds = hull.upperIds\n  var x = upperIds[upperIds.length-1]\n  hull.upperIds = [x]\n  hulls.splice(splitIdx+1, 0,\n    new PartialHull(event.a, event.b, event.idx, [x], upperIds))\n}\n\n\nfunction mergeHulls(hulls, points, event) {\n  //Swap pointers for merge search\n  var tmp = event.a\n  event.a = event.b\n  event.b = tmp\n  var mergeIdx = bsearch.eq(hulls, event, findSplit)\n  var upper = hulls[mergeIdx]\n  var lower = hulls[mergeIdx-1]\n  lower.upperIds = upper.upperIds\n  hulls.splice(mergeIdx, 1)\n}\n\n\nfunction monotoneTriangulate(points, edges) {\n\n  var numPoints = points.length\n  var numEdges = edges.length\n\n  var events = []\n\n  //Create point events\n  for(var i=0; i<numPoints; ++i) {\n    events.push(new Event(\n      points[i],\n      null,\n      EVENT_POINT,\n      i))\n  }\n\n  //Create edge events\n  for(var i=0; i<numEdges; ++i) {\n    var e = edges[i]\n    var a = points[e[0]]\n    var b = points[e[1]]\n    if(a[0] < b[0]) {\n      events.push(\n        new Event(a, b, EVENT_START, i),\n        new Event(b, a, EVENT_END, i))\n    } else if(a[0] > b[0]) {\n      events.push(\n        new Event(b, a, EVENT_START, i),\n        new Event(a, b, EVENT_END, i))\n    }\n  }\n\n  //Sort events\n  events.sort(compareEvent)\n\n  //Initialize hull\n  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52)\n  var hull = [ new PartialHull([minX, 1], [minX, 0], -1, [], [], [], []) ]\n\n  //Process events in order\n  var cells = []\n  for(var i=0, numEvents=events.length; i<numEvents; ++i) {\n    var event = events[i]\n    var type = event.type\n    if(type === EVENT_POINT) {\n      addPoint(cells, hull, points, event.a, event.idx)\n    } else if(type === EVENT_START) {\n      splitHulls(hull, points, event)\n    } else {\n      mergeHulls(hull, points, event)\n    }\n  }\n\n  //Return triangulation\n  return cells\n}\n"]},"metadata":{},"sourceType":"script"}