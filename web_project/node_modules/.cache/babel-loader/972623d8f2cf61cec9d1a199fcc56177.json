{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar c = require('./constants');\n\nvar d3 = require('d3');\n\nvar keyFun = require('../../lib/gup').keyFun;\n\nvar repeat = require('../../lib/gup').repeat;\n\nvar sortAsc = require('../../lib').sorterAsc;\n\nvar snapRatio = c.bar.snapRatio;\n\nfunction snapOvershoot(v, vAdjacent) {\n  return v * (1 - snapRatio) + vAdjacent * snapRatio;\n}\n\nvar snapClose = c.bar.snapClose;\n\nfunction closeToCovering(v, vAdjacent) {\n  return v * (1 - snapClose) + vAdjacent * snapClose;\n} // snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\n\n\nfunction ordinalScaleSnap(isHigh, a, v, existingRanges) {\n  if (overlappingExisting(v, existingRanges)) return v;\n  var dir = isHigh ? -1 : 1;\n  var first = 0;\n  var last = a.length - 1;\n\n  if (dir < 0) {\n    var tmp = first;\n    first = last;\n    last = tmp;\n  }\n\n  var aHere = a[first];\n  var aPrev = aHere;\n\n  for (var i = first; dir * i < dir * last; i += dir) {\n    var nextI = i + dir;\n    var aNext = a[nextI]; // very close to the previous - snap down to it\n\n    if (dir * v < dir * closeToCovering(aHere, aNext)) return snapOvershoot(aHere, aPrev);\n    if (dir * v < dir * aNext || nextI === last) return snapOvershoot(aNext, aHere);\n    aPrev = aHere;\n    aHere = aNext;\n  }\n}\n\nfunction overlappingExisting(v, existingRanges) {\n  for (var i = 0; i < existingRanges.length; i++) {\n    if (v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n  }\n\n  return false;\n}\n\nfunction barHorizontalSetup(selection) {\n  selection.attr('x', -c.bar.captureWidth / 2).attr('width', c.bar.captureWidth);\n}\n\nfunction backgroundBarHorizontalSetup(selection) {\n  selection.attr('visibility', 'visible').style('visibility', 'visible').attr('fill', 'yellow').attr('opacity', 0);\n}\n\nfunction setHighlight(d) {\n  if (!d.brush.filterSpecified) {\n    return '0,' + d.height;\n  }\n\n  var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n  var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n\n  var p, sectionHeight, iNext;\n  var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n\n  for (var i = 0; i < pixelRanges.length; i++) {\n    p = pixelRanges[i];\n    sectionHeight = p[1] - p[0];\n    dashArray.push(currentGap);\n    dashArray.push(sectionHeight);\n    iNext = i + 1;\n\n    if (iNext < pixelRanges.length) {\n      currentGap = pixelRanges[iNext][0] - p[1];\n    }\n  }\n\n  dashArray.push(d.height); // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n  // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n  // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n  // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n\n  return dashArray;\n}\n\nfunction unitToPx(unitRanges, height) {\n  return unitRanges.map(function (pr) {\n    return pr.map(function (v) {\n      return Math.max(0, v * height);\n    }).sort(sortAsc);\n  });\n} // is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\n\n\nfunction getRegion(fPix, y) {\n  var pad = c.bar.handleHeight;\n  if (y > fPix[1] + pad || y < fPix[0] - pad) return;\n  if (y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n  if (y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n  return 'ns';\n}\n\nfunction clearCursor() {\n  d3.select(document.body).style('cursor', null);\n}\n\nfunction styleHighlight(selection) {\n  // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n  // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n  // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n  // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n  selection.attr('stroke-dasharray', setHighlight);\n}\n\nfunction renderHighlight(root, tweenCallback) {\n  var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n  var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n  styleHighlight(barToStyle);\n}\n\nfunction getInterval(d, y) {\n  var b = d.brush;\n  var active = b.filterSpecified;\n  var closestInterval = NaN;\n  var out = {};\n  var i;\n\n  if (active) {\n    var height = d.height;\n    var intervals = b.filter.getConsolidated();\n    var pixIntervals = unitToPx(intervals, height);\n    var hoveredInterval = NaN;\n    var previousInterval = NaN;\n    var nextInterval = NaN;\n\n    for (i = 0; i <= pixIntervals.length; i++) {\n      var p = pixIntervals[i];\n\n      if (p && p[0] <= y && y <= p[1]) {\n        // over a bar\n        hoveredInterval = i;\n        break;\n      } else {\n        // between bars, or before/after the first/last bar\n        previousInterval = i ? i - 1 : NaN;\n\n        if (p && p[0] > y) {\n          nextInterval = i;\n          break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n        }\n      }\n    }\n\n    closestInterval = hoveredInterval;\n\n    if (isNaN(closestInterval)) {\n      if (isNaN(previousInterval) || isNaN(nextInterval)) {\n        closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n      } else {\n        closestInterval = y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y ? previousInterval : nextInterval;\n      }\n    }\n\n    if (!isNaN(closestInterval)) {\n      var fPix = pixIntervals[closestInterval];\n      var region = getRegion(fPix, y);\n\n      if (region) {\n        out.interval = intervals[closestInterval];\n        out.intervalPix = fPix;\n        out.region = region;\n      }\n    }\n  }\n\n  if (d.ordinal && !out.region) {\n    var a = d.unitTickvals;\n    var unitLocation = d.unitToPaddedPx.invert(y);\n\n    for (i = 0; i < a.length; i++) {\n      var rangei = [a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75, a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75];\n\n      if (unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n        out.clickableOrdinalRange = rangei;\n        break;\n      }\n    }\n  }\n\n  return out;\n}\n\nfunction dragstart(lThis, d) {\n  d3.event.sourceEvent.stopPropagation();\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var unitLocation = d.unitToPaddedPx.invert(y);\n  var b = d.brush;\n  var interval = getInterval(d, y);\n  var unitRange = interval.interval;\n  var s = b.svgBrush;\n  s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n\n  s.grabbingBar = interval.region === 'ns';\n\n  if (s.grabbingBar) {\n    var pixelRange = unitRange.map(d.unitToPaddedPx);\n    s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n    s.barLength = pixelRange[1] - pixelRange[0];\n  }\n\n  s.clickableOrdinalRange = interval.clickableOrdinalRange;\n  s.stayingIntervals = d.multiselect && b.filterSpecified ? b.filter.getConsolidated() : [];\n\n  if (unitRange) {\n    s.stayingIntervals = s.stayingIntervals.filter(function (int2) {\n      return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n    });\n  }\n\n  s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n  d.parent.inBrushDrag = true;\n  s.brushStartCallback();\n}\n\nfunction drag(lThis, d) {\n  d3.event.sourceEvent.stopPropagation();\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var s = d.brush.svgBrush;\n  s.wasDragged = true;\n  s._dragging = true;\n\n  if (s.grabbingBar) {\n    // moving the bar\n    s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n  } else {\n    // south/north drag or new bar creation\n    s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n  }\n\n  d.brush.filterSpecified = true;\n  s.extent = s.stayingIntervals.concat([s.newExtent]);\n  s.brushCallback(d);\n  renderHighlight(lThis.parentNode);\n}\n\nfunction dragend(lThis, d) {\n  var brush = d.brush;\n  var filter = brush.filter;\n  var s = brush.svgBrush;\n\n  if (!s._dragging) {\n    // i.e. click\n    // mock zero drag\n    mousemove(lThis, d);\n    drag(lThis, d); // remember it is a click not a drag\n\n    d.brush.svgBrush.wasDragged = false;\n  }\n\n  s._dragging = false;\n  var e = d3.event;\n  e.sourceEvent.stopPropagation();\n  var grabbingBar = s.grabbingBar;\n  s.grabbingBar = false;\n  s.grabLocation = undefined;\n  d.parent.inBrushDrag = false;\n  clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n\n  if (!s.wasDragged) {\n    // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n    s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n\n    if (s.clickableOrdinalRange) {\n      if (brush.filterSpecified && d.multiselect) {\n        s.extent.push(s.clickableOrdinalRange);\n      } else {\n        s.extent = [s.clickableOrdinalRange];\n        brush.filterSpecified = true;\n      }\n    } else if (grabbingBar) {\n      s.extent = s.stayingIntervals;\n\n      if (s.extent.length === 0) {\n        brushClear(brush);\n      }\n    } else {\n      brushClear(brush);\n    }\n\n    s.brushCallback(d);\n    renderHighlight(lThis.parentNode);\n    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n    return; // no need to fuse intervals or snap to ordinals, so we can bail early\n  }\n\n  var mergeIntervals = function () {\n    // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n    // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n    filter.set(filter.getConsolidated());\n  };\n\n  if (d.ordinal) {\n    var a = d.unitTickvals;\n    if (a[a.length - 1] < a[0]) a.reverse();\n    s.newExtent = [ordinalScaleSnap(0, a, s.newExtent[0], s.stayingIntervals), ordinalScaleSnap(1, a, s.newExtent[1], s.stayingIntervals)];\n    var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n    s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n\n    if (!s.extent.length) {\n      brushClear(brush);\n    }\n\n    s.brushCallback(d);\n\n    if (hasNewExtent) {\n      // merging intervals post the snap tween\n      renderHighlight(lThis.parentNode, mergeIntervals);\n    } else {\n      // if no new interval, don't animate, just redraw the highlight immediately\n      mergeIntervals();\n      renderHighlight(lThis.parentNode);\n    }\n  } else {\n    mergeIntervals(); // merging intervals immediately\n  }\n\n  s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n}\n\nfunction mousemove(lThis, d) {\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var interval = getInterval(d, y);\n  var cursor = 'crosshair';\n  if (interval.clickableOrdinalRange) cursor = 'pointer';else if (interval.region) cursor = interval.region + '-resize';\n  d3.select(document.body).style('cursor', cursor);\n}\n\nfunction attachDragBehavior(selection) {\n  // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n  // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n  // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n  selection.on('mousemove', function (d) {\n    d3.event.preventDefault();\n    if (!d.parent.inBrushDrag) mousemove(this, d);\n  }).on('mouseleave', function (d) {\n    if (!d.parent.inBrushDrag) clearCursor();\n  }).call(d3.behavior.drag().on('dragstart', function (d) {\n    dragstart(this, d);\n  }).on('drag', function (d) {\n    drag(this, d);\n  }).on('dragend', function (d) {\n    dragend(this, d);\n  }));\n}\n\nfunction startAsc(a, b) {\n  return a[0] - b[0];\n}\n\nfunction renderAxisBrush(axisBrush) {\n  var background = axisBrush.selectAll('.background').data(repeat);\n  background.enter().append('rect').classed('background', true).call(barHorizontalSetup).call(backgroundBarHorizontalSetup).style('pointer-events', 'auto') // parent pointer events are disabled; we must have it to register events\n  .attr('transform', 'translate(0 ' + c.verticalPadding + ')');\n  background.call(attachDragBehavior).attr('height', function (d) {\n    return d.height - c.verticalPadding;\n  });\n  var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n  highlightShadow.enter().append('line').classed('highlight-shadow', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width + c.bar.strokeWidth).attr('stroke', c.bar.strokeColor).attr('opacity', c.bar.strokeOpacity).attr('stroke-linecap', 'butt');\n  highlightShadow.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n  var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n  highlight.enter().append('line').classed('highlight', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width - c.bar.strokeWidth).attr('stroke', c.bar.fillColor).attr('opacity', c.bar.fillOpacity).attr('stroke-linecap', 'butt');\n  highlight.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n}\n\nfunction ensureAxisBrush(axisOverlays) {\n  var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush).data(repeat, keyFun);\n  axisBrush.enter().append('g').classed(c.cn.axisBrush, true);\n  renderAxisBrush(axisBrush);\n}\n\nfunction getBrushExtent(brush) {\n  return brush.svgBrush.extent.map(function (e) {\n    return e.slice();\n  });\n}\n\nfunction brushClear(brush) {\n  brush.filterSpecified = false;\n  brush.svgBrush.extent = [[-Infinity, Infinity]];\n}\n\nfunction axisBrushMoved(callback) {\n  return function axisBrushMoved(dimension) {\n    var brush = dimension.brush;\n    var extent = getBrushExtent(brush);\n    var newExtent = extent.slice();\n    brush.filter.set(newExtent);\n    callback();\n  };\n}\n\nfunction dedupeRealRanges(intervals) {\n  // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n  // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n  var queue = intervals.slice();\n  var result = [];\n  var currentInterval;\n  var current = queue.shift();\n\n  while (current) {\n    // [].shift === undefined, so we don't descend into an empty array\n    currentInterval = current.slice();\n\n    while ((current = queue.shift()) && current[0] <=\n    /* right-open interval would need `<` */\n    currentInterval[1]) {\n      currentInterval[1] = Math.max(currentInterval[1], current[1]);\n    }\n\n    result.push(currentInterval);\n  }\n\n  if (result.length === 1 && result[0][0] > result[0][1]) {\n    // discard result\n    result = [];\n  }\n\n  return result;\n}\n\nfunction makeFilter() {\n  var filter = [];\n  var consolidated;\n  var bounds;\n  return {\n    set: function (a) {\n      filter = a.map(function (d) {\n        return d.slice().sort(sortAsc);\n      }).sort(startAsc); // handle unselected case\n\n      if (filter.length === 1 && filter[0][0] === -Infinity && filter[0][1] === Infinity) {\n        filter = [[0, -1]];\n      }\n\n      consolidated = dedupeRealRanges(filter);\n      bounds = filter.reduce(function (p, n) {\n        return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n      }, [Infinity, -Infinity]);\n    },\n    get: function () {\n      return filter.slice();\n    },\n    getConsolidated: function () {\n      return consolidated;\n    },\n    getBounds: function () {\n      return bounds;\n    }\n  };\n}\n\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n  var filter = makeFilter();\n  filter.set(initialRange);\n  return {\n    filter: filter,\n    filterSpecified: rangeSpecified,\n    // there's a difference between not filtering and filtering a non-proper subset\n    svgBrush: {\n      extent: [],\n      // this is where the svgBrush writes contents into\n      brushStartCallback: brushStartCallback,\n      brushCallback: axisBrushMoved(brushCallback),\n      brushEndCallback: brushEndCallback\n    }\n  };\n} // for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\n\n\nfunction cleanRanges(ranges, dimension) {\n  if (Array.isArray(ranges[0])) {\n    ranges = ranges.map(function (ri) {\n      return ri.sort(sortAsc);\n    });\n    if (!dimension.multiselect) ranges = [ranges[0]];else ranges = dedupeRealRanges(ranges.sort(startAsc));\n  } else ranges = [ranges.sort(sortAsc)]; // ordinal snapping\n\n\n  if (dimension.tickvals) {\n    var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n    ranges = ranges.map(function (ri) {\n      var rSnapped = [ordinalScaleSnap(0, sortedTickVals, ri[0], []), ordinalScaleSnap(1, sortedTickVals, ri[1], [])];\n      if (rSnapped[1] > rSnapped[0]) return rSnapped;\n    }).filter(function (ri) {\n      return ri;\n    });\n    if (!ranges.length) return;\n  }\n\n  return ranges.length > 1 ? ranges : ranges[0];\n}\n\nmodule.exports = {\n  makeBrush: makeBrush,\n  ensureAxisBrush: ensureAxisBrush,\n  cleanRanges: cleanRanges\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/parcoords/axisbrush.js"],"names":["c","require","d3","keyFun","repeat","sortAsc","sorterAsc","snapRatio","bar","snapOvershoot","v","vAdjacent","snapClose","closeToCovering","ordinalScaleSnap","isHigh","a","existingRanges","overlappingExisting","dir","first","last","length","tmp","aHere","aPrev","i","nextI","aNext","barHorizontalSetup","selection","attr","captureWidth","backgroundBarHorizontalSetup","style","setHighlight","d","brush","filterSpecified","height","pixelRanges","unitToPx","filter","getConsolidated","dashArray","p","sectionHeight","iNext","currentGap","push","unitRanges","map","pr","Math","max","sort","getRegion","fPix","y","pad","handleHeight","clearCursor","select","document","body","styleHighlight","renderHighlight","root","tweenCallback","selectAll","barToStyle","transition","duration","snapDuration","each","getInterval","b","active","closestInterval","NaN","out","intervals","pixIntervals","hoveredInterval","previousInterval","nextInterval","isNaN","region","interval","intervalPix","ordinal","unitTickvals","unitLocation","unitToPaddedPx","invert","rangei","min","clickableOrdinalRange","dragstart","lThis","event","sourceEvent","stopPropagation","mouse","verticalPadding","unitRange","s","svgBrush","wasDragged","grabbingBar","pixelRange","grabPoint","barLength","stayingIntervals","multiselect","int2","startExtent","parent","inBrushDrag","brushStartCallback","drag","_dragging","newExtent","extent","concat","brushCallback","parentNode","dragend","mousemove","e","grabLocation","undefined","brushClear","brushEndCallback","mergeIntervals","set","reverse","hasNewExtent","cursor","attachDragBehavior","on","preventDefault","call","behavior","startAsc","renderAxisBrush","axisBrush","background","data","enter","append","classed","highlightShadow","width","strokeWidth","strokeColor","strokeOpacity","highlight","fillColor","fillOpacity","ensureAxisBrush","axisOverlays","cn","getBrushExtent","slice","Infinity","axisBrushMoved","callback","dimension","dedupeRealRanges","queue","result","currentInterval","current","shift","makeFilter","consolidated","bounds","reduce","n","get","getBounds","makeBrush","state","rangeSpecified","initialRange","cleanRanges","ranges","Array","isArray","ri","tickvals","sortedTickVals","rSnapped","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar c = require('./constants');\nvar d3 = require('d3');\nvar keyFun = require('../../lib/gup').keyFun;\nvar repeat = require('../../lib/gup').repeat;\nvar sortAsc = require('../../lib').sorterAsc;\n\nvar snapRatio = c.bar.snapRatio;\nfunction snapOvershoot(v, vAdjacent) { return v * (1 - snapRatio) + vAdjacent * snapRatio; }\n\nvar snapClose = c.bar.snapClose;\nfunction closeToCovering(v, vAdjacent) { return v * (1 - snapClose) + vAdjacent * snapClose; }\n\n// snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\nfunction ordinalScaleSnap(isHigh, a, v, existingRanges) {\n    if(overlappingExisting(v, existingRanges)) return v;\n\n    var dir = isHigh ? -1 : 1;\n\n    var first = 0;\n    var last = a.length - 1;\n    if(dir < 0) {\n        var tmp = first;\n        first = last;\n        last = tmp;\n    }\n\n    var aHere = a[first];\n    var aPrev = aHere;\n    for(var i = first; dir * i < dir * last; i += dir) {\n        var nextI = i + dir;\n        var aNext = a[nextI];\n\n        // very close to the previous - snap down to it\n        if(dir * v < dir * closeToCovering(aHere, aNext)) return snapOvershoot(aHere, aPrev);\n        if(dir * v < dir * aNext || nextI === last) return snapOvershoot(aNext, aHere);\n\n        aPrev = aHere;\n        aHere = aNext;\n    }\n}\n\nfunction overlappingExisting(v, existingRanges) {\n    for(var i = 0; i < existingRanges.length; i++) {\n        if(v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n    }\n    return false;\n}\n\nfunction barHorizontalSetup(selection) {\n    selection\n        .attr('x', -c.bar.captureWidth / 2)\n        .attr('width', c.bar.captureWidth);\n}\n\nfunction backgroundBarHorizontalSetup(selection) {\n    selection\n        .attr('visibility', 'visible')\n        .style('visibility', 'visible')\n        .attr('fill', 'yellow')\n        .attr('opacity', 0);\n}\n\nfunction setHighlight(d) {\n    if(!d.brush.filterSpecified) {\n        return '0,' + d.height;\n    }\n\n    var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n    var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n    var p, sectionHeight, iNext;\n    var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n    for(var i = 0; i < pixelRanges.length; i++) {\n        p = pixelRanges[i];\n        sectionHeight = p[1] - p[0];\n        dashArray.push(currentGap);\n        dashArray.push(sectionHeight);\n        iNext = i + 1;\n        if(iNext < pixelRanges.length) {\n            currentGap = pixelRanges[iNext][0] - p[1];\n        }\n    }\n    dashArray.push(d.height);\n    // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n    // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n    // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n    // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n    return dashArray;\n}\n\nfunction unitToPx(unitRanges, height) {\n    return unitRanges.map(function(pr) {\n        return pr.map(function(v) { return Math.max(0, v * height); }).sort(sortAsc);\n    });\n}\n\n// is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\nfunction getRegion(fPix, y) {\n    var pad = c.bar.handleHeight;\n    if(y > fPix[1] + pad || y < fPix[0] - pad) return;\n    if(y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n    if(y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n    return 'ns';\n}\n\nfunction clearCursor() {\n    d3.select(document.body)\n        .style('cursor', null);\n}\n\nfunction styleHighlight(selection) {\n    // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n    // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n    // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n    // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n    selection.attr('stroke-dasharray', setHighlight);\n}\n\nfunction renderHighlight(root, tweenCallback) {\n    var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n    var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n    styleHighlight(barToStyle);\n}\n\nfunction getInterval(d, y) {\n    var b = d.brush;\n    var active = b.filterSpecified;\n    var closestInterval = NaN;\n    var out = {};\n    var i;\n\n    if(active) {\n        var height = d.height;\n        var intervals = b.filter.getConsolidated();\n        var pixIntervals = unitToPx(intervals, height);\n        var hoveredInterval = NaN;\n        var previousInterval = NaN;\n        var nextInterval = NaN;\n        for(i = 0; i <= pixIntervals.length; i++) {\n            var p = pixIntervals[i];\n            if(p && p[0] <= y && y <= p[1]) {\n                // over a bar\n                hoveredInterval = i;\n                break;\n            } else {\n                // between bars, or before/after the first/last bar\n                previousInterval = i ? i - 1 : NaN;\n                if(p && p[0] > y) {\n                    nextInterval = i;\n                    break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n                }\n            }\n        }\n\n        closestInterval = hoveredInterval;\n        if(isNaN(closestInterval)) {\n            if(isNaN(previousInterval) || isNaN(nextInterval)) {\n                closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n            } else {\n                closestInterval = (y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y) ?\n                    previousInterval : nextInterval;\n            }\n        }\n\n        if(!isNaN(closestInterval)) {\n            var fPix = pixIntervals[closestInterval];\n            var region = getRegion(fPix, y);\n\n            if(region) {\n                out.interval = intervals[closestInterval];\n                out.intervalPix = fPix;\n                out.region = region;\n            }\n        }\n    }\n\n    if(d.ordinal && !out.region) {\n        var a = d.unitTickvals;\n        var unitLocation = d.unitToPaddedPx.invert(y);\n        for(i = 0; i < a.length; i++) {\n            var rangei = [\n                a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75,\n                a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75\n            ];\n            if(unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n                out.clickableOrdinalRange = rangei;\n                break;\n            }\n        }\n    }\n\n    return out;\n}\n\nfunction dragstart(lThis, d) {\n    d3.event.sourceEvent.stopPropagation();\n    var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n    var unitLocation = d.unitToPaddedPx.invert(y);\n    var b = d.brush;\n    var interval = getInterval(d, y);\n    var unitRange = interval.interval;\n    var s = b.svgBrush;\n    s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n    s.grabbingBar = interval.region === 'ns';\n    if(s.grabbingBar) {\n        var pixelRange = unitRange.map(d.unitToPaddedPx);\n        s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n        s.barLength = pixelRange[1] - pixelRange[0];\n    }\n    s.clickableOrdinalRange = interval.clickableOrdinalRange;\n    s.stayingIntervals = (d.multiselect && b.filterSpecified) ? b.filter.getConsolidated() : [];\n    if(unitRange) {\n        s.stayingIntervals = s.stayingIntervals.filter(function(int2) {\n            return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n        });\n    }\n    s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n    d.parent.inBrushDrag = true;\n    s.brushStartCallback();\n}\n\nfunction drag(lThis, d) {\n    d3.event.sourceEvent.stopPropagation();\n    var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n    var s = d.brush.svgBrush;\n    s.wasDragged = true;\n    s._dragging = true;\n\n    if(s.grabbingBar) { // moving the bar\n        s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n    } else { // south/north drag or new bar creation\n        s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n    }\n\n    d.brush.filterSpecified = true;\n    s.extent = s.stayingIntervals.concat([s.newExtent]);\n    s.brushCallback(d);\n    renderHighlight(lThis.parentNode);\n}\n\nfunction dragend(lThis, d) {\n    var brush = d.brush;\n    var filter = brush.filter;\n    var s = brush.svgBrush;\n\n    if(!s._dragging) { // i.e. click\n        // mock zero drag\n        mousemove(lThis, d);\n        drag(lThis, d);\n        // remember it is a click not a drag\n        d.brush.svgBrush.wasDragged = false;\n    }\n    s._dragging = false;\n\n    var e = d3.event;\n    e.sourceEvent.stopPropagation();\n    var grabbingBar = s.grabbingBar;\n    s.grabbingBar = false;\n    s.grabLocation = undefined;\n    d.parent.inBrushDrag = false;\n    clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n    if(!s.wasDragged) { // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n        s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n        if(s.clickableOrdinalRange) {\n            if(brush.filterSpecified && d.multiselect) {\n                s.extent.push(s.clickableOrdinalRange);\n            } else {\n                s.extent = [s.clickableOrdinalRange];\n                brush.filterSpecified = true;\n            }\n        } else if(grabbingBar) {\n            s.extent = s.stayingIntervals;\n            if(s.extent.length === 0) {\n                brushClear(brush);\n            }\n        } else {\n            brushClear(brush);\n        }\n        s.brushCallback(d);\n        renderHighlight(lThis.parentNode);\n        s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n        return; // no need to fuse intervals or snap to ordinals, so we can bail early\n    }\n\n    var mergeIntervals = function() {\n        // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n        // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n        filter.set(filter.getConsolidated());\n    };\n\n    if(d.ordinal) {\n        var a = d.unitTickvals;\n        if(a[a.length - 1] < a[0]) a.reverse();\n        s.newExtent = [\n            ordinalScaleSnap(0, a, s.newExtent[0], s.stayingIntervals),\n            ordinalScaleSnap(1, a, s.newExtent[1], s.stayingIntervals)\n        ];\n        var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n        s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n        if(!s.extent.length) {\n            brushClear(brush);\n        }\n        s.brushCallback(d);\n        if(hasNewExtent) {\n            // merging intervals post the snap tween\n            renderHighlight(lThis.parentNode, mergeIntervals);\n        } else {\n            // if no new interval, don't animate, just redraw the highlight immediately\n            mergeIntervals();\n            renderHighlight(lThis.parentNode);\n        }\n    } else {\n        mergeIntervals(); // merging intervals immediately\n    }\n    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n}\n\nfunction mousemove(lThis, d) {\n    var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n    var interval = getInterval(d, y);\n\n    var cursor = 'crosshair';\n    if(interval.clickableOrdinalRange) cursor = 'pointer';\n    else if(interval.region) cursor = interval.region + '-resize';\n    d3.select(document.body)\n        .style('cursor', cursor);\n}\n\nfunction attachDragBehavior(selection) {\n    // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n    // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n    // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n    selection\n        .on('mousemove', function(d) {\n            d3.event.preventDefault();\n            if(!d.parent.inBrushDrag) mousemove(this, d);\n        })\n        .on('mouseleave', function(d) {\n            if(!d.parent.inBrushDrag) clearCursor();\n        })\n        .call(d3.behavior.drag()\n            .on('dragstart', function(d) { dragstart(this, d); })\n            .on('drag', function(d) { drag(this, d); })\n            .on('dragend', function(d) { dragend(this, d); })\n        );\n}\n\nfunction startAsc(a, b) { return a[0] - b[0]; }\n\nfunction renderAxisBrush(axisBrush) {\n    var background = axisBrush.selectAll('.background').data(repeat);\n\n    background.enter()\n        .append('rect')\n        .classed('background', true)\n        .call(barHorizontalSetup)\n        .call(backgroundBarHorizontalSetup)\n        .style('pointer-events', 'auto') // parent pointer events are disabled; we must have it to register events\n        .attr('transform', 'translate(0 ' + c.verticalPadding + ')');\n\n    background\n        .call(attachDragBehavior)\n        .attr('height', function(d) {\n            return d.height - c.verticalPadding;\n        });\n\n    var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n    highlightShadow.enter()\n        .append('line')\n        .classed('highlight-shadow', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width + c.bar.strokeWidth)\n        .attr('stroke', c.bar.strokeColor)\n        .attr('opacity', c.bar.strokeOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlightShadow\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n\n    var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n    highlight.enter()\n        .append('line')\n        .classed('highlight', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width - c.bar.strokeWidth)\n        .attr('stroke', c.bar.fillColor)\n        .attr('opacity', c.bar.fillOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlight\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n}\n\nfunction ensureAxisBrush(axisOverlays) {\n    var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush)\n        .data(repeat, keyFun);\n\n    axisBrush.enter()\n        .append('g')\n        .classed(c.cn.axisBrush, true);\n\n    renderAxisBrush(axisBrush);\n}\n\nfunction getBrushExtent(brush) {\n    return brush.svgBrush.extent.map(function(e) {return e.slice();});\n}\n\nfunction brushClear(brush) {\n    brush.filterSpecified = false;\n    brush.svgBrush.extent = [[-Infinity, Infinity]];\n}\n\nfunction axisBrushMoved(callback) {\n    return function axisBrushMoved(dimension) {\n        var brush = dimension.brush;\n        var extent = getBrushExtent(brush);\n        var newExtent = extent.slice();\n        brush.filter.set(newExtent);\n        callback();\n    };\n}\n\nfunction dedupeRealRanges(intervals) {\n    // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n    // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n    var queue = intervals.slice();\n    var result = [];\n    var currentInterval;\n    var current = queue.shift();\n    while(current) { // [].shift === undefined, so we don't descend into an empty array\n        currentInterval = current.slice();\n        while((current = queue.shift()) && current[0] <= /* right-open interval would need `<` */ currentInterval[1]) {\n            currentInterval[1] = Math.max(currentInterval[1], current[1]);\n        }\n        result.push(currentInterval);\n    }\n\n    if(\n        result.length === 1 &&\n        result[0][0] > result[0][1]\n    ) {\n        // discard result\n        result = [];\n    }\n\n    return result;\n}\n\nfunction makeFilter() {\n    var filter = [];\n    var consolidated;\n    var bounds;\n    return {\n        set: function(a) {\n            filter = a\n                .map(function(d) { return d.slice().sort(sortAsc); })\n                .sort(startAsc);\n\n            // handle unselected case\n            if(filter.length === 1 &&\n                filter[0][0] === -Infinity &&\n                filter[0][1] === Infinity) {\n                filter = [[0, -1]];\n            }\n\n            consolidated = dedupeRealRanges(filter);\n            bounds = filter.reduce(function(p, n) {\n                return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n            }, [Infinity, -Infinity]);\n        },\n        get: function() { return filter.slice(); },\n        getConsolidated: function() { return consolidated; },\n        getBounds: function() { return bounds; }\n    };\n}\n\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n    var filter = makeFilter();\n    filter.set(initialRange);\n    return {\n        filter: filter,\n        filterSpecified: rangeSpecified, // there's a difference between not filtering and filtering a non-proper subset\n        svgBrush: {\n            extent: [], // this is where the svgBrush writes contents into\n            brushStartCallback: brushStartCallback,\n            brushCallback: axisBrushMoved(brushCallback),\n            brushEndCallback: brushEndCallback\n        }\n    };\n}\n\n// for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\nfunction cleanRanges(ranges, dimension) {\n    if(Array.isArray(ranges[0])) {\n        ranges = ranges.map(function(ri) { return ri.sort(sortAsc); });\n\n        if(!dimension.multiselect) ranges = [ranges[0]];\n        else ranges = dedupeRealRanges(ranges.sort(startAsc));\n    } else ranges = [ranges.sort(sortAsc)];\n\n    // ordinal snapping\n    if(dimension.tickvals) {\n        var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n        ranges = ranges.map(function(ri) {\n            var rSnapped = [\n                ordinalScaleSnap(0, sortedTickVals, ri[0], []),\n                ordinalScaleSnap(1, sortedTickVals, ri[1], [])\n            ];\n            if(rSnapped[1] > rSnapped[0]) return rSnapped;\n        })\n        .filter(function(ri) { return ri; });\n\n        if(!ranges.length) return;\n    }\n    return ranges.length > 1 ? ranges : ranges[0];\n}\n\nmodule.exports = {\n    makeBrush: makeBrush,\n    ensureAxisBrush: ensureAxisBrush,\n    cleanRanges: cleanRanges\n};\n"]},"metadata":{},"sourceType":"script"}