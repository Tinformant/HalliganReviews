{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar polygonTester = require('../../lib/polygon').tester;\n\nvar findIndexOfMin = Lib.findIndexOfMin;\nvar isAngleInsideSector = Lib.isAngleInsideSector;\nvar angleDelta = Lib.angleDelta;\nvar angleDist = Lib.angleDist;\n/**\n * is pt (r,a) inside polygon made up vertices at angles 'vangles'\n * inside a given polar sector\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {boolean}\n */\n\nfunction isPtInsidePolygon(r, a, rBnds, aBnds, vangles) {\n  if (!isAngleInsideSector(a, aBnds)) return false;\n  var r0, r1;\n\n  if (rBnds[0] < rBnds[1]) {\n    r0 = rBnds[0];\n    r1 = rBnds[1];\n  } else {\n    r0 = rBnds[1];\n    r1 = rBnds[0];\n  }\n\n  var polygonIn = polygonTester(makePolygon(r0, aBnds[0], aBnds[1], vangles));\n  var polygonOut = polygonTester(makePolygon(r1, aBnds[0], aBnds[1], vangles));\n  var xy = [r * Math.cos(a), r * Math.sin(a)];\n  return polygonOut.contains(xy) && !polygonIn.contains(xy);\n} // find intersection of 'v0' <-> 'v1' edge with a ray at angle 'a'\n// (i.e. a line that starts from the origin at angle 'a')\n// given an (xp,yp) pair on the 'v0' <-> 'v1' line\n// (N.B. 'v0' and 'v1' are angles in radians)\n\n\nfunction findIntersectionXY(v0, v1, a, xpyp) {\n  var xstar, ystar;\n  var xp = xpyp[0];\n  var yp = xpyp[1];\n  var dsin = clampTiny(Math.sin(v1) - Math.sin(v0));\n  var dcos = clampTiny(Math.cos(v1) - Math.cos(v0));\n  var tanA = Math.tan(a);\n  var cotanA = clampTiny(1 / tanA);\n  var m = dsin / dcos;\n  var b = yp - m * xp;\n\n  if (cotanA) {\n    if (dsin && dcos) {\n      // given\n      //  g(x) := v0 -> v1 line = m*x + b\n      //  h(x) := ray at angle 'a' = m*x = tanA*x\n      // solve g(xstar) = h(xstar)\n      xstar = b / (tanA - m);\n      ystar = tanA * xstar;\n    } else if (dcos) {\n      // horizontal v0 -> v1\n      xstar = yp * cotanA;\n      ystar = yp;\n    } else {\n      // vertical v0 -> v1\n      xstar = xp;\n      ystar = xp * tanA;\n    }\n  } else {\n    // vertical ray\n    if (dsin && dcos) {\n      xstar = 0;\n      ystar = b;\n    } else if (dcos) {\n      xstar = 0;\n      ystar = yp;\n    } else {\n      // does this case exists?\n      xstar = ystar = NaN;\n    }\n  }\n\n  return [xstar, ystar];\n} // solves l^2 = (f(x)^2 - yp)^2 + (x - xp)^2\n// rearranged into 0 = a*x^2 + b * x + c\n//\n// where f(x) = m*x + t + yp\n// and   (x0, x1) = (-b +/- del) / (2*a)\n\n\nfunction findXYatLength(l, m, xp, yp) {\n  var t = -m * xp;\n  var a = m * m + 1;\n  var b = 2 * (m * t - xp);\n  var c = t * t + xp * xp - l * l;\n  var del = Math.sqrt(b * b - 4 * a * c);\n  var x0 = (-b + del) / (2 * a);\n  var x1 = (-b - del) / (2 * a);\n  return [[x0, m * x0 + t + yp], [x1, m * x1 + t + yp]];\n}\n\nfunction makeRegularPolygon(r, vangles) {\n  var len = vangles.length;\n  var vertices = new Array(len + 1);\n  var i;\n\n  for (i = 0; i < len; i++) {\n    var va = vangles[i];\n    vertices[i] = [r * Math.cos(va), r * Math.sin(va)];\n  }\n\n  vertices[i] = vertices[0].slice();\n  return vertices;\n}\n\nfunction makeClippedPolygon(r, a0, a1, vangles) {\n  var len = vangles.length;\n  var vertices = [];\n  var i, j;\n\n  function a2xy(a) {\n    return [r * Math.cos(a), r * Math.sin(a)];\n  }\n\n  function findXY(va0, va1, s) {\n    return findIntersectionXY(va0, va1, s, a2xy(va0));\n  }\n\n  function cycleIndex(ind) {\n    return Lib.mod(ind, len);\n  }\n\n  function isInside(v) {\n    return isAngleInsideSector(v, [a0, a1]);\n  } // find index in sector closest to a0\n  // use it to find intersection of v[i0] <-> v[i0-1] edge with sector radius\n\n\n  var i0 = findIndexOfMin(vangles, function (v) {\n    return isInside(v) ? angleDist(v, a0) : Infinity;\n  });\n  var xy0 = findXY(vangles[i0], vangles[cycleIndex(i0 - 1)], a0);\n  vertices.push(xy0); // fill in in-sector vertices\n\n  for (i = i0, j = 0; j < len; i++, j++) {\n    var va = vangles[cycleIndex(i)];\n    if (!isInside(va)) break;\n    vertices.push(a2xy(va));\n  } // find index in sector closest to a1,\n  // use it to find intersection of v[iN] <-> v[iN+1] edge with sector radius\n\n\n  var iN = findIndexOfMin(vangles, function (v) {\n    return isInside(v) ? angleDist(v, a1) : Infinity;\n  });\n  var xyN = findXY(vangles[iN], vangles[cycleIndex(iN + 1)], a1);\n  vertices.push(xyN);\n  vertices.push([0, 0]);\n  vertices.push(vertices[0].slice());\n  return vertices;\n}\n\nfunction makePolygon(r, a0, a1, vangles) {\n  return Lib.isFullCircle([a0, a1]) ? makeRegularPolygon(r, vangles) : makeClippedPolygon(r, a0, a1, vangles);\n}\n\nfunction findPolygonOffset(r, a0, a1, vangles) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var vertices = makePolygon(r, a0, a1, vangles);\n\n  for (var i = 0; i < vertices.length; i++) {\n    var v = vertices[i];\n    minX = Math.min(minX, v[0]);\n    minY = Math.min(minY, -v[1]);\n  }\n\n  return [minX, minY];\n}\n/**\n * find vertex angles (in 'vangles') the enclose angle 'a'\n *\n * @param {number} a : angle in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {2-item array}\n */\n\n\nfunction findEnclosingVertexAngles(a, vangles) {\n  var minFn = function (v) {\n    var adelta = angleDelta(v, a);\n    return adelta > 0 ? adelta : Infinity;\n  };\n\n  var i0 = findIndexOfMin(vangles, minFn);\n  var i1 = Lib.mod(i0 + 1, vangles.length);\n  return [vangles[i0], vangles[i1]];\n} // to more easily catch 'almost zero' numbers in if-else blocks\n\n\nfunction clampTiny(v) {\n  return Math.abs(v) > 1e-10 ? v : 0;\n}\n\nfunction transformForSVG(pts0, cx, cy) {\n  cx = cx || 0;\n  cy = cy || 0;\n  var len = pts0.length;\n  var pts1 = new Array(len);\n\n  for (var i = 0; i < len; i++) {\n    var pt = pts0[i];\n    pts1[i] = [cx + pt[0], cy - pt[1]];\n  }\n\n  return pts1;\n}\n/**\n * path polygon\n *\n * @param {number} r : polygon 'radius'\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\n\n\nfunction pathPolygon(r, a0, a1, vangles, cx, cy) {\n  var poly = makePolygon(r, a0, a1, vangles);\n  return 'M' + transformForSVG(poly, cx, cy).join('L');\n}\n/**\n * path a polygon 'annulus'\n * i.e. a polygon with a concentric hole\n *\n * N.B. this routine uses the evenodd SVG rule\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\n\n\nfunction pathPolygonAnnulus(r0, r1, a0, a1, vangles, cx, cy) {\n  var rStart, rEnd;\n\n  if (r0 < r1) {\n    rStart = r0;\n    rEnd = r1;\n  } else {\n    rStart = r1;\n    rEnd = r0;\n  }\n\n  var inner = transformForSVG(makePolygon(rStart, a0, a1, vangles), cx, cy);\n  var outer = transformForSVG(makePolygon(rEnd, a0, a1, vangles), cx, cy);\n  return 'M' + outer.reverse().join('L') + 'M' + inner.join('L');\n}\n\nmodule.exports = {\n  isPtInsidePolygon: isPtInsidePolygon,\n  findPolygonOffset: findPolygonOffset,\n  findEnclosingVertexAngles: findEnclosingVertexAngles,\n  findIntersectionXY: findIntersectionXY,\n  findXYatLength: findXYatLength,\n  clampTiny: clampTiny,\n  pathPolygon: pathPolygon,\n  pathPolygonAnnulus: pathPolygonAnnulus\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/plots/polar/helpers.js"],"names":["Lib","require","polygonTester","tester","findIndexOfMin","isAngleInsideSector","angleDelta","angleDist","isPtInsidePolygon","r","a","rBnds","aBnds","vangles","r0","r1","polygonIn","makePolygon","polygonOut","xy","Math","cos","sin","contains","findIntersectionXY","v0","v1","xpyp","xstar","ystar","xp","yp","dsin","clampTiny","dcos","tanA","tan","cotanA","m","b","NaN","findXYatLength","l","t","c","del","sqrt","x0","x1","makeRegularPolygon","len","length","vertices","Array","i","va","slice","makeClippedPolygon","a0","a1","j","a2xy","findXY","va0","va1","s","cycleIndex","ind","mod","isInside","v","i0","Infinity","xy0","push","iN","xyN","isFullCircle","findPolygonOffset","minX","minY","min","findEnclosingVertexAngles","minFn","adelta","i1","abs","transformForSVG","pts0","cx","cy","pts1","pt","pathPolygon","poly","join","pathPolygonAnnulus","rStart","rEnd","inner","outer","reverse","module","exports"],"mappings":"AAAA;;;;;;;AAQA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,mBAAD,CAAP,CAA6BE,MAAjD;;AAEA,IAAIC,cAAc,GAAGJ,GAAG,CAACI,cAAzB;AACA,IAAIC,mBAAmB,GAAGL,GAAG,CAACK,mBAA9B;AACA,IAAIC,UAAU,GAAGN,GAAG,CAACM,UAArB;AACA,IAAIC,SAAS,GAAGP,GAAG,CAACO,SAApB;AAEA;;;;;;;;;;;;AAWA,SAASC,iBAAT,CAA2BC,CAA3B,EAA8BC,CAA9B,EAAiCC,KAAjC,EAAwCC,KAAxC,EAA+CC,OAA/C,EAAwD;AACpD,MAAG,CAACR,mBAAmB,CAACK,CAAD,EAAIE,KAAJ,CAAvB,EAAmC,OAAO,KAAP;AAEnC,MAAIE,EAAJ,EAAQC,EAAR;;AAEA,MAAGJ,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAnB,EAAwB;AACpBG,IAAAA,EAAE,GAAGH,KAAK,CAAC,CAAD,CAAV;AACAI,IAAAA,EAAE,GAAGJ,KAAK,CAAC,CAAD,CAAV;AACH,GAHD,MAGO;AACHG,IAAAA,EAAE,GAAGH,KAAK,CAAC,CAAD,CAAV;AACAI,IAAAA,EAAE,GAAGJ,KAAK,CAAC,CAAD,CAAV;AACH;;AAED,MAAIK,SAAS,GAAGd,aAAa,CAACe,WAAW,CAACH,EAAD,EAAKF,KAAK,CAAC,CAAD,CAAV,EAAeA,KAAK,CAAC,CAAD,CAApB,EAAyBC,OAAzB,CAAZ,CAA7B;AACA,MAAIK,UAAU,GAAGhB,aAAa,CAACe,WAAW,CAACF,EAAD,EAAKH,KAAK,CAAC,CAAD,CAAV,EAAeA,KAAK,CAAC,CAAD,CAApB,EAAyBC,OAAzB,CAAZ,CAA9B;AACA,MAAIM,EAAE,GAAG,CAACV,CAAC,GAAGW,IAAI,CAACC,GAAL,CAASX,CAAT,CAAL,EAAkBD,CAAC,GAAGW,IAAI,CAACE,GAAL,CAASZ,CAAT,CAAtB,CAAT;AACA,SAAOQ,UAAU,CAACK,QAAX,CAAoBJ,EAApB,KAA2B,CAACH,SAAS,CAACO,QAAV,CAAmBJ,EAAnB,CAAnC;AACH,C,CAED;AACA;AACA;AACA;;;AACA,SAASK,kBAAT,CAA4BC,EAA5B,EAAgCC,EAAhC,EAAoChB,CAApC,EAAuCiB,IAAvC,EAA6C;AACzC,MAAIC,KAAJ,EAAWC,KAAX;AAEA,MAAIC,EAAE,GAAGH,IAAI,CAAC,CAAD,CAAb;AACA,MAAII,EAAE,GAAGJ,IAAI,CAAC,CAAD,CAAb;AACA,MAAIK,IAAI,GAAGC,SAAS,CAACb,IAAI,CAACE,GAAL,CAASI,EAAT,IAAeN,IAAI,CAACE,GAAL,CAASG,EAAT,CAAhB,CAApB;AACA,MAAIS,IAAI,GAAGD,SAAS,CAACb,IAAI,CAACC,GAAL,CAASK,EAAT,IAAeN,IAAI,CAACC,GAAL,CAASI,EAAT,CAAhB,CAApB;AACA,MAAIU,IAAI,GAAGf,IAAI,CAACgB,GAAL,CAAS1B,CAAT,CAAX;AACA,MAAI2B,MAAM,GAAGJ,SAAS,CAAC,IAAIE,IAAL,CAAtB;AACA,MAAIG,CAAC,GAAGN,IAAI,GAAGE,IAAf;AACA,MAAIK,CAAC,GAAGR,EAAE,GAAGO,CAAC,GAAGR,EAAjB;;AAEA,MAAGO,MAAH,EAAW;AACP,QAAGL,IAAI,IAAIE,IAAX,EAAiB;AACb;AACA;AACA;AACA;AACAN,MAAAA,KAAK,GAAGW,CAAC,IAAIJ,IAAI,GAAGG,CAAX,CAAT;AACAT,MAAAA,KAAK,GAAGM,IAAI,GAAGP,KAAf;AACH,KAPD,MAOO,IAAGM,IAAH,EAAS;AACZ;AACAN,MAAAA,KAAK,GAAGG,EAAE,GAAGM,MAAb;AACAR,MAAAA,KAAK,GAAGE,EAAR;AACH,KAJM,MAIA;AACH;AACAH,MAAAA,KAAK,GAAGE,EAAR;AACAD,MAAAA,KAAK,GAAGC,EAAE,GAAGK,IAAb;AACH;AACJ,GAjBD,MAiBO;AACH;AACA,QAAGH,IAAI,IAAIE,IAAX,EAAiB;AACbN,MAAAA,KAAK,GAAG,CAAR;AACAC,MAAAA,KAAK,GAAGU,CAAR;AACH,KAHD,MAGO,IAAGL,IAAH,EAAS;AACZN,MAAAA,KAAK,GAAG,CAAR;AACAC,MAAAA,KAAK,GAAGE,EAAR;AACH,KAHM,MAGA;AACH;AACAH,MAAAA,KAAK,GAAGC,KAAK,GAAGW,GAAhB;AACH;AACJ;;AAED,SAAO,CAACZ,KAAD,EAAQC,KAAR,CAAP;AACH,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASY,cAAT,CAAwBC,CAAxB,EAA2BJ,CAA3B,EAA8BR,EAA9B,EAAkCC,EAAlC,EAAsC;AAClC,MAAIY,CAAC,GAAG,CAACL,CAAD,GAAKR,EAAb;AACA,MAAIpB,CAAC,GAAG4B,CAAC,GAAGA,CAAJ,GAAQ,CAAhB;AACA,MAAIC,CAAC,GAAG,KAAKD,CAAC,GAAGK,CAAJ,GAAQb,EAAb,CAAR;AACA,MAAIc,CAAC,GAAGD,CAAC,GAAGA,CAAJ,GAAQb,EAAE,GAAGA,EAAb,GAAkBY,CAAC,GAAGA,CAA9B;AACA,MAAIG,GAAG,GAAGzB,IAAI,CAAC0B,IAAL,CAAUP,CAAC,GAAGA,CAAJ,GAAQ,IAAI7B,CAAJ,GAAQkC,CAA1B,CAAV;AACA,MAAIG,EAAE,GAAG,CAAC,CAACR,CAAD,GAAKM,GAAN,KAAc,IAAInC,CAAlB,CAAT;AACA,MAAIsC,EAAE,GAAG,CAAC,CAACT,CAAD,GAAKM,GAAN,KAAc,IAAInC,CAAlB,CAAT;AACA,SAAO,CACH,CAACqC,EAAD,EAAKT,CAAC,GAAGS,EAAJ,GAASJ,CAAT,GAAaZ,EAAlB,CADG,EAEH,CAACiB,EAAD,EAAKV,CAAC,GAAGU,EAAJ,GAASL,CAAT,GAAaZ,EAAlB,CAFG,CAAP;AAIH;;AAED,SAASkB,kBAAT,CAA4BxC,CAA5B,EAA+BI,OAA/B,EAAwC;AACpC,MAAIqC,GAAG,GAAGrC,OAAO,CAACsC,MAAlB;AACA,MAAIC,QAAQ,GAAG,IAAIC,KAAJ,CAAUH,GAAG,GAAG,CAAhB,CAAf;AACA,MAAII,CAAJ;;AACA,OAAIA,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGJ,GAAf,EAAoBI,CAAC,EAArB,EAAyB;AACrB,QAAIC,EAAE,GAAG1C,OAAO,CAACyC,CAAD,CAAhB;AACAF,IAAAA,QAAQ,CAACE,CAAD,CAAR,GAAc,CAAC7C,CAAC,GAAGW,IAAI,CAACC,GAAL,CAASkC,EAAT,CAAL,EAAmB9C,CAAC,GAAGW,IAAI,CAACE,GAAL,CAASiC,EAAT,CAAvB,CAAd;AACH;;AACDH,EAAAA,QAAQ,CAACE,CAAD,CAAR,GAAcF,QAAQ,CAAC,CAAD,CAAR,CAAYI,KAAZ,EAAd;AACA,SAAOJ,QAAP;AACH;;AAED,SAASK,kBAAT,CAA4BhD,CAA5B,EAA+BiD,EAA/B,EAAmCC,EAAnC,EAAuC9C,OAAvC,EAAgD;AAC5C,MAAIqC,GAAG,GAAGrC,OAAO,CAACsC,MAAlB;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIE,CAAJ,EAAOM,CAAP;;AAEA,WAASC,IAAT,CAAcnD,CAAd,EAAiB;AACb,WAAO,CAACD,CAAC,GAAGW,IAAI,CAACC,GAAL,CAASX,CAAT,CAAL,EAAkBD,CAAC,GAAGW,IAAI,CAACE,GAAL,CAASZ,CAAT,CAAtB,CAAP;AACH;;AAED,WAASoD,MAAT,CAAgBC,GAAhB,EAAqBC,GAArB,EAA0BC,CAA1B,EAA6B;AACzB,WAAOzC,kBAAkB,CAACuC,GAAD,EAAMC,GAAN,EAAWC,CAAX,EAAcJ,IAAI,CAACE,GAAD,CAAlB,CAAzB;AACH;;AAED,WAASG,UAAT,CAAoBC,GAApB,EAAyB;AACrB,WAAOnE,GAAG,CAACoE,GAAJ,CAAQD,GAAR,EAAajB,GAAb,CAAP;AACH;;AAED,WAASmB,QAAT,CAAkBC,CAAlB,EAAqB;AACjB,WAAOjE,mBAAmB,CAACiE,CAAD,EAAI,CAACZ,EAAD,EAAKC,EAAL,CAAJ,CAA1B;AACH,GAnB2C,CAqB5C;AACA;;;AACA,MAAIY,EAAE,GAAGnE,cAAc,CAACS,OAAD,EAAU,UAASyD,CAAT,EAAY;AACzC,WAAOD,QAAQ,CAACC,CAAD,CAAR,GAAc/D,SAAS,CAAC+D,CAAD,EAAIZ,EAAJ,CAAvB,GAAiCc,QAAxC;AACH,GAFsB,CAAvB;AAGA,MAAIC,GAAG,GAAGX,MAAM,CAACjD,OAAO,CAAC0D,EAAD,CAAR,EAAc1D,OAAO,CAACqD,UAAU,CAACK,EAAE,GAAG,CAAN,CAAX,CAArB,EAA2Cb,EAA3C,CAAhB;AACAN,EAAAA,QAAQ,CAACsB,IAAT,CAAcD,GAAd,EA3B4C,CA6B5C;;AACA,OAAInB,CAAC,GAAGiB,EAAJ,EAAQX,CAAC,GAAG,CAAhB,EAAmBA,CAAC,GAAGV,GAAvB,EAA4BI,CAAC,IAAIM,CAAC,EAAlC,EAAsC;AAClC,QAAIL,EAAE,GAAG1C,OAAO,CAACqD,UAAU,CAACZ,CAAD,CAAX,CAAhB;AACA,QAAG,CAACe,QAAQ,CAACd,EAAD,CAAZ,EAAkB;AAClBH,IAAAA,QAAQ,CAACsB,IAAT,CAAcb,IAAI,CAACN,EAAD,CAAlB;AACH,GAlC2C,CAoC5C;AACA;;;AACA,MAAIoB,EAAE,GAAGvE,cAAc,CAACS,OAAD,EAAU,UAASyD,CAAT,EAAY;AACzC,WAAOD,QAAQ,CAACC,CAAD,CAAR,GAAc/D,SAAS,CAAC+D,CAAD,EAAIX,EAAJ,CAAvB,GAAiCa,QAAxC;AACH,GAFsB,CAAvB;AAGA,MAAII,GAAG,GAAGd,MAAM,CAACjD,OAAO,CAAC8D,EAAD,CAAR,EAAc9D,OAAO,CAACqD,UAAU,CAACS,EAAE,GAAG,CAAN,CAAX,CAArB,EAA2ChB,EAA3C,CAAhB;AACAP,EAAAA,QAAQ,CAACsB,IAAT,CAAcE,GAAd;AAEAxB,EAAAA,QAAQ,CAACsB,IAAT,CAAc,CAAC,CAAD,EAAI,CAAJ,CAAd;AACAtB,EAAAA,QAAQ,CAACsB,IAAT,CAActB,QAAQ,CAAC,CAAD,CAAR,CAAYI,KAAZ,EAAd;AAEA,SAAOJ,QAAP;AACH;;AAED,SAASnC,WAAT,CAAqBR,CAArB,EAAwBiD,EAAxB,EAA4BC,EAA5B,EAAgC9C,OAAhC,EAAyC;AACrC,SAAOb,GAAG,CAAC6E,YAAJ,CAAiB,CAACnB,EAAD,EAAKC,EAAL,CAAjB,IACHV,kBAAkB,CAACxC,CAAD,EAAII,OAAJ,CADf,GAEH4C,kBAAkB,CAAChD,CAAD,EAAIiD,EAAJ,EAAQC,EAAR,EAAY9C,OAAZ,CAFtB;AAGH;;AAED,SAASiE,iBAAT,CAA2BrE,CAA3B,EAA8BiD,EAA9B,EAAkCC,EAAlC,EAAsC9C,OAAtC,EAA+C;AAC3C,MAAIkE,IAAI,GAAGP,QAAX;AACA,MAAIQ,IAAI,GAAGR,QAAX;AACA,MAAIpB,QAAQ,GAAGnC,WAAW,CAACR,CAAD,EAAIiD,EAAJ,EAAQC,EAAR,EAAY9C,OAAZ,CAA1B;;AAEA,OAAI,IAAIyC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,QAAQ,CAACD,MAA5B,EAAoCG,CAAC,EAArC,EAAyC;AACrC,QAAIgB,CAAC,GAAGlB,QAAQ,CAACE,CAAD,CAAhB;AACAyB,IAAAA,IAAI,GAAG3D,IAAI,CAAC6D,GAAL,CAASF,IAAT,EAAeT,CAAC,CAAC,CAAD,CAAhB,CAAP;AACAU,IAAAA,IAAI,GAAG5D,IAAI,CAAC6D,GAAL,CAASD,IAAT,EAAe,CAACV,CAAC,CAAC,CAAD,CAAjB,CAAP;AACH;;AACD,SAAO,CAACS,IAAD,EAAOC,IAAP,CAAP;AACH;AAED;;;;;;;;;AAOA,SAASE,yBAAT,CAAmCxE,CAAnC,EAAsCG,OAAtC,EAA+C;AAC3C,MAAIsE,KAAK,GAAG,UAASb,CAAT,EAAY;AACpB,QAAIc,MAAM,GAAG9E,UAAU,CAACgE,CAAD,EAAI5D,CAAJ,CAAvB;AACA,WAAO0E,MAAM,GAAG,CAAT,GAAaA,MAAb,GAAsBZ,QAA7B;AACH,GAHD;;AAIA,MAAID,EAAE,GAAGnE,cAAc,CAACS,OAAD,EAAUsE,KAAV,CAAvB;AACA,MAAIE,EAAE,GAAGrF,GAAG,CAACoE,GAAJ,CAAQG,EAAE,GAAG,CAAb,EAAgB1D,OAAO,CAACsC,MAAxB,CAAT;AACA,SAAO,CAACtC,OAAO,CAAC0D,EAAD,CAAR,EAAc1D,OAAO,CAACwE,EAAD,CAArB,CAAP;AACH,C,CAED;;;AACA,SAASpD,SAAT,CAAmBqC,CAAnB,EAAsB;AAClB,SAAOlD,IAAI,CAACkE,GAAL,CAAShB,CAAT,IAAc,KAAd,GAAsBA,CAAtB,GAA0B,CAAjC;AACH;;AAED,SAASiB,eAAT,CAAyBC,IAAzB,EAA+BC,EAA/B,EAAmCC,EAAnC,EAAuC;AACnCD,EAAAA,EAAE,GAAGA,EAAE,IAAI,CAAX;AACAC,EAAAA,EAAE,GAAGA,EAAE,IAAI,CAAX;AAEA,MAAIxC,GAAG,GAAGsC,IAAI,CAACrC,MAAf;AACA,MAAIwC,IAAI,GAAG,IAAItC,KAAJ,CAAUH,GAAV,CAAX;;AAEA,OAAI,IAAII,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGJ,GAAnB,EAAwBI,CAAC,EAAzB,EAA6B;AACzB,QAAIsC,EAAE,GAAGJ,IAAI,CAAClC,CAAD,CAAb;AACAqC,IAAAA,IAAI,CAACrC,CAAD,CAAJ,GAAU,CAACmC,EAAE,GAAGG,EAAE,CAAC,CAAD,CAAR,EAAaF,EAAE,GAAGE,EAAE,CAAC,CAAD,CAApB,CAAV;AACH;;AACD,SAAOD,IAAP;AACH;AAED;;;;;;;;;;;;;;AAYA,SAASE,WAAT,CAAqBpF,CAArB,EAAwBiD,EAAxB,EAA4BC,EAA5B,EAAgC9C,OAAhC,EAAyC4E,EAAzC,EAA6CC,EAA7C,EAAiD;AAC7C,MAAII,IAAI,GAAG7E,WAAW,CAACR,CAAD,EAAIiD,EAAJ,EAAQC,EAAR,EAAY9C,OAAZ,CAAtB;AACA,SAAO,MAAM0E,eAAe,CAACO,IAAD,EAAOL,EAAP,EAAWC,EAAX,CAAf,CAA8BK,IAA9B,CAAmC,GAAnC,CAAb;AACH;AAED;;;;;;;;;;;;;;;;;;AAgBA,SAASC,kBAAT,CAA4BlF,EAA5B,EAAgCC,EAAhC,EAAoC2C,EAApC,EAAwCC,EAAxC,EAA4C9C,OAA5C,EAAqD4E,EAArD,EAAyDC,EAAzD,EAA6D;AACzD,MAAIO,MAAJ,EAAYC,IAAZ;;AAEA,MAAGpF,EAAE,GAAGC,EAAR,EAAY;AACRkF,IAAAA,MAAM,GAAGnF,EAAT;AACAoF,IAAAA,IAAI,GAAGnF,EAAP;AACH,GAHD,MAGO;AACHkF,IAAAA,MAAM,GAAGlF,EAAT;AACAmF,IAAAA,IAAI,GAAGpF,EAAP;AACH;;AAED,MAAIqF,KAAK,GAAGZ,eAAe,CAACtE,WAAW,CAACgF,MAAD,EAASvC,EAAT,EAAaC,EAAb,EAAiB9C,OAAjB,CAAZ,EAAuC4E,EAAvC,EAA2CC,EAA3C,CAA3B;AACA,MAAIU,KAAK,GAAGb,eAAe,CAACtE,WAAW,CAACiF,IAAD,EAAOxC,EAAP,EAAWC,EAAX,EAAe9C,OAAf,CAAZ,EAAqC4E,EAArC,EAAyCC,EAAzC,CAA3B;AACA,SAAO,MAAMU,KAAK,CAACC,OAAN,GAAgBN,IAAhB,CAAqB,GAArB,CAAN,GAAkC,GAAlC,GAAwCI,KAAK,CAACJ,IAAN,CAAW,GAAX,CAA/C;AACH;;AAEDO,MAAM,CAACC,OAAP,GAAiB;AACb/F,EAAAA,iBAAiB,EAAEA,iBADN;AAEbsE,EAAAA,iBAAiB,EAAEA,iBAFN;AAGbI,EAAAA,yBAAyB,EAAEA,yBAHd;AAIb1D,EAAAA,kBAAkB,EAAEA,kBAJP;AAKbiB,EAAAA,cAAc,EAAEA,cALH;AAMbR,EAAAA,SAAS,EAAEA,SANE;AAOb4D,EAAAA,WAAW,EAAEA,WAPA;AAQbG,EAAAA,kBAAkB,EAAEA;AARP,CAAjB","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar polygonTester = require('../../lib/polygon').tester;\n\nvar findIndexOfMin = Lib.findIndexOfMin;\nvar isAngleInsideSector = Lib.isAngleInsideSector;\nvar angleDelta = Lib.angleDelta;\nvar angleDist = Lib.angleDist;\n\n/**\n * is pt (r,a) inside polygon made up vertices at angles 'vangles'\n * inside a given polar sector\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {boolean}\n */\nfunction isPtInsidePolygon(r, a, rBnds, aBnds, vangles) {\n    if(!isAngleInsideSector(a, aBnds)) return false;\n\n    var r0, r1;\n\n    if(rBnds[0] < rBnds[1]) {\n        r0 = rBnds[0];\n        r1 = rBnds[1];\n    } else {\n        r0 = rBnds[1];\n        r1 = rBnds[0];\n    }\n\n    var polygonIn = polygonTester(makePolygon(r0, aBnds[0], aBnds[1], vangles));\n    var polygonOut = polygonTester(makePolygon(r1, aBnds[0], aBnds[1], vangles));\n    var xy = [r * Math.cos(a), r * Math.sin(a)];\n    return polygonOut.contains(xy) && !polygonIn.contains(xy);\n}\n\n// find intersection of 'v0' <-> 'v1' edge with a ray at angle 'a'\n// (i.e. a line that starts from the origin at angle 'a')\n// given an (xp,yp) pair on the 'v0' <-> 'v1' line\n// (N.B. 'v0' and 'v1' are angles in radians)\nfunction findIntersectionXY(v0, v1, a, xpyp) {\n    var xstar, ystar;\n\n    var xp = xpyp[0];\n    var yp = xpyp[1];\n    var dsin = clampTiny(Math.sin(v1) - Math.sin(v0));\n    var dcos = clampTiny(Math.cos(v1) - Math.cos(v0));\n    var tanA = Math.tan(a);\n    var cotanA = clampTiny(1 / tanA);\n    var m = dsin / dcos;\n    var b = yp - m * xp;\n\n    if(cotanA) {\n        if(dsin && dcos) {\n            // given\n            //  g(x) := v0 -> v1 line = m*x + b\n            //  h(x) := ray at angle 'a' = m*x = tanA*x\n            // solve g(xstar) = h(xstar)\n            xstar = b / (tanA - m);\n            ystar = tanA * xstar;\n        } else if(dcos) {\n            // horizontal v0 -> v1\n            xstar = yp * cotanA;\n            ystar = yp;\n        } else {\n            // vertical v0 -> v1\n            xstar = xp;\n            ystar = xp * tanA;\n        }\n    } else {\n        // vertical ray\n        if(dsin && dcos) {\n            xstar = 0;\n            ystar = b;\n        } else if(dcos) {\n            xstar = 0;\n            ystar = yp;\n        } else {\n            // does this case exists?\n            xstar = ystar = NaN;\n        }\n    }\n\n    return [xstar, ystar];\n}\n\n// solves l^2 = (f(x)^2 - yp)^2 + (x - xp)^2\n// rearranged into 0 = a*x^2 + b * x + c\n//\n// where f(x) = m*x + t + yp\n// and   (x0, x1) = (-b +/- del) / (2*a)\nfunction findXYatLength(l, m, xp, yp) {\n    var t = -m * xp;\n    var a = m * m + 1;\n    var b = 2 * (m * t - xp);\n    var c = t * t + xp * xp - l * l;\n    var del = Math.sqrt(b * b - 4 * a * c);\n    var x0 = (-b + del) / (2 * a);\n    var x1 = (-b - del) / (2 * a);\n    return [\n        [x0, m * x0 + t + yp],\n        [x1, m * x1 + t + yp]\n    ];\n}\n\nfunction makeRegularPolygon(r, vangles) {\n    var len = vangles.length;\n    var vertices = new Array(len + 1);\n    var i;\n    for(i = 0; i < len; i++) {\n        var va = vangles[i];\n        vertices[i] = [r * Math.cos(va), r * Math.sin(va)];\n    }\n    vertices[i] = vertices[0].slice();\n    return vertices;\n}\n\nfunction makeClippedPolygon(r, a0, a1, vangles) {\n    var len = vangles.length;\n    var vertices = [];\n    var i, j;\n\n    function a2xy(a) {\n        return [r * Math.cos(a), r * Math.sin(a)];\n    }\n\n    function findXY(va0, va1, s) {\n        return findIntersectionXY(va0, va1, s, a2xy(va0));\n    }\n\n    function cycleIndex(ind) {\n        return Lib.mod(ind, len);\n    }\n\n    function isInside(v) {\n        return isAngleInsideSector(v, [a0, a1]);\n    }\n\n    // find index in sector closest to a0\n    // use it to find intersection of v[i0] <-> v[i0-1] edge with sector radius\n    var i0 = findIndexOfMin(vangles, function(v) {\n        return isInside(v) ? angleDist(v, a0) : Infinity;\n    });\n    var xy0 = findXY(vangles[i0], vangles[cycleIndex(i0 - 1)], a0);\n    vertices.push(xy0);\n\n    // fill in in-sector vertices\n    for(i = i0, j = 0; j < len; i++, j++) {\n        var va = vangles[cycleIndex(i)];\n        if(!isInside(va)) break;\n        vertices.push(a2xy(va));\n    }\n\n    // find index in sector closest to a1,\n    // use it to find intersection of v[iN] <-> v[iN+1] edge with sector radius\n    var iN = findIndexOfMin(vangles, function(v) {\n        return isInside(v) ? angleDist(v, a1) : Infinity;\n    });\n    var xyN = findXY(vangles[iN], vangles[cycleIndex(iN + 1)], a1);\n    vertices.push(xyN);\n\n    vertices.push([0, 0]);\n    vertices.push(vertices[0].slice());\n\n    return vertices;\n}\n\nfunction makePolygon(r, a0, a1, vangles) {\n    return Lib.isFullCircle([a0, a1]) ?\n        makeRegularPolygon(r, vangles) :\n        makeClippedPolygon(r, a0, a1, vangles);\n}\n\nfunction findPolygonOffset(r, a0, a1, vangles) {\n    var minX = Infinity;\n    var minY = Infinity;\n    var vertices = makePolygon(r, a0, a1, vangles);\n\n    for(var i = 0; i < vertices.length; i++) {\n        var v = vertices[i];\n        minX = Math.min(minX, v[0]);\n        minY = Math.min(minY, -v[1]);\n    }\n    return [minX, minY];\n}\n\n/**\n * find vertex angles (in 'vangles') the enclose angle 'a'\n *\n * @param {number} a : angle in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {2-item array}\n */\nfunction findEnclosingVertexAngles(a, vangles) {\n    var minFn = function(v) {\n        var adelta = angleDelta(v, a);\n        return adelta > 0 ? adelta : Infinity;\n    };\n    var i0 = findIndexOfMin(vangles, minFn);\n    var i1 = Lib.mod(i0 + 1, vangles.length);\n    return [vangles[i0], vangles[i1]];\n}\n\n// to more easily catch 'almost zero' numbers in if-else blocks\nfunction clampTiny(v) {\n    return Math.abs(v) > 1e-10 ? v : 0;\n}\n\nfunction transformForSVG(pts0, cx, cy) {\n    cx = cx || 0;\n    cy = cy || 0;\n\n    var len = pts0.length;\n    var pts1 = new Array(len);\n\n    for(var i = 0; i < len; i++) {\n        var pt = pts0[i];\n        pts1[i] = [cx + pt[0], cy - pt[1]];\n    }\n    return pts1;\n}\n\n/**\n * path polygon\n *\n * @param {number} r : polygon 'radius'\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\nfunction pathPolygon(r, a0, a1, vangles, cx, cy) {\n    var poly = makePolygon(r, a0, a1, vangles);\n    return 'M' + transformForSVG(poly, cx, cy).join('L');\n}\n\n/**\n * path a polygon 'annulus'\n * i.e. a polygon with a concentric hole\n *\n * N.B. this routine uses the evenodd SVG rule\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\nfunction pathPolygonAnnulus(r0, r1, a0, a1, vangles, cx, cy) {\n    var rStart, rEnd;\n\n    if(r0 < r1) {\n        rStart = r0;\n        rEnd = r1;\n    } else {\n        rStart = r1;\n        rEnd = r0;\n    }\n\n    var inner = transformForSVG(makePolygon(rStart, a0, a1, vangles), cx, cy);\n    var outer = transformForSVG(makePolygon(rEnd, a0, a1, vangles), cx, cy);\n    return 'M' + outer.reverse().join('L') + 'M' + inner.join('L');\n}\n\nmodule.exports = {\n    isPtInsidePolygon: isPtInsidePolygon,\n    findPolygonOffset: findPolygonOffset,\n    findEnclosingVertexAngles: findEnclosingVertexAngles,\n    findIntersectionXY: findIntersectionXY,\n    findXYatLength: findXYatLength,\n    clampTiny: clampTiny,\n    pathPolygon: pathPolygon,\n    pathPolygonAnnulus: pathPolygonAnnulus\n};\n"]},"metadata":{},"sourceType":"script"}