{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Registry = require('../../registry');\n\nvar tickText = require('../../plots/cartesian/axes').tickText;\n\nvar uniformText = require('./uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar style = require('./style');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants');\n\nvar attributes = require('./attributes');\n\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar TEXTPAD = constants.TEXTPAD;\n\nfunction keyFunc(d) {\n  return d.id;\n}\n\nfunction getKeyFunc(trace) {\n  if (trace.ids) {\n    return keyFunc;\n  }\n}\n\nfunction dirSign(a, b) {\n  return a < b ? 1 : -1;\n}\n\nfunction getXY(di, xa, ya, isHorizontal) {\n  var s = [];\n  var p = [];\n  var sAxis = isHorizontal ? xa : ya;\n  var pAxis = isHorizontal ? ya : xa;\n  s[0] = sAxis.c2p(di.s0, true);\n  p[0] = pAxis.c2p(di.p0, true);\n  s[1] = sAxis.c2p(di.s1, true);\n  p[1] = pAxis.c2p(di.p1, true);\n  return isHorizontal ? [s, p] : [p, s];\n}\n\nfunction transition(selection, fullLayout, opts, makeOnCompleteCallback) {\n  if (!fullLayout.uniformtext.mode && hasTransition(opts)) {\n    var onComplete;\n\n    if (makeOnCompleteCallback) {\n      onComplete = makeOnCompleteCallback();\n    }\n\n    return selection.transition().duration(opts.duration).ease(opts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n  } else {\n    return selection;\n  }\n}\n\nfunction hasTransition(transitionOpts) {\n  return transitionOpts && transitionOpts.duration > 0;\n}\n\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n\n  if (!opts) {\n    opts = {\n      mode: fullLayout.barmode,\n      norm: fullLayout.barmode,\n      gap: fullLayout.bargap,\n      groupgap: fullLayout.bargroupgap\n    }; // don't clear bar when this is called from waterfall or funnel\n\n    clearMinTextSize('bar', fullLayout);\n  }\n\n  var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var trace = cd[0].trace;\n    var isWaterfall = trace.type === 'waterfall';\n    var isFunnel = trace.type === 'funnel';\n    var isBar = trace.type === 'bar';\n    var shouldDisplayZeros = isBar || isFunnel;\n    var adjustPixel = 0;\n\n    if (isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n      adjustPixel = trace.connector.line.width / 2;\n    }\n\n    var isHorizontal = trace.orientation === 'h';\n    var withTransition = hasTransition(opts);\n    var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n    var keyFunc = getKeyFunc(trace);\n    var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n    bars.enter().append('g').classed('point', true);\n    bars.exit().remove();\n    bars.each(function (di, i) {\n      var bar = d3.select(this); // now display the bar\n      // clipped xf/yf (2nd arg true): non-positive\n      // log values go off-screen by plotwidth\n      // so you see them continue if you drag the plot\n\n      var xy = getXY(di, xa, ya, isHorizontal);\n      var x0 = xy[0][0];\n      var x1 = xy[0][1];\n      var y0 = xy[1][0];\n      var y1 = xy[1][1]; // empty bars\n\n      var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0; // display zeros if line.width > 0\n\n      if (isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {\n        isBlank = false;\n      } // skip nulls\n\n\n      if (!isBlank) {\n        isBlank = !isNumeric(x0) || !isNumeric(x1) || !isNumeric(y0) || !isNumeric(y1);\n      } // record isBlank\n\n\n      di.isBlank = isBlank; // for blank bars, ensure start and end positions are equal - important for smooth transitions\n\n      if (isBlank) {\n        if (isHorizontal) {\n          x1 = x0;\n        } else {\n          y1 = y0;\n        }\n      } // in waterfall mode `between` we need to adjust bar end points to match the connector width\n\n\n      if (adjustPixel && !isBlank) {\n        if (isHorizontal) {\n          x0 -= dirSign(x0, x1) * adjustPixel;\n          x1 += dirSign(x0, x1) * adjustPixel;\n        } else {\n          y0 -= dirSign(y0, y1) * adjustPixel;\n          y1 += dirSign(y0, y1) * adjustPixel;\n        }\n      }\n\n      var lw;\n      var mc;\n\n      if (trace.type === 'waterfall') {\n        if (!isBlank) {\n          var cont = trace[di.dir].marker;\n          lw = cont.line.width;\n          mc = cont.color;\n        }\n      } else {\n        lw = helpers.getLineWidth(trace, di);\n        mc = di.mc || trace.marker.color;\n      }\n\n      function roundWithLine(v) {\n        var offset = d3.round(lw / 2 % 1, 2); // if there are explicit gaps, don't round,\n        // it can make the gaps look crappy\n\n        return opts.gap === 0 && opts.groupgap === 0 ? d3.round(Math.round(v) - offset, 2) : v;\n      }\n\n      function expandToVisible(v, vc, hideZeroSpan) {\n        if (hideZeroSpan && v === vc) {\n          // should not expand zero span bars\n          // when start and end positions are identical\n          // i.e. for vertical when y0 === y1\n          // and for horizontal when x0 === x1\n          return v;\n        } // if it's not in danger of disappearing entirely,\n        // round more precisely\n\n\n        return Math.abs(v - vc) >= 2 ? roundWithLine(v) : // but if it's very thin, expand it so it's\n        // necessarily visible, even if it might overlap\n        // its neighbor\n        v > vc ? Math.ceil(v) : Math.floor(v);\n      }\n\n      if (!gd._context.staticPlot) {\n        // if bars are not fully opaque or they have a line\n        // around them, round to integer pixels, mainly for\n        // safari so we prevent overlaps from its expansive\n        // pixelation. if the bars ARE fully opaque and have\n        // no line, expand to a full pixel to make sure we\n        // can see them\n        var op = Color.opacity(mc);\n        var fixpx = op < 1 || lw > 0.01 ? roundWithLine : expandToVisible;\n        x0 = fixpx(x0, x1, isHorizontal);\n        x1 = fixpx(x1, x0, isHorizontal);\n        y0 = fixpx(y0, y1, !isHorizontal);\n        y1 = fixpx(y1, y0, !isHorizontal);\n      }\n\n      var sel = transition(Lib.ensureSingle(bar, 'path'), fullLayout, opts, makeOnCompleteCallback);\n      sel.style('vector-effect', 'non-scaling-stroke').attr('d', isNaN((x1 - x0) * (y1 - y0)) ? 'M0,0Z' : 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z').call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n\n      if (!fullLayout.uniformtext.mode && withTransition) {\n        var styleFns = Drawing.makePointStyleFns(trace);\n        Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n      }\n\n      appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback);\n\n      if (plotinfo.layerClipId) {\n        Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n      }\n    }); // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n  }); // error bars are on the top\n\n  Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\n\nfunction appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var textPosition;\n\n  function appendTextNode(bar, text, font) {\n    var textSelection = Lib.ensureSingle(bar, 'text').text(text).attr({\n      'class': 'bartext bartext-' + textPosition,\n      'text-anchor': 'middle',\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      'data-notex': 1\n    }).call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n    return textSelection;\n  } // get trace attributes\n\n\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var text = getText(fullLayout, cd, i, xa, ya);\n  textPosition = getTextPosition(trace, i); // compute text position\n\n  var inStackOrRelativeMode = opts.mode === 'stack' || opts.mode === 'relative';\n  var calcBar = cd[i];\n  var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n\n  if (!text || textPosition === 'none' || (calcBar.isBlank || x0 === x1 || y0 === y1) && (textPosition === 'auto' || textPosition === 'inside')) {\n    bar.select('text').remove();\n    return;\n  }\n\n  var layoutFont = fullLayout.font;\n  var barColor = style.getBarColor(cd[i], trace);\n  var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n  var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont); // Special case: don't use the c2p(v, true) value on log size axes,\n  // so that we can get correctly inside text scaling\n\n  var di = bar.datum();\n\n  if (isHorizontal) {\n    if (xa.type === 'log' && di.s0 <= 0) {\n      if (xa.range[0] < xa.range[1]) {\n        x0 = 0;\n      } else {\n        x0 = xa._length;\n      }\n    }\n  } else {\n    if (ya.type === 'log' && di.s0 <= 0) {\n      if (ya.range[0] < ya.range[1]) {\n        y0 = ya._length;\n      } else {\n        y0 = 0;\n      }\n    }\n  } // padding excluded\n\n\n  var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD;\n  var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD;\n  var textSelection;\n  var textBB;\n  var textWidth;\n  var textHeight;\n  var font;\n\n  if (textPosition === 'outside') {\n    if (!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n  }\n\n  if (textPosition === 'auto') {\n    if (isOutmostBar) {\n      // draw text using insideTextFont and check if it fits inside bar\n      textPosition = 'inside';\n      font = Lib.ensureUniformFontSize(gd, insideTextFont);\n      textSelection = appendTextNode(bar, text, font);\n      textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n      var textHasSize = textWidth > 0 && textHeight > 0;\n      var fitsInside = textWidth <= barWidth && textHeight <= barHeight;\n      var fitsInsideIfRotated = textWidth <= barHeight && textHeight <= barWidth;\n      var fitsInsideIfShrunk = isHorizontal ? barWidth >= textWidth * (barHeight / textHeight) : barHeight >= textHeight * (barWidth / textWidth);\n\n      if (textHasSize && (fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk)) {\n        textPosition = 'inside';\n      } else {\n        textPosition = 'outside';\n        textSelection.remove();\n        textSelection = null;\n      }\n    } else {\n      textPosition = 'inside';\n    }\n  }\n\n  if (!textSelection) {\n    font = Lib.ensureUniformFontSize(gd, textPosition === 'outside' ? outsideTextFont : insideTextFont);\n    textSelection = appendTextNode(bar, text, font);\n    var currentTransform = textSelection.attr('transform');\n    textSelection.attr('transform', '');\n    textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n    textSelection.attr('transform', currentTransform);\n\n    if (textWidth <= 0 || textHeight <= 0) {\n      textSelection.remove();\n      return;\n    }\n  }\n\n  var angle = trace.textangle; // compute text transform\n\n  var transform, constrained;\n\n  if (textPosition === 'outside') {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n    transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle\n    });\n  } else {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n    transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle,\n      anchor: trace.insidetextanchor\n    });\n  }\n\n  transform.fontSize = font.size;\n  recordMinTextSize(trace.type, transform, fullLayout);\n  calcBar.transform = transform;\n  transition(textSelection, fullLayout, opts, makeOnCompleteCallback).attr('transform', Lib.getTextTransform(transform));\n}\n\nfunction getRotateFromAngle(angle) {\n  return angle === 'auto' ? 0 : angle;\n}\n\nfunction getRotatedTextSize(textBB, rotate) {\n  var a = Math.PI / 180 * rotate;\n  var absSin = Math.abs(Math.sin(a));\n  var absCos = Math.abs(Math.cos(a));\n  return {\n    x: textBB.width * absCos + textBB.height * absSin,\n    y: textBB.width * absSin + textBB.height * absCos\n  };\n}\n\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var anchor = opts.anchor || 'end';\n  var isEnd = anchor === 'end';\n  var isStart = anchor === 'start';\n  var leftToRight = opts.leftToRight || 0; // left: -1, center: 0, right: 1\n\n  var toRight = (leftToRight + 1) / 2;\n  var toLeft = 1 - toRight;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0); // compute remaining space\n\n  var textpad = lx > 2 * TEXTPAD && ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  lx -= 2 * textpad;\n  ly -= 2 * textpad;\n  var rotate = getRotateFromAngle(angle);\n\n  if (angle === 'auto' && !(textWidth <= lx && textHeight <= ly) && (textWidth > lx || textHeight > ly) && (!(textWidth > ly || textHeight > lx) || textWidth < textHeight !== lx < ly)) {\n    rotate += 90;\n  }\n\n  var t = getRotatedTextSize(textBB, rotate);\n  var scale = 1;\n\n  if (constrained) {\n    scale = Math.min(1, lx / t.x, ly / t.y);\n  } // compute text and target positions\n\n\n  var textX = textBB.left * toLeft + textBB.right * toRight;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + TEXTPAD) * toLeft + (x1 - TEXTPAD) * toRight;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n\n  if (isStart || isEnd) {\n    var extrapad = (isHorizontal ? t.x : t.y) / 2;\n    var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);\n\n    if (isHorizontal) {\n      if (isStart) {\n        targetX = x0 + dir * textpad;\n        anchorX = -dir * extrapad;\n      } else {\n        targetX = x1 - dir * textpad;\n        anchorX = dir * extrapad;\n      }\n    } else {\n      if (isStart) {\n        targetY = y0 + dir * textpad;\n        anchorY = -dir * extrapad;\n      } else {\n        targetY = y1 - dir * textpad;\n        anchorY = dir * extrapad;\n      }\n    }\n  }\n\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\n\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n  var textpad; // Keep the padding so the text doesn't sit right against\n  // the bars, but don't factor it into barWidth\n\n  if (isHorizontal) {\n    textpad = ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  } else {\n    textpad = lx > 2 * TEXTPAD ? TEXTPAD : 0;\n  } // compute rotate and scale\n\n\n  var scale = 1;\n\n  if (constrained) {\n    scale = isHorizontal ? Math.min(1, ly / textHeight) : Math.min(1, lx / textWidth);\n  }\n\n  var rotate = getRotateFromAngle(angle);\n  var t = getRotatedTextSize(textBB, rotate); // compute text and target positions\n\n  var extrapad = (isHorizontal ? t.x : t.y) / 2;\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + x1) / 2;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n  var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);\n\n  if (isHorizontal) {\n    targetX = x1 - dir * textpad;\n    anchorX = dir * extrapad;\n  } else {\n    targetY = y1 + dir * textpad;\n    anchorY = -dir * extrapad;\n  }\n\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\n\nfunction getText(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = trace.texttemplate;\n  var value;\n\n  if (texttemplate) {\n    value = calcTexttemplate(fullLayout, cd, index, xa, ya);\n  } else if (trace.textinfo) {\n    value = calcTextinfo(cd, index, xa, ya);\n  } else {\n    value = helpers.getValue(trace.text, index);\n  }\n\n  return helpers.coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n  var value = helpers.getValue(trace.textposition, index);\n  return helpers.coerceEnumerated(attributeTextPosition, value);\n}\n\nfunction calcTexttemplate(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n  if (!texttemplate) return '';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n  var pLetter, pAxis;\n  var vLetter, vAxis;\n\n  if (trace.orientation === 'h') {\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  }\n\n  function formatLabel(u) {\n    return tickText(pAxis, u, true).text;\n  }\n\n  function formatNumber(v) {\n    return tickText(vAxis, +v, true).text;\n  }\n\n  var cdi = cd[index];\n  var obj = {};\n  obj.label = cdi.p;\n  obj.labelLabel = obj[pLetter + 'Label'] = formatLabel(cdi.p);\n  var tx = Lib.castOption(trace, cdi.i, 'text');\n  if (tx === 0 || tx) obj.text = tx;\n  obj.value = cdi.s;\n  obj.valueLabel = obj[vLetter + 'Label'] = formatNumber(cdi.s);\n  var pt = {};\n  appendArrayPointValue(pt, trace, cdi.i);\n\n  if (isWaterfall) {\n    obj.delta = +cdi.rawS || cdi.s;\n    obj.deltaLabel = formatNumber(obj.delta);\n    obj.final = cdi.v;\n    obj.finalLabel = formatNumber(obj.final);\n    obj.initial = obj.final - obj.delta;\n    obj.initialLabel = formatNumber(obj.initial);\n  }\n\n  if (isFunnel) {\n    obj.value = cdi.s;\n    obj.valueLabel = formatNumber(obj.value);\n    obj.percentInitial = cdi.begR;\n    obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n    obj.percentPrevious = cdi.difR;\n    obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n    obj.percentTotal = cdi.sumR;\n    obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n  }\n\n  var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  if (customdata) obj.customdata = customdata;\n  return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\n\nfunction calcTextinfo(cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n\n  function formatLabel(u) {\n    var pAxis = isHorizontal ? ya : xa;\n    return tickText(pAxis, u, true).text;\n  }\n\n  function formatNumber(v) {\n    var sAxis = isHorizontal ? xa : ya;\n    return tickText(sAxis, +v, true).text;\n  }\n\n  var textinfo = trace.textinfo;\n  var cdi = cd[index];\n  var parts = textinfo.split('+');\n  var text = [];\n  var tx;\n\n  var hasFlag = function (flag) {\n    return parts.indexOf(flag) !== -1;\n  };\n\n  if (hasFlag('label')) {\n    text.push(formatLabel(cd[index].p));\n  }\n\n  if (hasFlag('text')) {\n    tx = Lib.castOption(trace, cdi.i, 'text');\n    if (tx === 0 || tx) text.push(tx);\n  }\n\n  if (isWaterfall) {\n    var delta = +cdi.rawS || cdi.s;\n    var final = cdi.v;\n    var initial = final - delta;\n    if (hasFlag('initial')) text.push(formatNumber(initial));\n    if (hasFlag('delta')) text.push(formatNumber(delta));\n    if (hasFlag('final')) text.push(formatNumber(final));\n  }\n\n  if (isFunnel) {\n    if (hasFlag('value')) text.push(formatNumber(cdi.s));\n    var nPercent = 0;\n    if (hasFlag('percent initial')) nPercent++;\n    if (hasFlag('percent previous')) nPercent++;\n    if (hasFlag('percent total')) nPercent++;\n    var hasMultiplePercents = nPercent > 1;\n\n    if (hasFlag('percent initial')) {\n      tx = Lib.formatPercent(cdi.begR);\n      if (hasMultiplePercents) tx += ' of initial';\n      text.push(tx);\n    }\n\n    if (hasFlag('percent previous')) {\n      tx = Lib.formatPercent(cdi.difR);\n      if (hasMultiplePercents) tx += ' of previous';\n      text.push(tx);\n    }\n\n    if (hasFlag('percent total')) {\n      tx = Lib.formatPercent(cdi.sumR);\n      if (hasMultiplePercents) tx += ' of total';\n      text.push(tx);\n    }\n  }\n\n  return text.join('<br>');\n}\n\nmodule.exports = {\n  plot: plot,\n  toMoveInsideBar: toMoveInsideBar\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/bar/plot.js"],"names":["d3","require","isNumeric","Lib","svgTextUtils","Color","Drawing","Registry","tickText","uniformText","recordMinTextSize","clearMinTextSize","style","helpers","constants","attributes","attributeText","text","attributeTextPosition","textposition","appendArrayPointValue","TEXTPAD","keyFunc","d","id","getKeyFunc","trace","ids","dirSign","a","b","getXY","di","xa","ya","isHorizontal","s","p","sAxis","pAxis","c2p","s0","p0","s1","p1","transition","selection","fullLayout","opts","makeOnCompleteCallback","uniformtext","mode","hasTransition","onComplete","duration","ease","easing","each","transitionOpts","plot","gd","plotinfo","cdModule","traceLayer","xaxis","yaxis","_fullLayout","barmode","norm","gap","bargap","groupgap","bargroupgap","bartraces","makeTraceGroups","cd","plotGroup","select","isWaterfall","type","isFunnel","isBar","shouldDisplayZeros","adjustPixel","connector","visible","line","width","orientation","withTransition","pointGroup","ensureSingle","bars","selectAll","data","identity","enter","append","classed","exit","remove","i","bar","xy","x0","x1","y0","y1","isBlank","getLineWidth","lw","mc","cont","dir","marker","color","roundWithLine","v","offset","round","Math","expandToVisible","vc","hideZeroSpan","abs","ceil","floor","_context","staticPlot","op","opacity","fixpx","sel","attr","isNaN","call","setClipUrl","layerClipId","styleFns","makePointStyleFns","singlePointStyle","appendBarText","hideOutsideRangePoint","xcalendar","ycalendar","hasClipOnAxisFalse","cliponaxis","getComponentMethod","textPosition","appendTextNode","font","textSelection","convertToTspans","getText","getTextPosition","inStackOrRelativeMode","calcBar","isOutmostBar","_outmost","layoutFont","barColor","getBarColor","insideTextFont","getInsideTextFont","outsideTextFont","getOutsideTextFont","datum","range","_length","barWidth","barHeight","textBB","textWidth","textHeight","hasB","ensureUniformFontSize","bBox","node","height","textHasSize","fitsInside","fitsInsideIfRotated","fitsInsideIfShrunk","currentTransform","angle","textangle","transform","constrained","constraintext","toMoveOutsideBar","toMoveInsideBar","anchor","insidetextanchor","fontSize","size","getTextTransform","getRotateFromAngle","getRotatedTextSize","rotate","PI","absSin","sin","absCos","cos","x","y","isEnd","isStart","leftToRight","toRight","toLeft","lx","ly","textpad","t","scale","min","textX","left","right","textY","top","bottom","targetX","targetY","anchorX","anchorY","extrapad","index","texttemplate","value","calcTexttemplate","textinfo","calcTextinfo","getValue","coerceString","coerceEnumerated","castOption","pLetter","vLetter","vAxis","formatLabel","u","formatNumber","cdi","obj","label","labelLabel","tx","valueLabel","pt","delta","rawS","deltaLabel","final","finalLabel","initial","initialLabel","percentInitial","begR","percentInitialLabel","formatPercent","percentPrevious","difR","percentPreviousLabel","percentTotal","sumR","percenTotalLabel","customdata","texttemplateString","_d3locale","_meta","parts","split","hasFlag","flag","indexOf","push","nPercent","hasMultiplePercents","join","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\nvar tickText = require('../../plots/cartesian/axes').tickText;\n\nvar uniformText = require('./uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar style = require('./style');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar attributes = require('./attributes');\n\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar TEXTPAD = constants.TEXTPAD;\n\nfunction keyFunc(d) {return d.id;}\nfunction getKeyFunc(trace) {\n    if(trace.ids) {\n        return keyFunc;\n    }\n}\n\nfunction dirSign(a, b) {\n    return (a < b) ? 1 : -1;\n}\n\nfunction getXY(di, xa, ya, isHorizontal) {\n    var s = [];\n    var p = [];\n\n    var sAxis = isHorizontal ? xa : ya;\n    var pAxis = isHorizontal ? ya : xa;\n\n    s[0] = sAxis.c2p(di.s0, true);\n    p[0] = pAxis.c2p(di.p0, true);\n\n    s[1] = sAxis.c2p(di.s1, true);\n    p[1] = pAxis.c2p(di.p1, true);\n\n    return isHorizontal ? [s, p] : [p, s];\n}\n\nfunction transition(selection, fullLayout, opts, makeOnCompleteCallback) {\n    if(!fullLayout.uniformtext.mode && hasTransition(opts)) {\n        var onComplete;\n        if(makeOnCompleteCallback) {\n            onComplete = makeOnCompleteCallback();\n        }\n        return selection\n          .transition()\n          .duration(opts.duration)\n          .ease(opts.easing)\n          .each('end', function() { onComplete && onComplete(); })\n          .each('interrupt', function() { onComplete && onComplete(); });\n    } else {\n        return selection;\n    }\n}\n\nfunction hasTransition(transitionOpts) {\n    return transitionOpts && transitionOpts.duration > 0;\n}\n\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var fullLayout = gd._fullLayout;\n\n    if(!opts) {\n        opts = {\n            mode: fullLayout.barmode,\n            norm: fullLayout.barmode,\n            gap: fullLayout.bargap,\n            groupgap: fullLayout.bargroupgap\n        };\n\n        // don't clear bar when this is called from waterfall or funnel\n        clearMinTextSize('bar', fullLayout);\n    }\n\n    var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var trace = cd[0].trace;\n        var isWaterfall = (trace.type === 'waterfall');\n        var isFunnel = (trace.type === 'funnel');\n        var isBar = (trace.type === 'bar');\n        var shouldDisplayZeros = (isBar || isFunnel);\n\n        var adjustPixel = 0;\n        if(isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n            adjustPixel = trace.connector.line.width / 2;\n        }\n\n        var isHorizontal = (trace.orientation === 'h');\n        var withTransition = hasTransition(opts);\n\n        var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n\n        var keyFunc = getKeyFunc(trace);\n        var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n\n        bars.enter().append('g')\n            .classed('point', true);\n\n        bars.exit().remove();\n\n        bars.each(function(di, i) {\n            var bar = d3.select(this);\n\n            // now display the bar\n            // clipped xf/yf (2nd arg true): non-positive\n            // log values go off-screen by plotwidth\n            // so you see them continue if you drag the plot\n            var xy = getXY(di, xa, ya, isHorizontal);\n\n            var x0 = xy[0][0];\n            var x1 = xy[0][1];\n            var y0 = xy[1][0];\n            var y1 = xy[1][1];\n\n            // empty bars\n            var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0;\n\n            // display zeros if line.width > 0\n            if(isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {\n                isBlank = false;\n            }\n\n            // skip nulls\n            if(!isBlank) {\n                isBlank = (\n                    !isNumeric(x0) ||\n                    !isNumeric(x1) ||\n                    !isNumeric(y0) ||\n                    !isNumeric(y1)\n                );\n            }\n\n            // record isBlank\n            di.isBlank = isBlank;\n\n            // for blank bars, ensure start and end positions are equal - important for smooth transitions\n            if(isBlank) {\n                if(isHorizontal) {\n                    x1 = x0;\n                } else {\n                    y1 = y0;\n                }\n            }\n\n            // in waterfall mode `between` we need to adjust bar end points to match the connector width\n            if(adjustPixel && !isBlank) {\n                if(isHorizontal) {\n                    x0 -= dirSign(x0, x1) * adjustPixel;\n                    x1 += dirSign(x0, x1) * adjustPixel;\n                } else {\n                    y0 -= dirSign(y0, y1) * adjustPixel;\n                    y1 += dirSign(y0, y1) * adjustPixel;\n                }\n            }\n\n            var lw;\n            var mc;\n\n            if(trace.type === 'waterfall') {\n                if(!isBlank) {\n                    var cont = trace[di.dir].marker;\n                    lw = cont.line.width;\n                    mc = cont.color;\n                }\n            } else {\n                lw = helpers.getLineWidth(trace, di);\n                mc = di.mc || trace.marker.color;\n            }\n\n            function roundWithLine(v) {\n                var offset = d3.round((lw / 2) % 1, 2);\n\n                // if there are explicit gaps, don't round,\n                // it can make the gaps look crappy\n                return (opts.gap === 0 && opts.groupgap === 0) ?\n                    d3.round(Math.round(v) - offset, 2) : v;\n            }\n\n            function expandToVisible(v, vc, hideZeroSpan) {\n                if(hideZeroSpan && v === vc) {\n                    // should not expand zero span bars\n                    // when start and end positions are identical\n                    // i.e. for vertical when y0 === y1\n                    // and for horizontal when x0 === x1\n                    return v;\n                }\n\n                // if it's not in danger of disappearing entirely,\n                // round more precisely\n                return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n                // but if it's very thin, expand it so it's\n                // necessarily visible, even if it might overlap\n                // its neighbor\n                (v > vc ? Math.ceil(v) : Math.floor(v));\n            }\n\n            if(!gd._context.staticPlot) {\n                // if bars are not fully opaque or they have a line\n                // around them, round to integer pixels, mainly for\n                // safari so we prevent overlaps from its expansive\n                // pixelation. if the bars ARE fully opaque and have\n                // no line, expand to a full pixel to make sure we\n                // can see them\n\n                var op = Color.opacity(mc);\n                var fixpx = (op < 1 || lw > 0.01) ? roundWithLine : expandToVisible;\n\n                x0 = fixpx(x0, x1, isHorizontal);\n                x1 = fixpx(x1, x0, isHorizontal);\n                y0 = fixpx(y0, y1, !isHorizontal);\n                y1 = fixpx(y1, y0, !isHorizontal);\n            }\n\n            var sel = transition(Lib.ensureSingle(bar, 'path'), fullLayout, opts, makeOnCompleteCallback);\n            sel\n                .style('vector-effect', 'non-scaling-stroke')\n                .attr('d', isNaN((x1 - x0) * (y1 - y0)) ? 'M0,0Z' : 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z')\n                .call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n\n            if(!fullLayout.uniformtext.mode && withTransition) {\n                var styleFns = Drawing.makePointStyleFns(trace);\n                Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n            }\n\n            appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback);\n\n            if(plotinfo.layerClipId) {\n                Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n            }\n        });\n\n        // lastly, clip points groups of `cliponaxis !== false` traces\n        // on `plotinfo._hasClipOnAxisFalse === true` subplots\n        var hasClipOnAxisFalse = trace.cliponaxis === false;\n        Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n    });\n\n    // error bars are on the top\n    Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\n\nfunction appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var textPosition;\n\n    function appendTextNode(bar, text, font) {\n        var textSelection = Lib.ensureSingle(bar, 'text')\n            .text(text)\n            .attr({\n                'class': 'bartext bartext-' + textPosition,\n                'text-anchor': 'middle',\n                // prohibit tex interpretation until we can handle\n                // tex and regular text together\n                'data-notex': 1\n            })\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        return textSelection;\n    }\n\n    // get trace attributes\n    var trace = cd[0].trace;\n    var isHorizontal = (trace.orientation === 'h');\n\n    var text = getText(fullLayout, cd, i, xa, ya);\n    textPosition = getTextPosition(trace, i);\n\n    // compute text position\n    var inStackOrRelativeMode =\n        opts.mode === 'stack' ||\n        opts.mode === 'relative';\n\n    var calcBar = cd[i];\n    var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n\n    if(!text ||\n        textPosition === 'none' ||\n        ((calcBar.isBlank || x0 === x1 || y0 === y1) && (\n            textPosition === 'auto' ||\n            textPosition === 'inside'))) {\n        bar.select('text').remove();\n        return;\n    }\n\n    var layoutFont = fullLayout.font;\n    var barColor = style.getBarColor(cd[i], trace);\n    var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n    var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);\n\n    // Special case: don't use the c2p(v, true) value on log size axes,\n    // so that we can get correctly inside text scaling\n    var di = bar.datum();\n    if(isHorizontal) {\n        if(xa.type === 'log' && di.s0 <= 0) {\n            if(xa.range[0] < xa.range[1]) {\n                x0 = 0;\n            } else {\n                x0 = xa._length;\n            }\n        }\n    } else {\n        if(ya.type === 'log' && di.s0 <= 0) {\n            if(ya.range[0] < ya.range[1]) {\n                y0 = ya._length;\n            } else {\n                y0 = 0;\n            }\n        }\n    }\n\n    // padding excluded\n    var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD;\n    var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD;\n\n    var textSelection;\n    var textBB;\n    var textWidth;\n    var textHeight;\n    var font;\n\n    if(textPosition === 'outside') {\n        if(!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n    }\n\n    if(textPosition === 'auto') {\n        if(isOutmostBar) {\n            // draw text using insideTextFont and check if it fits inside bar\n            textPosition = 'inside';\n\n            font = Lib.ensureUniformFontSize(gd, insideTextFont);\n\n            textSelection = appendTextNode(bar, text, font);\n\n            textBB = Drawing.bBox(textSelection.node()),\n            textWidth = textBB.width,\n            textHeight = textBB.height;\n\n            var textHasSize = (textWidth > 0 && textHeight > 0);\n            var fitsInside = (textWidth <= barWidth && textHeight <= barHeight);\n            var fitsInsideIfRotated = (textWidth <= barHeight && textHeight <= barWidth);\n            var fitsInsideIfShrunk = (isHorizontal) ?\n                (barWidth >= textWidth * (barHeight / textHeight)) :\n                (barHeight >= textHeight * (barWidth / textWidth));\n\n            if(textHasSize && (\n                fitsInside ||\n                fitsInsideIfRotated ||\n                fitsInsideIfShrunk)\n            ) {\n                textPosition = 'inside';\n            } else {\n                textPosition = 'outside';\n                textSelection.remove();\n                textSelection = null;\n            }\n        } else {\n            textPosition = 'inside';\n        }\n    }\n\n    if(!textSelection) {\n        font = Lib.ensureUniformFontSize(gd, (textPosition === 'outside') ? outsideTextFont : insideTextFont);\n\n        textSelection = appendTextNode(bar, text, font);\n\n        var currentTransform = textSelection.attr('transform');\n        textSelection.attr('transform', '');\n        textBB = Drawing.bBox(textSelection.node()),\n        textWidth = textBB.width,\n        textHeight = textBB.height;\n        textSelection.attr('transform', currentTransform);\n\n        if(textWidth <= 0 || textHeight <= 0) {\n            textSelection.remove();\n            return;\n        }\n    }\n\n    var angle = trace.textangle;\n\n    // compute text transform\n    var transform, constrained;\n    if(textPosition === 'outside') {\n        constrained =\n            trace.constraintext === 'both' ||\n            trace.constraintext === 'outside';\n\n        transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: isHorizontal,\n            constrained: constrained,\n            angle: angle\n        });\n    } else {\n        constrained =\n            trace.constraintext === 'both' ||\n            trace.constraintext === 'inside';\n\n        transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: isHorizontal,\n            constrained: constrained,\n            angle: angle,\n            anchor: trace.insidetextanchor\n        });\n    }\n\n    transform.fontSize = font.size;\n    recordMinTextSize(trace.type, transform, fullLayout);\n    calcBar.transform = transform;\n\n    transition(textSelection, fullLayout, opts, makeOnCompleteCallback)\n        .attr('transform', Lib.getTextTransform(transform));\n}\n\nfunction getRotateFromAngle(angle) {\n    return (angle === 'auto') ? 0 : angle;\n}\n\nfunction getRotatedTextSize(textBB, rotate) {\n    var a = Math.PI / 180 * rotate;\n    var absSin = Math.abs(Math.sin(a));\n    var absCos = Math.abs(Math.cos(a));\n\n    return {\n        x: textBB.width * absCos + textBB.height * absSin,\n        y: textBB.width * absSin + textBB.height * absCos\n    };\n}\n\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n    var isHorizontal = !!opts.isHorizontal;\n    var constrained = !!opts.constrained;\n    var angle = opts.angle || 0;\n    var anchor = opts.anchor || 'end';\n    var isEnd = anchor === 'end';\n    var isStart = anchor === 'start';\n    var leftToRight = opts.leftToRight || 0; // left: -1, center: 0, right: 1\n    var toRight = (leftToRight + 1) / 2;\n    var toLeft = 1 - toRight;\n\n    var textWidth = textBB.width;\n    var textHeight = textBB.height;\n    var lx = Math.abs(x1 - x0);\n    var ly = Math.abs(y1 - y0);\n\n    // compute remaining space\n    var textpad = (\n        lx > (2 * TEXTPAD) &&\n        ly > (2 * TEXTPAD)\n    ) ? TEXTPAD : 0;\n\n    lx -= 2 * textpad;\n    ly -= 2 * textpad;\n\n    var rotate = getRotateFromAngle(angle);\n    if((angle === 'auto') &&\n        !(textWidth <= lx && textHeight <= ly) &&\n        (textWidth > lx || textHeight > ly) && (\n        !(textWidth > ly || textHeight > lx) ||\n        ((textWidth < textHeight) !== (lx < ly))\n    )) {\n        rotate += 90;\n    }\n\n    var t = getRotatedTextSize(textBB, rotate);\n\n    var scale = 1;\n    if(constrained) {\n        scale = Math.min(\n            1,\n            lx / t.x,\n            ly / t.y\n        );\n    }\n\n    // compute text and target positions\n    var textX = (\n        textBB.left * toLeft +\n        textBB.right * toRight\n    );\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var targetX = (\n        (x0 + TEXTPAD) * toLeft +\n        (x1 - TEXTPAD) * toRight\n    );\n    var targetY = (y0 + y1) / 2;\n    var anchorX = 0;\n    var anchorY = 0;\n    if(isStart || isEnd) {\n        var extrapad = (isHorizontal ? t.x : t.y) / 2;\n        var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);\n\n        if(isHorizontal) {\n            if(isStart) {\n                targetX = x0 + dir * textpad;\n                anchorX = -dir * extrapad;\n            } else {\n                targetX = x1 - dir * textpad;\n                anchorX = dir * extrapad;\n            }\n        } else {\n            if(isStart) {\n                targetY = y0 + dir * textpad;\n                anchorY = -dir * extrapad;\n            } else {\n                targetY = y1 - dir * textpad;\n                anchorY = dir * extrapad;\n            }\n        }\n    }\n\n    return {\n        textX: textX,\n        textY: textY,\n        targetX: targetX,\n        targetY: targetY,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        scale: scale,\n        rotate: rotate\n    };\n}\n\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n    var isHorizontal = !!opts.isHorizontal;\n    var constrained = !!opts.constrained;\n    var angle = opts.angle || 0;\n\n    var textWidth = textBB.width;\n    var textHeight = textBB.height;\n    var lx = Math.abs(x1 - x0);\n    var ly = Math.abs(y1 - y0);\n\n    var textpad;\n    // Keep the padding so the text doesn't sit right against\n    // the bars, but don't factor it into barWidth\n    if(isHorizontal) {\n        textpad = (ly > 2 * TEXTPAD) ? TEXTPAD : 0;\n    } else {\n        textpad = (lx > 2 * TEXTPAD) ? TEXTPAD : 0;\n    }\n\n    // compute rotate and scale\n    var scale = 1;\n    if(constrained) {\n        scale = (isHorizontal) ?\n            Math.min(1, ly / textHeight) :\n            Math.min(1, lx / textWidth);\n    }\n\n    var rotate = getRotateFromAngle(angle);\n    var t = getRotatedTextSize(textBB, rotate);\n\n    // compute text and target positions\n    var extrapad = (isHorizontal ? t.x : t.y) / 2;\n    var textX = (textBB.left + textBB.right) / 2;\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var targetX = (x0 + x1) / 2;\n    var targetY = (y0 + y1) / 2;\n    var anchorX = 0;\n    var anchorY = 0;\n\n    var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);\n    if(isHorizontal) {\n        targetX = x1 - dir * textpad;\n        anchorX = dir * extrapad;\n    } else {\n        targetY = y1 + dir * textpad;\n        anchorY = -dir * extrapad;\n    }\n\n    return {\n        textX: textX,\n        textY: textY,\n        targetX: targetX,\n        targetY: targetY,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        scale: scale,\n        rotate: rotate\n    };\n}\n\nfunction getText(fullLayout, cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var texttemplate = trace.texttemplate;\n\n    var value;\n    if(texttemplate) {\n        value = calcTexttemplate(fullLayout, cd, index, xa, ya);\n    } else if(trace.textinfo) {\n        value = calcTextinfo(cd, index, xa, ya);\n    } else {\n        value = helpers.getValue(trace.text, index);\n    }\n\n    return helpers.coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n    var value = helpers.getValue(trace.textposition, index);\n    return helpers.coerceEnumerated(attributeTextPosition, value);\n}\n\nfunction calcTexttemplate(fullLayout, cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n    if(!texttemplate) return '';\n    var isWaterfall = (trace.type === 'waterfall');\n    var isFunnel = (trace.type === 'funnel');\n\n    var pLetter, pAxis;\n    var vLetter, vAxis;\n    if(trace.orientation === 'h') {\n        pLetter = 'y';\n        pAxis = ya;\n        vLetter = 'x';\n        vAxis = xa;\n    } else {\n        pLetter = 'x';\n        pAxis = xa;\n        vLetter = 'y';\n        vAxis = ya;\n    }\n\n    function formatLabel(u) {\n        return tickText(pAxis, u, true).text;\n    }\n\n    function formatNumber(v) {\n        return tickText(vAxis, +v, true).text;\n    }\n\n    var cdi = cd[index];\n    var obj = {};\n\n    obj.label = cdi.p;\n    obj.labelLabel = obj[pLetter + 'Label'] = formatLabel(cdi.p);\n\n    var tx = Lib.castOption(trace, cdi.i, 'text');\n    if(tx === 0 || tx) obj.text = tx;\n\n    obj.value = cdi.s;\n    obj.valueLabel = obj[vLetter + 'Label'] = formatNumber(cdi.s);\n\n    var pt = {};\n    appendArrayPointValue(pt, trace, cdi.i);\n\n    if(isWaterfall) {\n        obj.delta = +cdi.rawS || cdi.s;\n        obj.deltaLabel = formatNumber(obj.delta);\n        obj.final = cdi.v;\n        obj.finalLabel = formatNumber(obj.final);\n        obj.initial = obj.final - obj.delta;\n        obj.initialLabel = formatNumber(obj.initial);\n    }\n\n    if(isFunnel) {\n        obj.value = cdi.s;\n        obj.valueLabel = formatNumber(obj.value);\n\n        obj.percentInitial = cdi.begR;\n        obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n        obj.percentPrevious = cdi.difR;\n        obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n        obj.percentTotal = cdi.sumR;\n        obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n    }\n\n    var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n    if(customdata) obj.customdata = customdata;\n    return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\n\nfunction calcTextinfo(cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var isHorizontal = (trace.orientation === 'h');\n    var isWaterfall = (trace.type === 'waterfall');\n    var isFunnel = (trace.type === 'funnel');\n\n    function formatLabel(u) {\n        var pAxis = isHorizontal ? ya : xa;\n        return tickText(pAxis, u, true).text;\n    }\n\n    function formatNumber(v) {\n        var sAxis = isHorizontal ? xa : ya;\n        return tickText(sAxis, +v, true).text;\n    }\n\n    var textinfo = trace.textinfo;\n    var cdi = cd[index];\n\n    var parts = textinfo.split('+');\n    var text = [];\n    var tx;\n\n    var hasFlag = function(flag) { return parts.indexOf(flag) !== -1; };\n\n    if(hasFlag('label')) {\n        text.push(formatLabel(cd[index].p));\n    }\n\n    if(hasFlag('text')) {\n        tx = Lib.castOption(trace, cdi.i, 'text');\n        if(tx === 0 || tx) text.push(tx);\n    }\n\n    if(isWaterfall) {\n        var delta = +cdi.rawS || cdi.s;\n        var final = cdi.v;\n        var initial = final - delta;\n\n        if(hasFlag('initial')) text.push(formatNumber(initial));\n        if(hasFlag('delta')) text.push(formatNumber(delta));\n        if(hasFlag('final')) text.push(formatNumber(final));\n    }\n\n    if(isFunnel) {\n        if(hasFlag('value')) text.push(formatNumber(cdi.s));\n\n        var nPercent = 0;\n        if(hasFlag('percent initial')) nPercent++;\n        if(hasFlag('percent previous')) nPercent++;\n        if(hasFlag('percent total')) nPercent++;\n\n        var hasMultiplePercents = nPercent > 1;\n\n        if(hasFlag('percent initial')) {\n            tx = Lib.formatPercent(cdi.begR);\n            if(hasMultiplePercents) tx += ' of initial';\n            text.push(tx);\n        }\n        if(hasFlag('percent previous')) {\n            tx = Lib.formatPercent(cdi.difR);\n            if(hasMultiplePercents) tx += ' of previous';\n            text.push(tx);\n        }\n        if(hasFlag('percent total')) {\n            tx = Lib.formatPercent(cdi.sumR);\n            if(hasMultiplePercents) tx += ' of total';\n            text.push(tx);\n        }\n    }\n\n    return text.join('<br>');\n}\n\nmodule.exports = {\n    plot: plot,\n    toMoveInsideBar: toMoveInsideBar\n};\n"]},"metadata":{},"sourceType":"script"}