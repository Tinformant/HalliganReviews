{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar partition = require('./partition');\n\nvar styleOne = require('./style').styleOne;\n\nvar constants = require('./constants');\n\nvar helpers = require('../sunburst/helpers');\n\nvar attachFxHandlers = require('../sunburst/fx');\n\nvar formatSliceLabel = require('../sunburst/plot').formatSliceLabel;\n\nvar onPathbar = false; // for Descendants\n\nmodule.exports = function drawDescendants(gd, cd, entry, slices, opts) {\n  var width = opts.width;\n  var height = opts.height;\n  var viewX = opts.viewX;\n  var viewY = opts.viewY;\n  var pathSlice = opts.pathSlice;\n  var toMoveInsideSlice = opts.toMoveInsideSlice;\n  var strTransform = opts.strTransform;\n  var hasTransition = opts.hasTransition;\n  var handleSlicesExit = opts.handleSlicesExit;\n  var makeUpdateSliceInterpolator = opts.makeUpdateSliceInterpolator;\n  var makeUpdateTextInterpolator = opts.makeUpdateTextInterpolator;\n  var prevEntry = opts.prevEntry;\n  var refRect = {};\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hasLeft = trace.textposition.indexOf('left') !== -1;\n  var hasRight = trace.textposition.indexOf('right') !== -1;\n  var hasBottom = trace.textposition.indexOf('bottom') !== -1;\n  var noRoomForHeader = !hasBottom && !trace.marker.pad.t || hasBottom && !trace.marker.pad.b; // N.B. slice data isn't the calcdata,\n  // grab corresponding calcdata item in sliceData[i].data.data\n\n  var allData = partition(entry, [width, height], {\n    packing: trace.tiling.packing,\n    squarifyratio: trace.tiling.squarifyratio,\n    flipX: trace.tiling.flip.indexOf('x') > -1,\n    flipY: trace.tiling.flip.indexOf('y') > -1,\n    pad: {\n      inner: trace.tiling.pad,\n      top: trace.marker.pad.t,\n      left: trace.marker.pad.l,\n      right: trace.marker.pad.r,\n      bottom: trace.marker.pad.b\n    }\n  });\n  var sliceData = allData.descendants();\n  var minVisibleDepth = Infinity;\n  var maxVisibleDepth = -Infinity;\n  sliceData.forEach(function (pt) {\n    var depth = pt.depth;\n\n    if (depth >= trace._maxDepth) {\n      // hide slices that won't show up on graph\n      pt.x0 = pt.x1 = (pt.x0 + pt.x1) / 2;\n      pt.y0 = pt.y1 = (pt.y0 + pt.y1) / 2;\n    } else {\n      minVisibleDepth = Math.min(minVisibleDepth, depth);\n      maxVisibleDepth = Math.max(maxVisibleDepth, depth);\n    }\n  });\n  slices = slices.data(sliceData, helpers.getPtId);\n  trace._maxVisibleLayers = isFinite(maxVisibleDepth) ? maxVisibleDepth - minVisibleDepth + 1 : 0;\n  slices.enter().append('g').classed('slice', true);\n  handleSlicesExit(slices, onPathbar, refRect, [width, height], pathSlice);\n  slices.order(); // next coords of previous entry\n\n  var nextOfPrevEntry = null;\n\n  if (hasTransition && prevEntry) {\n    var prevEntryId = helpers.getPtId(prevEntry);\n    slices.each(function (pt) {\n      if (nextOfPrevEntry === null && helpers.getPtId(pt) === prevEntryId) {\n        nextOfPrevEntry = {\n          x0: pt.x0,\n          x1: pt.x1,\n          y0: pt.y0,\n          y1: pt.y1\n        };\n      }\n    });\n  }\n\n  var getRefRect = function () {\n    return nextOfPrevEntry || {\n      x0: 0,\n      x1: width,\n      y0: 0,\n      y1: height\n    };\n  };\n\n  var updateSlices = slices;\n\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: true,\n        hideOnLeaves: false,\n        isTransitioning: false\n      });\n    });\n  }\n\n  updateSlices.each(function (pt) {\n    var isHeader = helpers.isHeader(pt, trace);\n    pt._hoverX = viewX(pt.x1 - trace.marker.pad.r), pt._hoverY = hasBottom ? viewY(pt.y1 - trace.marker.pad.b / 2) : viewY(pt.y0 + trace.marker.pad.t / 2);\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', 'all');\n    });\n\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      styleOne: styleOne,\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace, {\n      hovered: false\n    });\n\n    if (pt.x0 === pt.x1 || pt.y0 === pt.y1) {\n      pt._text = '';\n    } else {\n      if (isHeader) {\n        pt._text = noRoomForHeader ? '' : helpers.getPtLabel(pt) || '';\n      } else {\n        pt._text = formatSliceLabel(pt, entry, trace, cd, fullLayout) || '';\n      }\n    }\n\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n    sliceText.text(pt._text || ' ') // use one space character instead of a blank string to avoid jumps during transition\n    .classed('slicetext', true).attr('text-anchor', hasRight ? 'end' : hasLeft || isHeader ? 'start' : 'middle').call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n    pt.textBB = Drawing.bBox(sliceText.node());\n    pt.transform = toMoveInsideSlice(pt, {\n      fontSize: font.size,\n      isHeader: isHeader\n    });\n    pt.transform.fontSize = font.size;\n\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n        return function (t) {\n          return strTransform(interp(t));\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt));\n    }\n  });\n  return nextOfPrevEntry;\n};","map":{"version":3,"sources":["/Users/jingkaisu/Documents/HRfront/HalliganReviews/web_project/node_modules/plotly.js/src/traces/treemap/draw_descendants.js"],"names":["d3","require","Lib","Drawing","svgTextUtils","partition","styleOne","constants","helpers","attachFxHandlers","formatSliceLabel","onPathbar","module","exports","drawDescendants","gd","cd","entry","slices","opts","width","height","viewX","viewY","pathSlice","toMoveInsideSlice","strTransform","hasTransition","handleSlicesExit","makeUpdateSliceInterpolator","makeUpdateTextInterpolator","prevEntry","refRect","fullLayout","_fullLayout","cd0","trace","hasLeft","textposition","indexOf","hasRight","hasBottom","noRoomForHeader","marker","pad","t","b","allData","packing","tiling","squarifyratio","flipX","flip","flipY","inner","top","left","l","right","r","bottom","sliceData","descendants","minVisibleDepth","Infinity","maxVisibleDepth","forEach","pt","depth","_maxDepth","x0","x1","y0","y1","Math","min","max","data","getPtId","_maxVisibleLayers","isFinite","enter","append","classed","order","nextOfPrevEntry","prevEntryId","each","getRefRect","updateSlices","transition","sliceTop","select","setSliceCursor","hideOnRoot","hideOnLeaves","isTransitioning","isHeader","_hoverX","_hoverY","slicePath","ensureSingle","s","style","attrTween","pt2","interp","attr","call","eventDataKeys","transitionTime","CLICK_TRANSITION_TIME","transitionEasing","CLICK_TRANSITION_EASING","_transitioning","hovered","_text","getPtLabel","sliceTextGroup","sliceText","font","ensureUniformFontSize","determineTextFont","text","convertToTspans","textBB","bBox","node","transform","fontSize","size"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar partition = require('./partition');\nvar styleOne = require('./style').styleOne;\nvar constants = require('./constants');\nvar helpers = require('../sunburst/helpers');\nvar attachFxHandlers = require('../sunburst/fx');\nvar formatSliceLabel = require('../sunburst/plot').formatSliceLabel;\n\nvar onPathbar = false; // for Descendants\n\nmodule.exports = function drawDescendants(gd, cd, entry, slices, opts) {\n    var width = opts.width;\n    var height = opts.height;\n    var viewX = opts.viewX;\n    var viewY = opts.viewY;\n    var pathSlice = opts.pathSlice;\n    var toMoveInsideSlice = opts.toMoveInsideSlice;\n    var strTransform = opts.strTransform;\n    var hasTransition = opts.hasTransition;\n    var handleSlicesExit = opts.handleSlicesExit;\n    var makeUpdateSliceInterpolator = opts.makeUpdateSliceInterpolator;\n    var makeUpdateTextInterpolator = opts.makeUpdateTextInterpolator;\n    var prevEntry = opts.prevEntry;\n    var refRect = {};\n\n    var fullLayout = gd._fullLayout;\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n\n    var hasLeft = trace.textposition.indexOf('left') !== -1;\n    var hasRight = trace.textposition.indexOf('right') !== -1;\n    var hasBottom = trace.textposition.indexOf('bottom') !== -1;\n\n    var noRoomForHeader = (!hasBottom && !trace.marker.pad.t) || (hasBottom && !trace.marker.pad.b);\n\n    // N.B. slice data isn't the calcdata,\n    // grab corresponding calcdata item in sliceData[i].data.data\n    var allData = partition(entry, [width, height], {\n        packing: trace.tiling.packing,\n        squarifyratio: trace.tiling.squarifyratio,\n        flipX: trace.tiling.flip.indexOf('x') > -1,\n        flipY: trace.tiling.flip.indexOf('y') > -1,\n        pad: {\n            inner: trace.tiling.pad,\n            top: trace.marker.pad.t,\n            left: trace.marker.pad.l,\n            right: trace.marker.pad.r,\n            bottom: trace.marker.pad.b,\n        }\n    });\n\n    var sliceData = allData.descendants();\n\n    var minVisibleDepth = Infinity;\n    var maxVisibleDepth = -Infinity;\n    sliceData.forEach(function(pt) {\n        var depth = pt.depth;\n        if(depth >= trace._maxDepth) {\n            // hide slices that won't show up on graph\n            pt.x0 = pt.x1 = (pt.x0 + pt.x1) / 2;\n            pt.y0 = pt.y1 = (pt.y0 + pt.y1) / 2;\n        } else {\n            minVisibleDepth = Math.min(minVisibleDepth, depth);\n            maxVisibleDepth = Math.max(maxVisibleDepth, depth);\n        }\n    });\n\n    slices = slices.data(sliceData, helpers.getPtId);\n\n    trace._maxVisibleLayers = isFinite(maxVisibleDepth) ? maxVisibleDepth - minVisibleDepth + 1 : 0;\n\n    slices.enter().append('g')\n        .classed('slice', true);\n\n    handleSlicesExit(slices, onPathbar, refRect, [width, height], pathSlice);\n\n    slices.order();\n\n    // next coords of previous entry\n    var nextOfPrevEntry = null;\n    if(hasTransition && prevEntry) {\n        var prevEntryId = helpers.getPtId(prevEntry);\n        slices.each(function(pt) {\n            if(nextOfPrevEntry === null && (helpers.getPtId(pt) === prevEntryId)) {\n                nextOfPrevEntry = {\n                    x0: pt.x0,\n                    x1: pt.x1,\n                    y0: pt.y0,\n                    y1: pt.y1\n                };\n            }\n        });\n    }\n\n    var getRefRect = function() {\n        return nextOfPrevEntry || {\n            x0: 0,\n            x1: width,\n            y0: 0,\n            y1: height\n        };\n    };\n\n    var updateSlices = slices;\n    if(hasTransition) {\n        updateSlices = updateSlices.transition().each('end', function() {\n            // N.B. gd._transitioning is (still) *true* by the time\n            // transition updates get here\n            var sliceTop = d3.select(this);\n            helpers.setSliceCursor(sliceTop, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: false,\n                isTransitioning: false\n            });\n        });\n    }\n\n    updateSlices.each(function(pt) {\n        var isHeader = helpers.isHeader(pt, trace);\n\n        pt._hoverX = viewX(pt.x1 - trace.marker.pad.r),\n        pt._hoverY = hasBottom ?\n                viewY(pt.y1 - trace.marker.pad.b / 2) :\n                viewY(pt.y0 + trace.marker.pad.t / 2);\n\n        var sliceTop = d3.select(this);\n\n        var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function(s) {\n            s.style('pointer-events', 'all');\n        });\n\n        if(hasTransition) {\n            slicePath.transition().attrTween('d', function(pt2) {\n                var interp = makeUpdateSliceInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n                return function(t) { return pathSlice(interp(t)); };\n            });\n        } else {\n            slicePath.attr('d', pathSlice);\n        }\n\n        sliceTop\n            .call(attachFxHandlers, entry, gd, cd, {\n                styleOne: styleOne,\n                eventDataKeys: constants.eventDataKeys,\n                transitionTime: constants.CLICK_TRANSITION_TIME,\n                transitionEasing: constants.CLICK_TRANSITION_EASING\n            })\n            .call(helpers.setSliceCursor, gd, { isTransitioning: gd._transitioning });\n\n        slicePath.call(styleOne, pt, trace, {\n            hovered: false\n        });\n\n        if(pt.x0 === pt.x1 || pt.y0 === pt.y1) {\n            pt._text = '';\n        } else {\n            if(isHeader) {\n                pt._text = noRoomForHeader ? '' : helpers.getPtLabel(pt) || '';\n            } else {\n                pt._text = formatSliceLabel(pt, entry, trace, cd, fullLayout) || '';\n            }\n        }\n\n        var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n        var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n\n        sliceText.text(pt._text || ' ') // use one space character instead of a blank string to avoid jumps during transition\n            .classed('slicetext', true)\n            .attr('text-anchor', hasRight ? 'end' : (hasLeft || isHeader) ? 'start' : 'middle')\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        pt.textBB = Drawing.bBox(sliceText.node());\n        pt.transform = toMoveInsideSlice(pt, {\n            fontSize: font.size,\n            isHeader: isHeader\n        });\n        pt.transform.fontSize = font.size;\n\n        if(hasTransition) {\n            sliceText.transition().attrTween('transform', function(pt2) {\n                var interp = makeUpdateTextInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n                return function(t) { return strTransform(interp(t)); };\n            });\n        } else {\n            sliceText.attr('transform', strTransform(pt));\n        }\n    });\n\n    return nextOfPrevEntry;\n};\n"]},"metadata":{},"sourceType":"script"}